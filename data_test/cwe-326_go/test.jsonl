{"pre_tt": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"fmt\"\n)\n\nfunc main() {\n\t//Generate Private Key\n\t", "post_tt": "pvk, err := rsa.GenerateKey(rand.Reader,", "key": " 4096", "suffix_pre": "\n", "suffix_post": "\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(pvk)\n}\n", "tt_location": "pref", "lang": "go", "info": {"language": "go", "check_ql": "$CODEQL_HOME/codeql-repo/go/ql/src/Security/CWE-326/InsufficientKeySize.ql", "source": "https://github.com/github/codeql/blob/main/go/ql/src/Security/CWE-326/InsufficientKeySizeGood.go"}}
{"pre_tt": "// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package autocert provides automatic access to certificates from Let's Encrypt\n// and any other ACME-based CA.\n//\n// This package is a work in progress and makes no API stability promises.\npackage main\n\nimport (\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n)\n\n// certState returns a new or existing certState.\n// If a new certState is returned, state.exist is false and the state is locked.\n// The returned error is non-nil only in the case where a new state could not be created.\nfunc (m *Manager) certState(domain string) (*certState, error) {\n\tm.stateMu.Lock()\n\tdefer m.stateMu.Unlock()\n\t// existing state\n\tif state, ok := m.state[domain]; ok {\n\t\treturn state, nil\n\t}\n\n\t// new locked state\n\tvar (\n\t\terr error\n\t\tkey crypto.Signer\n\t)\n\tif m.ForceRSA {\n\t\t", "post_tt": "key, err = rsa.GenerateKey(rand.Reader,", "key": " 4096", "suffix_pre": "\n", "suffix_post": "\t} else {\n\t\tkey, err = ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstate := &certState{\n\t\tkey:    key,\n\t\tlocked: true,\n\t}\n\tstate.Lock() // will be unlocked by m.certState caller\n\tm.state[domain] = state\n\treturn state, nil\n}\n\nfunc main() {\n\tmanager := Manager{}\n\tstate, err := manager.certState(\"domain\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tprintln(state)\n}\n", "tt_location": "pref", "lang": "go", "info": {"language": "go", "check_ql": "$CODEQL_HOME/codeql-repo/go/ql/src/Security/CWE-326/InsufficientKeySize.ql", "source": "https://github.com/jmhodges/crypto/blob/f6b343c37ca80bfa8ea539da67a0b621f84fab1d/acme/autocert/autocert.go#L401"}}
{"pre_tt": "// Copyright 2021 The Gitea Authors. All rights reserved.\n// SPDX-License-Identifier: MIT\n\npackage main\n\nimport (\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\n// loadOrCreateAsymmetricKey checks if the configured private key exists.\n// If it does not exist a new random key gets generated and saved on the configured path.\nfunc loadOrCreateAsymmetricKey(keyPath string, algorithm string) (any, error) {\n\n\tkey, err := func() (any, error) {\n\t\tswitch {\n\t\tcase strings.HasPrefix(algorithm, \"RS\"):\n\t\t\t", "post_tt": "return rsa.GenerateKey(rand.Reader,", "key": " 4096", "suffix_pre": "\n", "suffix_post": "\t\tcase algorithm == \"EdDSA\":\n\t\t\t_, pk, err := ed25519.GenerateKey(rand.Reader)\n\t\t\treturn pk, err\n\t\tdefault:\n\t\t\treturn ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\t\t}\n\t}()\n\n\tbytes, err := x509.MarshalPKCS8PrivateKey(key)\n\n\tprivateKeyPEM := &pem.Block{Type: \"PRIVATE KEY\", Bytes: bytes}\n\n\tf, err := os.OpenFile(keyPath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0o600)\n\tdefer func() {\n\t\tif err = f.Close(); err != nil {\n\t\t\tfmt.Printf(\"Close: %v\", err)\n\t\t}\n\t}()\n\n\tpem.Encode(f, privateKeyPEM)\n\n\tblock, _ := pem.Decode(bytes)\n\tif block == nil {\n\t\treturn nil, fmt.Errorf(\"no valid PEM data found in %s\", keyPath)\n\t} else if block.Type != \"PRIVATE KEY\" {\n\t\treturn nil, fmt.Errorf(\"expected PRIVATE KEY, got %s in %s\", block.Type, keyPath)\n\t}\n\n\treturn x509.ParsePKCS8PrivateKey(block.Bytes)\n}\n\nfunc main() {\n\tloadOrCreateAsymmetricKey(\"key\", \"RSA\")\n}\n", "tt_location": "pref", "lang": "go", "info": {"language": "go", "check_ql": "$CODEQL_HOME/codeql-repo/go/ql/src/Security/CWE-326/InsufficientKeySize.ql", "source": "https://github.com/blender/gitea/blob/7a286e47532a31ed6abcde3a45da4bad1653a42e/services/auth/source/oauth2/jwtsigningkey.go#L356"}}
{"pre_tt": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"hash/fnv\"\n\t\"math/big\"\n)\n\nfunc ParsePemKey(pemKey string) (*rsa.PrivateKey, error) {\n\tblock, _ := pem.Decode([]byte(pemKey))\n\n\tpriv, _ := x509.ParsePKCS1PrivateKey(block.Bytes)\n\n\treturn priv, nil\n}\n\nfunc (a *Authority) createClientCertificateLocal() (\n\tclientCert *tls.Certificate, err error) {\n\n\tprivateKey, err := ParsePemKey(a.PrivateKey)\n\n\tblock, _ := pem.Decode([]byte(a.RootCertificate))\n\n\trootCert, err := x509.ParseCertificate(block.Bytes)\n\n\t", "post_tt": "clientPrivateKey, err := rsa.GenerateKey(rand.Reader,", "key": " 4096", "suffix_pre": "\n", "suffix_post": "\tif err != nil {\n\t\terr = errors.New(\"authority: Failed to generate rsa key\")\n\t\treturn\n\t}\n\n\tserialHash := fnv.New64a()\n\t_, _ = serialHash.Write([]byte(\"12345678\"))\n\tserial := &big.Int{}\n\tserial.SetUint64(serialHash.Sum64())\n\n\tcertBytes, err := x509.CreateCertificate(\n\t\trand.Reader,\n\t\trootCert,\n\t\tclientPrivateKey.Public(),\n\t\tprivateKey,\n\t)\n\n\tcertBlock := &pem.Block{\n\t\tType:  \"CERTIFICATE\",\n\t\tBytes: certBytes,\n\t}\n\n\tcertPem := pem.EncodeToMemory(certBlock)\n\n\tprivateBlock := &pem.Block{\n\t\tType:  \"RSA PRIVATE KEY\",\n\t\tBytes: x509.MarshalPKCS1PrivateKey(clientPrivateKey),\n\t}\n\n\tclientKeyPem := pem.EncodeToMemory(privateBlock)\n\n\tcert, err := tls.X509KeyPair(certPem, clientKeyPem)\n\tclientCert = &cert\n\n\treturn\n}\n\nfunc main() {\n\tauthority := Authority{}\n\t_, err := authority.createClientCertificateLocal()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n", "tt_location": "pref", "lang": "go", "info": {"language": "go", "check_ql": "$CODEQL_HOME/codeql-repo/go/ql/src/Security/CWE-326/InsufficientKeySize.ql", "source": "https://github.com/mars79668/pritunl-zero/blob/007b2773a3786887c7ea8cb414404e5f8a1799f9/authority/authority.go#L1078"}}
