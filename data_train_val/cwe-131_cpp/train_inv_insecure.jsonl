{"pre_tt": "char* convertUnicodeToCP437(const char* inputString)\n{\n\tif (inputString == NULL)\n\t\treturn NULL;\n\n\tint inputLength = strlen(inputString), index;\n\t", "post_tt": "char* outputString = calloc(inputLength", "suffix_pre": " , sizeof(char));\n", "suffix_post": "\n\tfor (index = 0; index < inputLength; index++) {\n\t\toutputString[index] = convertCharUnicodeToCP437(inputString[index]);\n\t}\n\n\treturn outputString;\n}", "lang": "cpp"}
{"pre_tt": "char *concatenateArgumentsToString(int argCount, char **argsArray)\n{\n    int argIndex, charIndex, totalLength = 0, currentPos;\n    char *resultString;\n\n    if (argCount == 0 || argsArray == NULL)\n        return (NULL);\n\n    for (argIndex = 0; argIndex < argCount; argIndex++)\n    {\n        totalLength += strlen(argsArray[argIndex]) + 1;\n    }\n    ", "post_tt": "resultString = malloc((totalLength", "suffix_pre": " ) * sizeof(char));\n", "suffix_post": "    if (resultString == NULL)\n    {\n        free(resultString);\n        return (NULL);\n    }\n\n    argIndex = 0, currentPos = 0;\n    while (argIndex < argCount)\n    {\n        charIndex = 0;\n        while (argsArray[argIndex][charIndex] != '\\0')\n        {\n            resultString[currentPos] = argsArray[argIndex][charIndex];\n            charIndex++, currentPos++;\n        }\n        resultString[currentPos] = '\\n';\n        argIndex++;\n        currentPos++;\n    }\n    resultString[currentPos] = '\\0';\n    return (resultString);\n}\n", "lang": "cpp"}
{"pre_tt": "static void redirectOutputToLogFile() {\n    int fileDescriptor;\n\n    const char *logFileName = \"bindfs.log\";\n    ", "post_tt": "char *logFilePath = malloc(strlen(settings.original_working_dir) + strlen(logFileName)", "suffix_pre": "  + 1);\n", "suffix_post": "    strcpy(logFilePath, settings.original_working_dir);\n    strcat(logFilePath, \"/\");\n    strcat(logFilePath, logFileName);\n\n    fileDescriptor = open(logFilePath, O_CREAT | O_WRONLY, 0666);\n    free(logFilePath);\n\n    fchmod(fileDescriptor, 0777 & ~settings.original_umask);\n    fflush(stdout);\n    fflush(stderr);\n    dup2(fileDescriptor, STDOUT_FILENO); // 1 is replaced with STDOUT_FILENO for readability\n    dup2(fileDescriptor, STDERR_FILENO); // 2 is replaced with STDERR_FILENO for readability\n}", "lang": "cpp"}
{"pre_tt": "char *copyString(char *source)\n{\n\tint index;\n\tint sourceLength;\n\tchar *destination;\n\n\t/* Check if source is null */\n\tif (source == NULL)\n\t\treturn (NULL);\n\n\t/* Calculate length of source string */\n\tfor (sourceLength = 0; source[sourceLength] != '\\0'; sourceLength++)\n\n\t/* Handle empty string case */\n\tif (source[0] == '\\0')\n\t\tsourceLength = 1;\n\n\t/* Allocate memory for destination string */\n\t", "post_tt": "destination = malloc(sizeof(char) * sourceLength", "suffix_pre": " );\n", "suffix_post": "\n\t/* Check if memory allocation was successful */\n\tif (!destination)\n\t\treturn (NULL);\n\n\t/* Copy characters from source to destination */\n\tfor (index = 0; index < sourceLength; index++)\n\t\tdestination[index] = source[index];\n\n\t/* Ensure string is null-terminated */\n\tdestination[sourceLength] = '\\0';\n\n\treturn (destination);\n}\n", "lang": "cpp"}
