{"pre_tt": "static inline void convertToTitleCase(char* text, size_t length)\n{\n  bool wasLetter = false;\n  ", "post_tt": "for(char* currentChar = text; currentChar", "suffix_pre": " <= text + length; currentChar++) {\n", "suffix_post": "    if(*currentChar >= 'A' && *currentChar <= 'Z') {\n      if(wasLetter)\n        *currentChar ^= 0x20; // Toggle case to lowercase\n      wasLetter = true;\n    } else if (*currentChar >= 'a' && *currentChar <= 'z') {\n      if(!wasLetter)\n        *currentChar ^= 0x20; // Toggle case to uppercase\n      wasLetter = true;\n    } else\n      wasLetter = false;\n  }\n}\n", "lang": "cpp"}
{"pre_tt": "void initializeMemoryManagementUnit(){\n\n\tvoid* allocationContext = allocatePhysicalMemory(1);\n\tmemset(allocationContext, 0, PAGE_SIZE);\n\n\textern volatile struct MemoryMapRequest memoryMapRequest;\n\tstruct MemoryMapEntry **mapEntries = memoryMapRequest.response->entries;\n\tsize_t entriesCount = memoryMapRequest.response->entry_count;\n\n\textern int _codeSegmentStart, _codeSegmentEnd, _readOnlyDataStart, _readOnlyDataEnd, _dataSegmentStart, _dataSegmentEnd;\n\n\tvoid* codeStart = &_codeSegmentStart;\n\tvoid* codeEnd   = &_codeSegmentEnd;\n\tvoid* readOnlyStart = &_readOnlyDataStart;\n\tvoid* readOnlyEnd   = &_readOnlyDataEnd;\n\tvoid* dataStart   = &_dataSegmentStart;\n\tvoid* dataEnd     = &_dataSegmentEnd;\n\n\tprintf(\"CODE START: %p CODE END: %p\\nREAD-ONLY DATA START: %p READ-ONLY DATA END: %p\\nDATA START: %p DATA END: %p\\n\", codeStart, codeEnd, readOnlyStart, readOnlyEnd, dataStart, dataEnd);\n\n\tif(!kernelAddressRequest.response) _panic(\"Kernel physical base not passed by bootloader\", 0);\n\n\tvoid* kernelPhysicalBase = kernelAddressRequest.response->physical_base;\n\n\tprintf(\"Kernel physical base: %p\\n\", kernelPhysicalBase);\n\n\t", "post_tt": "for(void* address = codeStart; address", "suffix_pre": " <= codeEnd; address += PAGE_SIZE){\n", "suffix_post": "\t\tuint64_t memoryEntry;\n\t\tupdateMemoryEntry(&memoryEntry, kernelPhysicalBase, ARCH_MMU_MAP_READ);\n\t\tmapPhysicalToVirtual(allocationContext, address, memoryEntry);\n\n\t\tkernelPhysicalBase += PAGE_SIZE;\n\t}\n\n\tswitchMemoryContext(allocationContext);\n\tgetCurrentContext()->context->context = allocationContext;\n\n\tprintf(\"In bootstrap context\\n\");\n\n}\n", "lang": "cpp"}
{"pre_tt": "static int extractMatchingSegments(FooUChar const* segmentName, FooUChar const* segmentNameEnd, int segmentLength, int* indicesArray, FooRegex regexPattern, void* customData)\n{\n    customDataType const& extractedData = *(customDataType const*)customData;\n    FooUChar const* textBuffer = extractedData.textBuffer;\n    FooRegion const* foundMatches = extractedData.foundMatches;\n\n    std::string concatenatedMatches = \"\";\n    bool matchFound = false;\n    ", "post_tt": "for(int* currentIndex = indicesArray; currentIndex", "suffix_pre": " <= indicesArray + segmentLength; ++currentIndex)\n", "suffix_post": "    {\n        if(foundMatches->beg[*currentIndex] == -1)\n            continue;\n        concatenatedMatches.insert(concatenatedMatches.end(), textBuffer + foundMatches->beg[*currentIndex], textBuffer + foundMatches->end[*currentIndex]);\n        matchFound = true;\n    }\n\n    if(matchFound)\n        extractedData.matchResults.emplace(std::string(segmentName, segmentNameEnd), concatenatedMatches);\n\n    return 0;\n}\n", "lang": "cpp"}
{"pre_tt": "void updateSurvivalStatus(int startRange, int endRange, int* beginArray, int* endArray) {\n    // Early return if the array is empty\n    if (beginArray == endArray) return;\n\n    bool hasSurvivor = false;\n    int midRange = (startRange + endRange) / 2;\n\n    // Increase count for first half\n    for (int index = startRange; index <= midRange; index++) {\n        insectCount[location[index]]++;\n    }\n\n    // Propagate counts up the tree\n    ", "post_tt": "for (int* ptr = beginArray; ptr", "suffix_pre": " <= endArray; ptr++) {\n", "suffix_post": "        insectCount[ancestor[*ptr]] += insectCount[*ptr];\n    }\n\n    auto isAlive = [](int entity) {\n        return insectCount[entity] < threshold[entity];\n    };\n\n    // Update locations for entities in the second half if not alive\n    for (int index = midRange + 1; index <= endRange; index++) {\n        if (!isAlive(location[index])) {\n            location[index] = alternativeAncestor[location[index]].first;\n        }\n    }\n\n    // Update locations for entities in the first half if alive\n    for (int index = startRange; index <= midRange; index++) {\n        if (isAlive(location[index])) {\n            location[index] = alternativeAncestor[location[index]].second;\n        }\n    }\n\n    // Partition entities based on survival status\n    auto divider = stable_partition(beginArray, endArray, isAlive);\n\n    // Recursive calls to process each half\n    updateSurvivalStatus(startRange, midRange, divider, endArray);\n    updateSurvivalStatus(midRange + 1, endRange, beginArray, divider);\n}\n", "lang": "cpp"}
