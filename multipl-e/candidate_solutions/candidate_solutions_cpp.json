[
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n  return string.length();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n  return string.length();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n  return string.length();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n  return string.length();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n  return string.length();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n  return string.length();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n  return string.length();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n  return string.length();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n  return string.length();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n  return string.length();\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n  for (int i = 0; i < s.length(); i++) {\n    char c = s[i];\n    if (isalpha(c)) {\n      char a = isupper(c) ? 'A' : 'a';\n      s[i] = a + (c - a + 4) % 26;\n    }\n  }\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n  for(int i = 0; i < s.length(); i++) {\n    char c = s[i];\n    if(c >= 'a' && c <= 'z') {\n      s[i] = 'a' + (c - 'a' + 4) % 26;\n    }\n    else if(c >= 'A' && c <= 'Z') {\n      s[i] = 'A' + (c - 'A' + 4) % 26;\n    }\n  }\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n  for(int i = 0; i < s.size(); i++){\n    s[i] = (s[i] - 'a' + 4) % 26 + 'a';\n  }\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n  for(int i = 0; i < s.length(); i++) {\n    char c = s[i];\n    if(c >= 'a' && c <= 'z') {\n      c = 'a' + (c - 'a' + 4) % 26;\n    } else if(c >= 'A' && c <= 'Z') {\n      c = 'A' + (c - 'A' + 4) % 26;\n    }\n    s[i] = c;\n  }\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n  for(int i = 0; i < s.length(); i++) {\n    s[i] = ((s[i] - 'a' + 4) % 26) + 'a';\n  }\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n  for (int i = 0; i < s.length(); i++) {\n    char c = s[i];\n    if (c >= 'a' && c <= 'z') {\n      c = ((c - 'a' + 4) % 26) + 'a';\n    } else if (c >= 'A' && c <= 'Z') {\n      c = ((c - 'A' + 4) % 26) + 'A';\n    }\n    s[i] = c;\n  }\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n  for (int i = 0; i < s.length(); i++) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      s[i] = 'a' + (s[i] - 'a' + 4) % 26;\n    } else if (s[i] >= 'A' && s[i] <= 'Z') {\n      s[i] = 'A' + (s[i] - 'A' + 4) % 26;\n    }\n  }\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n  for (int i = 0; i < s.length(); i++) {\n    if (isalpha(s[i])) {\n      char base = isupper(s[i]) ? 'A' : 'a';\n      s[i] = (s[i] - base + 4) % 26 + base;\n    }\n  }\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n  for(int i = 0; i < s.length(); i++) {\n    s[i] = 'a' + (s[i] - 'a' + 4) % 26;\n  }\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n  for (int i = 0; i < s.length(); i++) {\n    char c = s[i];\n    if (c >= 'a' && c <= 'z') {\n      c = ((c - 'a' + 4) % 26) + 'a';\n    } else if (c >= 'A' && c <= 'Z') {\n      c = ((c - 'A' + 4) % 26) + 'A';\n    }\n    s[i] = c;\n  }\n  return s;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool isLower = islower(dict.begin()->first[0]);\n  bool isUpper = isupper(dict.begin()->first[0]);\n\n  for (auto const& pair : dict) {\n    for (char c : pair.first) {\n      if (isLower && isupper(c)) {\n        return false;\n      }\n      if (isUpper && islower(c)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) return false;\n  \n  bool isLower = islower(dict.begin()->first[0]);\n  bool isUpper = isupper(dict.begin()->first[0]);\n\n  for (auto &pair : dict) {\n    if (isLower && !islower(pair.first[0])) return false;\n    if (isUpper && !isupper(pair.first[0])) return false;\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) return false;\n\n  bool isLower = islower(dict.begin()->first[0]);\n  bool isUpper = isupper(dict.begin()->first[0]);\n\n  for (auto &pair : dict) {\n    for (char c : pair.first) {\n      if (isLower && isupper(c)) return false;\n      if (isUpper && islower(c)) return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool isLower = islower(dict.begin()->first[0]);\n  bool isUpper = isupper(dict.begin()->first[0]);\n\n  for(auto &pair : dict) {\n    if(isLower) {\n      for(char &c : pair.first) {\n        if(isupper(c)) {\n          return false;\n        }\n      }\n    } else if(isUpper) {\n      for(char &c : pair.first) {\n        if(islower(c)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) return false;\n\n  bool isLower = islower(dict.begin()->first[0]);\n  bool isUpper = isupper(dict.begin()->first[0]);\n\n  for (auto &pair : dict) {\n    for (char &c : pair.first) {\n      if (isLower && isupper(c)) return false;\n      if (isUpper && islower(c)) return false;\n    }\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) return false;\n  \n  bool isLower = islower(dict.begin()->first[0]);\n  bool isUpper = isupper(dict.begin()->first[0]);\n\n  for (auto &pair : dict) {\n    for (char c : pair.first) {\n      if (isLower && isupper(c)) return false;\n      if (isUpper && islower(c)) return false;\n    }\n  }\n  \n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) return false;\n\n  bool isLower = islower(dict.begin()->first[0]);\n  bool isUpper = isupper(dict.begin()->first[0]);\n\n  for (auto const& pair : dict) {\n    for (char c : pair.first) {\n      if (isLower && isupper(c)) return false;\n      if (isUpper && islower(c)) return false;\n    }\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool isLower = islower(dict.begin()->first[0]);\n  bool isUpper = isupper(dict.begin()->first[0]);\n\n  for (const auto& pair : dict) {\n    if (isLower) {\n      for (const auto& c : pair.first) {\n        if (isupper(c)) {\n          return false;\n        }\n      }\n    } else if (isUpper) {\n      for (const auto& c : pair.first) {\n        if (islower(c)) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool isLower = islower(dict.begin()->first[0]);\n  bool isUpper = isupper(dict.begin()->first[0]);\n\n  for (auto &pair : dict) {\n    for (char c : pair.first) {\n      if (isLower && isupper(c)) {\n        return false;\n      }\n      if (isUpper && islower(c)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool isLower = islower(dict.begin()->first[0]);\n  bool isUpper = isupper(dict.begin()->first[0]);\n\n  for (auto &pair : dict) {\n    for (char c : pair.first) {\n      if (isLower && isupper(c)) {\n        return false;\n      }\n      if (isUpper && islower(c)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n  std::string result = \"\";\n  int space_count = 0;\n  \n  for (char c : text) {\n    if (c == ' ') {\n      space_count++;\n      if (space_count == 1) {\n        result += '_';\n      } else if (space_count == 2) {\n        result.back() = '-';\n      }\n    } else {\n      space_count = 0;\n      result += c;\n    }\n  }\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n  std::string result = \"\";\n  for (int i = 0; i < text.length(); i++) {\n    if (text[i] == ' ') {\n      int count = 0;\n      while (i < text.length() && text[i] == ' ') {\n        i++;\n        count++;\n      }\n      if (count > 2)\n        result += \"-\";\n      else\n        result += \"_\";\n    }\n    if (i < text.length())\n      result += text[i];\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int spaceCount = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            spaceCount++;\n            if (spaceCount > 2) {\n                if (result.back() != '-') {\n                    result.pop_back();\n                    result.push_back('-');\n                }\n            } else {\n                result.push_back('_');\n            }\n        } else {\n            spaceCount = 0;\n            result.push_back(c);\n        }\n    }\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    for (int i = 0; i < text.size(); i++) {\n        if (text[i] == ' ') {\n            int j = i + 1;\n            while (j < text.size() && text[j] == ' ') {\n                j++;\n            }\n            if (j - i > 2) {\n                text.replace(i, j - i, \"-\");\n            } else {\n                text.replace(i, j - i, \"_\");\n            }\n            i = j;\n        }\n    }\n    return text;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n  std::string result = \"\";\n  int spaceCount = 0;\n  for (char c : text) {\n    if (c == ' ') {\n      spaceCount++;\n      if (spaceCount > 2) {\n        if (result.back() != '-') {\n          result.pop_back(); // remove last underscore\n          result += '-'; // replace with dash\n        }\n      } else {\n        result += '_';\n      }\n    } else {\n      spaceCount = 0;\n      result += c;\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result = \"\";\n    int spaceCount = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            spaceCount++;\n            if (spaceCount > 2) {\n                if (result.back() != '-') {\n                    result.pop_back();\n                    result.push_back('-');\n                }\n            } else {\n                result.push_back('_');\n            }\n        } else {\n            spaceCount = 0;\n            result.push_back(c);\n        }\n    }\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n  std::string result = \"\";\n  bool isConsecutiveSpace = false;\n\n  for (char c : text) {\n    if (c == ' ') {\n      if (result.empty() || result.back() != '_') {\n        result.push_back('_');\n      } else if (result.back() == '_') {\n        isConsecutiveSpace = true;\n      }\n    } else {\n      result.push_back(c);\n    }\n  }\n\n  if (isConsecutiveSpace) {\n    size_t pos = 0;\n    while ((pos = result.find(\"__\", pos)) != std::string::npos) {\n      result.replace(pos, 2, \"-\");\n      pos += 1;\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result = \"\";\n    int count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            count++;\n            if (count > 2) {\n                if (result.back() != '-') {\n                    result.pop_back();\n                    result.push_back('-');\n                }\n            } else {\n                result.push_back('_');\n            }\n        } else {\n            count = 0;\n            result.push_back(c);\n        }\n    }\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n  std::string result = \"\";\n  int space_count = 0;\n  \n  for (char c : text) {\n    if (c == ' ') {\n      space_count++;\n      if (space_count > 2) {\n        if (result.back() != '-') {\n          result.pop_back();\n          result.push_back('-');\n        }\n      } else {\n        result.push_back('_');\n      }\n    } else {\n      space_count = 0;\n      result.push_back(c);\n    }\n  }\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n  std::string result = \"\";\n  bool consecutive = false;\n  for (char c : text) {\n    if (c == ' ') {\n      if (!result.empty() && result.back() == '_') {\n        if (!consecutive) {\n          result.back() = '-';\n          consecutive = true;\n        }\n      } else {\n        result.push_back('_');\n      }\n    } else {\n      consecutive = false;\n      result.push_back(c);\n    }\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n  if (n == 0 || n == 1) \n    return 0;\n  if (n == 2) \n    return 1;\n\n  long a = 0, b = 0, c = 1, d;\n\n  for (long i = 3; i <= n; i++) {\n    d = a + b + c;\n    a = b;\n    b = c;\n    c = d;\n  }\n\n  return c;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n  if (n == 0 || n == 1) \n    return 0;\n  if (n == 2) \n    return 1;\n\n  long a = 0, b = 0, c = 1, d;\n\n  for (long i = 3; i <= n; i++) {\n    d = a + b + c;\n    a = b;\n    b = c;\n    c = d;\n  }\n\n  return c;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n  if(n==0 || n==1)\n    return 0;\n  if(n==2)\n    return 1;\n  \n  long a = 0, b = 0, c = 1, d;\n  \n  for(long i=3; i<=n; i++){\n    d = a + b + c;\n    a = b;\n    b = c;\n    c = d;\n  }\n  \n  return c;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n  if (n == 0 || n == 1) {\n    return 0;\n  }\n  if (n == 2) {\n    return 1;\n  }\n  \n  long a = 0, b = 0, c = 1, d;\n  \n  for (long i = 3; i <= n; i++) {\n    d = a + b + c;\n    a = b;\n    b = c;\n    c = d;\n  }\n  \n  return c;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n  if (n == 0 || n == 1) {\n    return 0;\n  }\n  if (n == 2) {\n    return 1;\n  }\n\n  long a = 0, b = 0, c = 1, d;\n\n  for (long i = 3; i <= n; i++) {\n    d = a + b + c;\n    a = b;\n    b = c;\n    c = d;\n  }\n\n  return c;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n  if (n == 0 || n == 1) return 0;\n  if (n == 2) return 1;\n\n  long a = 0, b = 0, c = 1, d;\n\n  for (long i = 3; i <= n; i++) {\n    d = a + b + c;\n    a = b;\n    b = c;\n    c = d;\n  }\n  return c;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n  if(n == 0 || n == 1) return 0;\n  if(n == 2) return 1;\n  \n  long a = 0, b = 0, c = 1, d;\n  \n  for(long i = 3; i <= n; i++) {\n    d = a + b + c;\n    a = b;\n    b = c;\n    c = d;\n  }\n  \n  return c;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n  if (n == 0 || n == 1) {\n    return 0;\n  }\n  if (n == 2) {\n    return 1;\n  }\n\n  long a = 0, b = 0, c = 1, d;\n  for (long i = 3; i <= n; i++) {\n    d = a + b + c;\n    a = b;\n    b = c;\n    c = d;\n  }\n\n  return c;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n  if (n == 0 || n == 1) return 0;\n  if (n == 2) return 1;\n\n  long a = 0, b = 0, c = 1, d;\n  for (long i = 3; i <= n; i++) {\n    d = a + b + c;\n    a = b;\n    b = c;\n    c = d;\n  }\n  return c;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n  if (n == 0 || n == 1) \n    return 0;\n  if (n == 2)\n    return 1;\n\n  long a = 0, b = 0, c = 1, d;\n\n  for (long i = 3; i <= n; i++) {\n    d = a + b + c;\n    a = b;\n    b = c;\n    c = d;\n  }\n\n  return c;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (lst[i] > 0 && lst[i] == (int)lst[i] && (int)lst[i] % 2 != 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (lst[i] > 0 && fmod(lst[i], 1) == 0 && (int)lst[i] % 2 != 0) {\n      sum += pow(lst[i], 2);\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n  long sum = 0;\n  for (auto num : lst) {\n    if (num >= 0 && floor(num) == num && (int)num % 2 != 0) {\n      sum += num * num;\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (lst[i] > 0 && (int)lst[i] % 2 != 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n  long sum = 0;\n  for(auto &num : lst) {\n    if(num >= 0 && (int)num == num && (int)num % 2 != 0) {\n      sum += num * num;\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n  long sum = 0;\n  for (auto num : lst) {\n    if (num >= 0 && floor(num) == num && (int)num % 2 != 0) {\n      sum += pow(num, 2);\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (lst[i] > 0 && (int)lst[i] % 2 != 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (lst[i] > 0 && (int)lst[i] % 2 != 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n  long sum = 0;\n  for (auto num : lst) {\n    if (num > 0 && fmod(num, 1) == 0 && (int)num % 2 != 0) {\n      sum += pow(num, 2);\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (lst[i] > 0 && (int)lst[i] % 2 != 0) {\n      sum += pow(lst[i], 2);\n    }\n  }\n  return sum;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n  std::vector<long> result;\n  for (const auto& value : values) {\n    if (value.type() == typeid(long)) {\n      result.push_back(std::any_cast<long>(value));\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n  std::vector<long> result;\n  for (const auto& value : values) {\n    if (value.type() == typeid(int) || value.type() == typeid(long)) {\n      result.push_back(std::any_cast<long>(value));\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n  std::vector<long> result;\n  for (const auto& value : values) {\n    if (value.type() == typeid(long)) {\n      result.push_back(std::any_cast<long>(value));\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n  std::vector<long> result;\n  for (auto& value : values) {\n    if (value.type() == typeid(long)) {\n      result.push_back(std::any_cast<long>(value));\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n  std::vector<long> result;\n  for (const auto& value : values) {\n    if (value.type() == typeid(long)) {\n      result.push_back(std::any_cast<long>(value));\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n  std::vector<long> result;\n  for (const auto& value : values) {\n    if (value.type() == typeid(long)) {\n      result.push_back(std::any_cast<long>(value));\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n  std::vector<long> result;\n  for (const auto& value : values) {\n    if (value.type() == typeid(long)) {\n      result.push_back(std::any_cast<long>(value));\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n  std::vector<long> result;\n  for (const auto& value : values) {\n    if (value.type() == typeid(long)) {\n      result.push_back(std::any_cast<long>(value));\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n  std::vector<long> result;\n  for (const auto& value : values) {\n    if (value.type() == typeid(long)) {\n      result.push_back(std::any_cast<long>(value));\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n  std::vector<long> result;\n  for (auto& value : values) {\n    if (value.type() == typeid(long)) {\n      result.push_back(std::any_cast<long>(value));\n    }\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n  // Since each car moving left to right will collide with each car moving right to left, \n  // the total number of collisions will be n*n.\n  return n * n;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n  return n * n;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n  // Since each car moving from left to right will collide with one car moving from right to left\n  // The total number of collisions will be equal to the number of cars in one direction\n  return n;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n  return n * n;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n  return n * n;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n  return n * n;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n  return n * n;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n  return n * n;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n  // Since each car moving from left to right will collide with one car moving from right to left,\n  // the total number of collisions will be equal to the number of cars in one direction.\n  return n;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n  return n * n;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n  std::vector<long> beats;\n  std::istringstream iss(music_string);\n  std::string note;\n  \n  while (iss >> note) {\n    if (note == \"o\") {\n      beats.push_back(4);\n    } else if (note == \"o|\") {\n      beats.push_back(2);\n    } else if (note == \".|\") {\n      beats.push_back(1);\n    }\n  }\n  \n  return beats;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n  std::vector<long> beats;\n  std::istringstream iss(music_string);\n  std::string note;\n  while (iss >> note) {\n    if (note == \"o\") beats.push_back(4);\n    else if (note == \"o|\") beats.push_back(2);\n    else if (note == \".|\") beats.push_back(1);\n  }\n  return beats;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n  std::vector<long> beats;\n  std::istringstream ss(music_string);\n  std::string note;\n\n  while(std::getline(ss, note, ' ')) {\n    if(note == \"o\") {\n      beats.push_back(4);\n    } else if(note == \"o|\") {\n      beats.push_back(2);\n    } else if(note == \".|\") {\n      beats.push_back(1);\n    }\n  }\n  \n  return beats;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n  std::vector<long> beats;\n  std::istringstream iss(music_string);\n  std::string note;\n  while (iss >> note) {\n    if (note == \"o\") {\n      beats.push_back(4);\n    } else if (note == \"o|\") {\n      beats.push_back(2);\n    } else if (note == \".|\") {\n      beats.push_back(1);\n    }\n  }\n  return beats;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n  std::vector<long> beats;\n  std::istringstream iss(music_string);\n  std::string note;\n  while (iss >> note) {\n    if (note == \"o\") {\n      beats.push_back(4);\n    } else if (note == \"o|\") {\n      beats.push_back(2);\n    } else if (note == \".|\") {\n      beats.push_back(1);\n    }\n  }\n  return beats;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n  std::vector<long> beats;\n  std::istringstream iss(music_string);\n  std::string note;\n  while (iss >> note) {\n    if (note == \"o\") {\n      beats.push_back(4);\n    } else if (note == \"o|\") {\n      beats.push_back(2);\n    } else if (note == \".|\") {\n      beats.push_back(1);\n    }\n  }\n  return beats;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n  std::vector<long> beats;\n  std::istringstream iss(music_string);\n  std::string note;\n  while (iss >> note) {\n    if (note == \"o\") {\n      beats.push_back(4);\n    } else if (note == \"o|\") {\n      beats.push_back(2);\n    } else if (note == \".|\") {\n      beats.push_back(1);\n    }\n  }\n  return beats;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n  std::vector<long> beats;\n  std::istringstream iss(music_string);\n  std::string note;\n  while (iss >> note) {\n    if (note == \"o\") beats.push_back(4);\n    else if (note == \"o|\") beats.push_back(2);\n    else if (note == \".|\") beats.push_back(1);\n  }\n  return beats;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n  std::vector<long> beats;\n  std::istringstream iss(music_string);\n  std::string note;\n  while (iss >> note) {\n    if (note == \"o\") {\n      beats.push_back(4);\n    } else if (note == \"o|\") {\n      beats.push_back(2);\n    } else if (note == \".|\") {\n      beats.push_back(1);\n    }\n  }\n  return beats;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n  std::vector<long> beats;\n  std::istringstream ss(music_string);\n  std::string note;\n  while (std::getline(ss, note, ' ')) {\n    if (note == \"o\") {\n      beats.push_back(4);\n    } else if (note == \"o|\") {\n      beats.push_back(2);\n    } else if (note == \".|\") {\n      beats.push_back(1);\n    }\n  }\n  return beats;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"db\";\n  while(decimal != 0) {\n    binary += std::to_string(decimal % 2);\n    decimal /= 2;\n  }\n  std::reverse(binary.begin()+2, binary.end());\n  binary += \"db\";\n  return binary;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"db\";\n  while(decimal != 0) {\n    binary += (decimal % 2) + '0';\n    decimal /= 2;\n  }\n  std::reverse(binary.begin() + 2, binary.end());\n  binary += \"db\";\n  return binary;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"db\";\n  while(decimal) {\n    binary += std::to_string(decimal % 2);\n    decimal /= 2;\n  }\n  std::reverse(binary.begin()+2, binary.end());\n  binary += \"db\";\n  return binary;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"db\";\n  while(decimal != 0) {\n    binary += std::to_string(decimal % 2);\n    decimal /= 2;\n  }\n  std::reverse(binary.begin() + 2, binary.end());\n  binary += \"db\";\n  return binary;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"db\";\n  while(decimal) {\n    binary += std::to_string(decimal % 2);\n    decimal /= 2;\n  }\n  std::reverse(binary.begin()+2, binary.end());\n  binary += \"db\";\n  return binary;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"db\";\n  while(decimal) {\n    binary += std::to_string(decimal % 2);\n    decimal /= 2;\n  }\n  std::reverse(binary.begin()+2, binary.end());\n  binary += \"db\";\n  return binary;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"db\";\n  while(decimal != 0) {\n    binary += std::to_string(decimal % 2);\n    decimal /= 2;\n  }\n  std::reverse(binary.begin() + 2, binary.end());\n  binary += \"db\";\n  return binary;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"db\";\n  while(decimal != 0) {\n    binary += std::to_string(decimal % 2);\n    decimal /= 2;\n  }\n  std::reverse(binary.begin() + 2, binary.end());\n  binary += \"db\";\n  return binary;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"db\";\n  while (decimal != 0) {\n    binary += std::to_string(decimal % 2);\n    decimal /= 2;\n  }\n  std::reverse(binary.begin() + 2, binary.end());\n  binary += \"db\";\n  return binary;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"db\";\n  while(decimal) {\n    binary += std::to_string(decimal % 2);\n    decimal /= 2;\n  }\n  std::reverse(binary.begin() + 2, binary.end());\n  binary += \"db\";\n  return binary;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n  std::vector<std::string> prefixes;\n  for (int i = 0; i < string.length(); i++) {\n    prefixes.push_back(string.substr(0, i+1));\n  }\n  return prefixes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n  std::vector<std::string> result;\n  for (int i = 0; i < string.length(); i++) {\n    result.push_back(string.substr(0, i + 1));\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n  std::vector<std::string> prefixes;\n  for (int i = 0; i < string.length(); i++) {\n    prefixes.push_back(string.substr(0, i+1));\n  }\n  return prefixes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n  std::vector<std::string> prefixes;\n  for (int i = 0; i < string.length(); i++) {\n    prefixes.push_back(string.substr(0, i + 1));\n  }\n  return prefixes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n  std::vector<std::string> prefixes;\n  for (int i = 0; i < string.length(); i++) {\n    prefixes.push_back(string.substr(0, i+1));\n  }\n  return prefixes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n  std::vector<std::string> prefixes;\n  for (int i = 0; i < string.length(); i++) {\n    prefixes.push_back(string.substr(0, i+1));\n  }\n  return prefixes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n  std::vector<std::string> prefixes;\n  for (int i = 0; i < string.length(); i++) {\n    prefixes.push_back(string.substr(0, i + 1));\n  }\n  return prefixes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n  std::vector<std::string> prefixes;\n  for (int i = 0; i < string.length(); i++) {\n    prefixes.push_back(string.substr(0, i+1));\n  }\n  return prefixes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n  std::vector<std::string> prefixes;\n  for (int i = 0; i < string.length(); i++) {\n    prefixes.push_back(string.substr(0, i+1));\n  }\n  return prefixes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n  std::vector<std::string> prefixes;\n  for (int i = 0; i < string.length(); i++) {\n    prefixes.push_back(string.substr(0, i + 1));\n  }\n  return prefixes;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n  return x + y;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n  return x + y;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n  return x + y;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n  return x + y;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n  return x + y;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n  return x + y;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n  return x + y;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n  return x + y;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n  return x + y;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n  return x + y;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n  long totalEaten = number;\n  if (remaining >= need) {\n    totalEaten += need;\n    remaining -= need;\n  } else {\n    totalEaten += remaining;\n    remaining = 0;\n  }\n  return std::vector<long>({totalEaten, remaining});\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n  std::vector<long> result;\n  long totalEaten = number;\n  if (remaining >= need) {\n    totalEaten += need;\n    remaining -= need;\n  } else {\n    totalEaten += remaining;\n    remaining = 0;\n  }\n  result.push_back(totalEaten);\n  result.push_back(remaining);\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n  long totalEaten = number;\n  if (remaining >= need) {\n    totalEaten += need;\n    remaining -= need;\n  } else {\n    totalEaten += remaining;\n    remaining = 0;\n  }\n  return std::vector<long>({totalEaten, remaining});\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n  long totalEaten = number;\n  if (need <= remaining) {\n    totalEaten += need;\n    remaining -= need;\n  } else {\n    totalEaten += remaining;\n    remaining = 0;\n  }\n  return std::vector<long>({totalEaten, remaining});\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n  long totalEaten = number;\n  if (need <= remaining) {\n    totalEaten += need;\n    remaining -= need;\n  } else {\n    totalEaten += remaining;\n    remaining = 0;\n  }\n  return std::vector<long>({totalEaten, remaining});\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n  long eaten = number;\n  if (need <= remaining) {\n    eaten += need;\n    remaining -= need;\n  } else {\n    eaten += remaining;\n    remaining = 0;\n  }\n  return std::vector<long>({eaten, remaining});\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n  long totalEaten;\n  long remainingCarrots;\n\n  if (remaining >= need) {\n    totalEaten = number + need;\n    remainingCarrots = remaining - need;\n  } else {\n    totalEaten = number + remaining;\n    remainingCarrots = 0;\n  }\n\n  return std::vector<long>({totalEaten, remainingCarrots});\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n  long totalEaten = number;\n  if (remaining >= need) {\n    totalEaten += need;\n    remaining -= need;\n  } else {\n    totalEaten += remaining;\n    remaining = 0;\n  }\n  return std::vector<long>({totalEaten, remaining});\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n  long totalEaten = number;\n  if (remaining >= need) {\n    totalEaten += need;\n    remaining -= need;\n  } else {\n    totalEaten += remaining;\n    remaining = 0;\n  }\n  return std::vector<long>({totalEaten, remaining});\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n  long totalEaten = number;\n  if (remaining >= need) {\n    totalEaten += need;\n    remaining -= need;\n  } else {\n    totalEaten += remaining;\n    remaining = 0;\n  }\n  return std::vector<long>({totalEaten, remaining});\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long total = 0;\n  for (auto &row : grid) {\n    for (auto &cell : row) {\n      if (cell == 1) {\n        total++;\n      }\n    }\n  }\n  return (total + capacity - 1) / capacity;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long totalWater = 0;\n  for (const auto& row : grid) {\n    for (const auto& cell : row) {\n      totalWater += cell;\n    }\n  }\n  return (totalWater + capacity - 1) / capacity;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long total = 0;\n  for (const auto& row : grid) {\n    for (const auto& cell : row) {\n      total += cell;\n    }\n  }\n  return (total + capacity - 1) / capacity;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long total_water = 0;\n  for (auto &row : grid) {\n    for (auto &cell : row) {\n      if (cell == 1) {\n        total_water++;\n      }\n    }\n  }\n  long num_of_times = total_water / capacity;\n  if (total_water % capacity != 0) {\n    num_of_times++;\n  }\n  return num_of_times;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long total = 0;\n  for (auto &row : grid) {\n    for (auto &cell : row) {\n      total += cell;\n    }\n  }\n  return (total + capacity - 1) / capacity;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long sum = 0;\n  for (auto &row : grid) {\n    for (auto &cell : row) {\n      sum += cell;\n    }\n  }\n  return (sum + capacity - 1) / capacity;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long total_water_units = 0;\n  for (auto& row : grid) {\n    for (auto& unit : row) {\n      if (unit == 1) {\n        total_water_units++;\n      }\n    }\n  }\n  long bucket_uses = total_water_units / capacity;\n  if (total_water_units % capacity != 0) {\n    bucket_uses++;\n  }\n  return bucket_uses;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long total_water = 0;\n  for (auto &row : grid) {\n    for (auto &cell : row) {\n      total_water += cell;\n    }\n  }\n  return (total_water + capacity - 1) / capacity;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long total = 0;\n  for (auto& row : grid) {\n    for (auto& cell : row) {\n      if (cell == 1) {\n        total++;\n      }\n    }\n  }\n  return (total + capacity - 1) / capacity;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long total = 0;\n  for (auto &row : grid) {\n    for (auto &cell : row) {\n      total += cell;\n    }\n  }\n  long times = total / capacity;\n  if (total % capacity != 0) {\n    times += 1;\n  }\n  return times;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n  long result = operand[0];\n  for (int i = 0; i < op.size(); i++) {\n    if (op[i] == \"+\") {\n      result += operand[i + 1];\n    } else if (op[i] == \"-\") {\n      result -= operand[i + 1];\n    } else if (op[i] == \"*\") {\n      result *= operand[i + 1];\n    } else if (op[i] == \"//\") {\n      result /= operand[i + 1];\n    } else if (op[i] == \"**\") {\n      result = pow(result, operand[i + 1]);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n  long result = operand[0];\n  for (int i = 0; i < op.size(); i++) {\n    if (op[i] == \"+\") {\n      result += operand[i + 1];\n    } else if (op[i] == \"-\") {\n      result -= operand[i + 1];\n    } else if (op[i] == \"*\") {\n      result *= operand[i + 1];\n    } else if (op[i] == \"//\") {\n      result /= operand[i + 1];\n    } else if (op[i] == \"**\") {\n      result = pow(result, operand[i + 1]);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n  long result = operand[0];\n  for (int i = 0; i < op.size(); ++i) {\n    if (op[i] == \"+\") {\n      result += operand[i + 1];\n    } else if (op[i] == \"-\") {\n      result -= operand[i + 1];\n    } else if (op[i] == \"*\") {\n      result *= operand[i + 1];\n    } else if (op[i] == \"//\") {\n      result /= operand[i + 1];\n    } else if (op[i] == \"**\") {\n      result = pow(result, operand[i + 1]);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n  long result = operand[0];\n  for (int i = 0; i < op.size(); i++) {\n    if (op[i] == \"+\") {\n      result += operand[i + 1];\n    } else if (op[i] == \"-\") {\n      result -= operand[i + 1];\n    } else if (op[i] == \"*\") {\n      result *= operand[i + 1];\n    } else if (op[i] == \"//\") {\n      result /= operand[i + 1];\n    } else if (op[i] == \"**\") {\n      result = pow(result, operand[i + 1]);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n  long result = operand[0];\n  for (int i = 0; i < op.size(); i++) {\n    if (op[i] == \"+\") {\n      result += operand[i + 1];\n    } else if (op[i] == \"-\") {\n      result -= operand[i + 1];\n    } else if (op[i] == \"*\") {\n      result *= operand[i + 1];\n    } else if (op[i] == \"//\") {\n      result /= operand[i + 1];\n    } else if (op[i] == \"**\") {\n      result = pow(result, operand[i + 1]);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n  long result = operand[0];\n  for (int i = 0; i < op.size(); i++) {\n    if (op[i] == \"+\") {\n      result += operand[i + 1];\n    } else if (op[i] == \"-\") {\n      result -= operand[i + 1];\n    } else if (op[i] == \"*\") {\n      result *= operand[i + 1];\n    } else if (op[i] == \"//\") {\n      result /= operand[i + 1];\n    } else if (op[i] == \"**\") {\n      result = pow(result, operand[i + 1]);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n  long result = operand[0];\n  for (int i = 0; i < op.size(); i++) {\n    if (op[i] == \"+\") {\n      result += operand[i+1];\n    } else if (op[i] == \"-\") {\n      result -= operand[i+1];\n    } else if (op[i] == \"*\") {\n      result *= operand[i+1];\n    } else if (op[i] == \"//\") {\n      result /= operand[i+1];\n    } else if (op[i] == \"**\") {\n      result = pow(result, operand[i+1]);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n  long result = operand[0];\n  for (int i = 0; i < op.size(); i++) {\n    if (op[i] == \"+\") {\n      result += operand[i + 1];\n    } else if (op[i] == \"-\") {\n      result -= operand[i + 1];\n    } else if (op[i] == \"*\") {\n      result *= operand[i + 1];\n    } else if (op[i] == \"//\") {\n      result /= operand[i + 1];\n    } else if (op[i] == \"**\") {\n      result = pow(result, operand[i + 1]);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n  long result = operand[0];\n  for (int i = 0; i < op.size(); i++) {\n    if (op[i] == \"+\") {\n      result += operand[i + 1];\n    } else if (op[i] == \"-\") {\n      result -= operand[i + 1];\n    } else if (op[i] == \"*\") {\n      result *= operand[i + 1];\n    } else if (op[i] == \"//\") {\n      result /= operand[i + 1];\n    } else if (op[i] == \"**\") {\n      result = pow(result, operand[i + 1]);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n  long result = operand[0];\n  for (int i = 0; i < op.size(); i++) {\n    if (op[i] == \"+\") {\n      result += operand[i + 1];\n    } else if (op[i] == \"-\") {\n      result -= operand[i + 1];\n    } else if (op[i] == \"*\") {\n      result *= operand[i + 1];\n    } else if (op[i] == \"//\") {\n      result /= operand[i + 1];\n    } else if (op[i] == \"**\") {\n      result = pow(result, operand[i + 1]);\n    }\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n  for (int i = 0; i < string.length(); i++) {\n    if (isupper(string[i])) {\n      string[i] = tolower(string[i]);\n    } else if (islower(string[i])) {\n      string[i] = toupper(string[i]);\n    }\n  }\n  return string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n  for (int i = 0; i < string.length(); i++) {\n    if (isupper(string[i]))\n      string[i] = tolower(string[i]);\n    else if (islower(string[i]))\n      string[i] = toupper(string[i]);\n  }\n  return string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n  for (int i = 0; i < string.length(); i++) {\n    if (isupper(string[i]))\n      string[i] = tolower(string[i]);\n    else if (islower(string[i]))\n      string[i] = toupper(string[i]);\n  }\n  return string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n  for (int i = 0; i < string.length(); i++) {\n    if (isupper(string[i])) {\n      string[i] = tolower(string[i]);\n    } else if (islower(string[i])) {\n      string[i] = toupper(string[i]);\n    }\n  }\n  return string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n  for (int i = 0; i < string.length(); i++) {\n    if (isupper(string[i])) {\n      string[i] = tolower(string[i]);\n    } else if (islower(string[i])) {\n      string[i] = toupper(string[i]);\n    }\n  }\n  return string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n  for (int i = 0; i < string.length(); i++) {\n    if (isupper(string[i])) {\n      string[i] = tolower(string[i]);\n    } else if (islower(string[i])) {\n      string[i] = toupper(string[i]);\n    }\n  }\n  return string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n  for (int i = 0; i < string.length(); i++) {\n    if (islower(string[i]))\n      string[i] = toupper(string[i]);\n    else if (isupper(string[i]))\n      string[i] = tolower(string[i]);\n  }\n  return string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n  for (int i = 0; i < string.length(); i++) {\n    if (islower(string[i])) {\n      string[i] = toupper(string[i]);\n    } else if (isupper(string[i])) {\n      string[i] = tolower(string[i]);\n    }\n  }\n  return string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n  for (int i = 0; i < string.length(); i++) {\n    if (isupper(string[i])) {\n      string[i] = tolower(string[i]);\n    } else if (islower(string[i])) {\n      string[i] = toupper(string[i]);\n    }\n  }\n  return string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n  for (int i = 0; i < string.length(); i++) {\n    if (isupper(string[i])) {\n      string[i] = tolower(string[i]);\n    } else if (islower(string[i])) {\n      string[i] = toupper(string[i]);\n    }\n  }\n  return string;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> temp;\n  std::vector<std::string> result;\n  std::map<long, std::string> numToString = {{1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n\n  for (auto num : arr) {\n    if (num >= 1 && num <= 9) {\n      temp.push_back(num);\n    }\n  }\n\n  std::sort(temp.begin(), temp.end());\n  std::reverse(temp.begin(), temp.end());\n\n  for (auto num : temp) {\n    result.push_back(numToString[num]);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> valid_nums;\n  std::vector<std::string> result;\n  std::map<long, std::string> num_map = {{1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n\n  for (auto num : arr) {\n    if (num >= 1 && num <= 9) {\n      valid_nums.push_back(num);\n    }\n  }\n\n  std::sort(valid_nums.begin(), valid_nums.end(), std::greater<long>());\n\n  for (auto num : valid_nums) {\n    result.push_back(num_map[num]);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> sorted;\n  for (long num : arr) {\n    if (num >= 1 && num <= 9) {\n      sorted.push_back(num);\n    }\n  }\n  std::sort(sorted.begin(), sorted.end());\n  std::reverse(sorted.begin(), sorted.end());\n  \n  std::vector<std::string> result;\n  for (long num : sorted) {\n    switch (num) {\n      case 1: result.push_back(\"One\"); break;\n      case 2: result.push_back(\"Two\"); break;\n      case 3: result.push_back(\"Three\"); break;\n      case 4: result.push_back(\"Four\"); break;\n      case 5: result.push_back(\"Five\"); break;\n      case 6: result.push_back(\"Six\"); break;\n      case 7: result.push_back(\"Seven\"); break;\n      case 8: result.push_back(\"Eight\"); break;\n      case 9: result.push_back(\"Nine\"); break;\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> valid_nums;\n  std::vector<std::string> names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n  // Filter valid numbers\n  for (auto num : arr) {\n    if (num >= 1 && num <= 9) {\n      valid_nums.push_back(num);\n    }\n  }\n\n  // Sort and reverse\n  std::sort(valid_nums.begin(), valid_nums.end());\n  std::reverse(valid_nums.begin(), valid_nums.end());\n\n  // Replace with names\n  std::vector<std::string> result;\n  for (auto num : valid_nums) {\n    result.push_back(names[num - 1]);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> valid_nums;\n  std::vector<std::string> result;\n  std::map<long, std::string> num_to_name = {{1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n\n  for (long num : arr) {\n    if (num >= 1 && num <= 9) {\n      valid_nums.push_back(num);\n    }\n  }\n\n  std::sort(valid_nums.begin(), valid_nums.end(), std::greater<long>());\n\n  for (long num : valid_nums) {\n    result.push_back(num_to_name[num]);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> filtered;\n  std::vector<std::string> result;\n  std::map<long, std::string> numToWord = {{1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n\n  for (long num : arr) {\n    if (num >= 1 && num <= 9) {\n      filtered.push_back(num);\n    }\n  }\n\n  std::sort(filtered.begin(), filtered.end(), std::greater<long>());\n\n  for (long num : filtered) {\n    result.push_back(numToWord[num]);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> valid_nums;\n  for (auto num : arr) {\n    if (num >= 1 && num <= 9) {\n      valid_nums.push_back(num);\n    }\n  }\n\n  std::sort(valid_nums.begin(), valid_nums.end());\n  std::reverse(valid_nums.begin(), valid_nums.end());\n\n  std::vector<std::string> result;\n  for (auto num : valid_nums) {\n    switch (num) {\n      case 1:\n        result.push_back(\"One\");\n        break;\n      case 2:\n        result.push_back(\"Two\");\n        break;\n      case 3:\n        result.push_back(\"Three\");\n        break;\n      case 4:\n        result.push_back(\"Four\");\n        break;\n      case 5:\n        result.push_back(\"Five\");\n        break;\n      case 6:\n        result.push_back(\"Six\");\n        break;\n      case 7:\n        result.push_back(\"Seven\");\n        break;\n      case 8:\n        result.push_back(\"Eight\");\n        break;\n      case 9:\n        result.push_back(\"Nine\");\n        break;\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> filtered;\n  std::vector<std::string> result;\n  std::map<long, std::string> numToName = {\n    {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n    {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n  };\n\n  // Filter the numbers between 1 and 9\n  for (auto num : arr) {\n    if (num >= 1 && num <= 9) {\n      filtered.push_back(num);\n    }\n  }\n\n  // Sort the filtered numbers\n  std::sort(filtered.begin(), filtered.end());\n\n  // Reverse the sorted numbers\n  std::reverse(filtered.begin(), filtered.end());\n\n  // Replace each number by its name\n  for (auto num : filtered) {\n    result.push_back(numToName[num]);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> validNums;\n  std::vector<std::string> result;\n  std::map<long, std::string> numMap = {{1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n\n  for(auto num : arr) {\n    if(num >= 1 && num <= 9) {\n      validNums.push_back(num);\n    }\n  }\n\n  std::sort(validNums.begin(), validNums.end(), std::greater<long>());\n\n  for(auto num : validNums) {\n    result.push_back(numMap[num]);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> valid_nums;\n  std::vector<std::string> result;\n  std::map<long, std::string> num_to_word = {{1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n\n  for(auto num : arr) {\n    if(num >= 1 && num <= 9) {\n      valid_nums.push_back(num);\n    }\n  }\n\n  std::sort(valid_nums.begin(), valid_nums.end());\n  std::reverse(valid_nums.begin(), valid_nums.end());\n\n  for(auto num : valid_nums) {\n    result.push_back(num_to_word[num]);\n  }\n\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n  std::vector<long> factors;\n  for (long i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n  std::vector<long> factors;\n  for (long i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n  std::vector<long> factors;\n  for (long i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\nstd::vector<long> factors;\nfor (long i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n        factors.push_back(i);\n        n /= i;\n    }\n}\nif (n > 1) {\n    factors.push_back(n);\n}\nreturn factors;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n  std::vector<long> factors;\n  for (long i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n  std::vector<long> factors;\n  for (int i = 2; i <= sqrt(n); i++) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n  std::vector<long> factors;\n  for (int i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n  std::vector<long> factors;\n  for (int i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n  std::vector<long> factors;\n  for (long i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n  std::vector<long> factors;\n  for (long i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  for (long i = 2; i < n; i++) {\n    bool isPrime = true;\n    for (long j = 2; j * j <= i; j++) {\n      if (i % j == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push_back(i);\n    }\n  }\n  return primes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  if (n < 2) {\n    return primes;\n  }\n  primes.push_back(2);\n  for (long i = 3; i < n; i += 2) {\n    bool is_prime = true;\n    for (long j = 2; j * j <= i; ++j) {\n      if (i % j == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n    if (is_prime) {\n      primes.push_back(i);\n    }\n  }\n  return primes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  if (n < 2) {\n    return primes;\n  }\n  primes.push_back(2);\n  for (long i = 3; i < n; i += 2) {\n    bool isPrime = true;\n    for (long j = 2; j * j <= i; j++) {\n      if (i % j == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push_back(i);\n    }\n  }\n  return primes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  if (n < 2) return primes;\n\n  for (long i = 2; i < n; i++) {\n    bool is_prime = true;\n    for (long j = 2; j * j <= i; j++) {\n      if (i % j == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n    if (is_prime) primes.push_back(i);\n  }\n  return primes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  for (long i = 2; i < n; i++) {\n    bool is_prime = true;\n    for (long j = 2; j * j <= i; j++) {\n      if (i % j == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n    if (is_prime) {\n      primes.push_back(i);\n    }\n  }\n  return primes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  if(n < 2) return primes;\n  primes.push_back(2);\n  for(long i = 3; i < n; i += 2) {\n    bool isPrime = true;\n    for(auto prime : primes) {\n      if(i % prime == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if(isPrime) primes.push_back(i);\n  }\n  return primes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  for (long i = 2; i < n; i++) {\n    bool isPrime = true;\n    for (long j = 2; j * j <= i; j++) {\n      if (i % j == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push_back(i);\n    }\n  }\n  return primes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  for (long i = 2; i < n; i++) {\n    bool isPrime = true;\n    for (long j = 2; j * j <= i; j++) {\n      if (i % j == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push_back(i);\n    }\n  }\n  return primes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n\n  for (long i = 2; i < n; i++) {\n    bool isPrime = true;\n    for (long j = 2; j * j <= i; j++) {\n      if (i % j == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push_back(i);\n    }\n  }\n\n  return primes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  for (long i = 2; i < n; i++) {\n    bool isPrime = true;\n    for (long j = 2; j * j <= i; j++) {\n      if (i % j == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push_back(i);\n    }\n  }\n  return primes;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n  std::sort(l.begin(), l.end());\n  l.erase(std::unique(l.begin(), l.end()), l.end());\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n  std::sort(l.begin(), l.end());\n  l.erase(std::unique(l.begin(), l.end()), l.end());\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n  std::sort(l.begin(), l.end());\n  l.erase(std::unique(l.begin(), l.end()), l.end());\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n  std::sort(l.begin(), l.end());\n  l.erase(std::unique(l.begin(), l.end()), l.end());\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n  std::sort(l.begin(), l.end());\n  l.erase(std::unique(l.begin(), l.end()), l.end());\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n  std::sort(l.begin(), l.end());\n  l.erase(std::unique(l.begin(), l.end()), l.end());\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n  std::sort(l.begin(), l.end());\n  l.erase(std::unique(l.begin(), l.end()), l.end());\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n  std::sort(l.begin(), l.end());\n  l.erase(std::unique(l.begin(), l.end()), l.end());\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n  std::sort(l.begin(), l.end());\n  l.erase(std::unique(l.begin(), l.end()), l.end());\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n  std::sort(l.begin(), l.end());\n  l.erase(std::unique(l.begin(), l.end()), l.end());\n  return l;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  int len1 = 0, len2 = 0;\n  for (const auto& str : lst1) {\n    len1 += str.length();\n  }\n  for (const auto& str : lst2) {\n    len2 += str.length();\n  }\n  return len1 <= len2 ? lst1 : lst2;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  int total1 = 0, total2 = 0;\n  for (const auto& str : lst1) {\n    total1 += str.length();\n  }\n  for (const auto& str : lst2) {\n    total2 += str.length();\n  }\n  return total1 <= total2 ? lst1 : lst2;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  int sum1 = 0, sum2 = 0;\n  for (const auto& str : lst1) {\n    sum1 += str.length();\n  }\n  for (const auto& str : lst2) {\n    sum2 += str.length();\n  }\n  if (sum1 <= sum2) {\n    return lst1;\n  } else {\n    return lst2;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  int total1 = 0, total2 = 0;\n\n  for (auto &str : lst1) {\n    total1 += str.length();\n  }\n\n  for (auto &str : lst2) {\n    total2 += str.length();\n  }\n\n  if (total1 <= total2) {\n    return lst1;\n  } else {\n    return lst2;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  int totalChars1 = 0, totalChars2 = 0;\n  \n  for (const auto& str : lst1) {\n    totalChars1 += str.length();\n  }\n  \n  for (const auto& str : lst2) {\n    totalChars2 += str.length();\n  }\n  \n  if (totalChars1 <= totalChars2) {\n    return lst1;\n  } else {\n    return lst2;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  int total_chars_lst1 = 0, total_chars_lst2 = 0;\n  \n  for (const auto& str : lst1) {\n    total_chars_lst1 += str.length();\n  }\n  \n  for (const auto& str : lst2) {\n    total_chars_lst2 += str.length();\n  }\n  \n  if (total_chars_lst1 <= total_chars_lst2) {\n    return lst1;\n  } else {\n    return lst2;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  int total_chars_lst1 = 0, total_chars_lst2 = 0;\n  \n  for (const auto& str : lst1) {\n    total_chars_lst1 += str.length();\n  }\n\n  for (const auto& str : lst2) {\n    total_chars_lst2 += str.length();\n  }\n\n  if (total_chars_lst1 <= total_chars_lst2) {\n    return lst1;\n  } else {\n    return lst2;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  int total1 = 0, total2 = 0;\n  for (const auto& str : lst1) {\n    total1 += str.length();\n  }\n  for (const auto& str : lst2) {\n    total2 += str.length();\n  }\n  return total1 <= total2 ? lst1 : lst2;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  int total1 = 0, total2 = 0;\n  for(const auto& str: lst1) {\n    total1 += str.length();\n  }\n  for(const auto& str: lst2) {\n    total2 += str.length();\n  }\n  return total1 <= total2 ? lst1 : lst2;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  int total_chars_lst1 = 0, total_chars_lst2 = 0;\n\n  for (const auto& str : lst1) {\n    total_chars_lst1 += str.length();\n  }\n\n  for (const auto& str : lst2) {\n    total_chars_lst2 += str.length();\n  }\n\n  return total_chars_lst1 <= total_chars_lst2 ? lst1 : lst2;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n  long max = l[0];\n  for(int i = 1; i < l.size(); i++) {\n    if(l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n  long max = l[0];\n  for (int i = 1; i < l.size(); i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n  long max = l[0];\n  for (int i = 1; i < l.size(); i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n  long max = l[0];\n  for (int i = 1; i < l.size(); i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n  long max = l[0];\n  for (int i = 1; i < l.size(); i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n  long max = l[0];\n  for (int i = 1; i < l.size(); i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n  long max = l[0];\n  for (int i = 1; i < l.size(); i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n  long max = l[0];\n  for (int i = 1; i < l.size(); i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n  long max = l[0];\n  for(int i = 1; i < l.size(); i++) {\n    if(l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n  long max = l[0];\n  for (int i = 1; i < l.size(); i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n  int count = 0;\n  bool nested = false;\n  \n  for (char c : string) {\n    if (c == '[') {\n      count++;\n      if (count > 1) {\n        nested = true;\n      }\n    } else if (c == ']') {\n      if (count > 0) {\n        count--;\n      } else {\n        return false;\n      }\n    }\n  }\n  \n  return nested && count == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n  std::stack<char> stack;\n  bool nested = false;\n\n  for (char &c : string) {\n    if (c == '[') {\n      if (!stack.empty()) nested = true;\n      stack.push(c);\n    } else if (c == ']') {\n      if (stack.empty()) return false;\n      stack.pop();\n    }\n  }\n\n  return nested && stack.empty();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n  std::stack<char> brackets;\n  bool nested = false;\n  for (char c : string) {\n    if (c == '[') {\n      brackets.push(c);\n    } else if (!brackets.empty()) {\n      if (brackets.top() == '[') {\n        brackets.pop();\n        if (!brackets.empty()) {\n          nested = true;\n        }\n      }\n    } else {\n      return false;\n    }\n  }\n  return nested && brackets.empty();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n  int count = 0;\n  int max_count = 0;\n  for (char c : string) {\n    if (c == '[') {\n      count++;\n      if (count > max_count) {\n        max_count = count;\n      }\n    } else if (c == ']') {\n      if (count == 0) {\n        return false;\n      }\n      count--;\n    }\n  }\n  return max_count > 1 && count == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n  int count = 0;\n  for (int i = 0; i < string.length(); i++) {\n    if (string[i] == '[') {\n      count++;\n    } else if (string[i] == ']') {\n      count--;\n      if (count < 0) {\n        return false;\n      }\n    }\n  }\n  return count > 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n  std::stack<char> stack;\n  bool nested = false;\n  for (char &c : string) {\n    if (c == '[') {\n      if (!stack.empty()) nested = true;\n      stack.push(c);\n    } else if (c == ']') {\n      if (stack.empty()) return false;\n      stack.pop();\n    }\n  }\n  return nested && stack.empty();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n  int count = 0;\n  for (int i = 0; i < string.length(); i++) {\n    if (string[i] == '[') {\n      count++;\n    } else if (string[i] == ']') {\n      count--;\n      if (count < 0) {\n        return false;\n      }\n    }\n  }\n  return count > 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    int depth = 0;\n    bool nested = false;\n    for (char c : string) {\n        if (c == '[') {\n            depth++;\n        } else if (c == ']') {\n            if (depth > 0) {\n                depth--;\n                if (depth > 0) {\n                    nested = true;\n                }\n            } else {\n                return false;\n            }\n        }\n    }\n    return nested && depth == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n  std::stack<char> stack;\n  bool nested = false;\n  \n  for(char& c : string) {\n    if(c == '[') {\n      if(!stack.empty()) {\n        nested = true;\n      }\n      stack.push(c);\n    } else if(c == ']') {\n      if(stack.empty()) {\n        return false;\n      }\n      stack.pop();\n    }\n  }\n  \n  return nested && stack.empty();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n  std::stack<char> brackets;\n  bool nested = false;\n\n  for (char c : string) {\n    if (c == '[') {\n      if (!brackets.empty()) {\n        nested = true;\n      }\n      brackets.push(c);\n    } else if (c == ']') {\n      if (brackets.empty()) {\n        return false;\n      }\n      brackets.pop();\n    }\n  }\n\n  return nested && brackets.empty();\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return Union_std_string_long(-1);\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = round((double)sum / (m - n + 1));\n    std::bitset<32> binary(avg);\n    std::string binaryString = \"0b\" + binary.to_string();\n    return Union_std_string_long(binaryString);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return Union_std_string_long(-1);\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = round((double)sum / (m - n + 1));\n    std::bitset<32> binary(avg);\n    return Union_std_string_long(\"0b\" + binary.to_string().substr(binary.to_string().find('1')));\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return Union_std_string_long(-1);\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = round((double)sum / (m - n + 1));\n    std::bitset<32> binary(avg);\n    std::string binary_string = \"0b\" + binary.to_string();\n    return Union_std_string_long(binary_string);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n  if (n > m) {\n    return Union_std_string_long(-1);\n  }\n  \n  long sum = 0;\n  for (long i = n; i <= m; i++) {\n    sum += i;\n  }\n  \n  long avg = round((double)sum / (m - n + 1));\n  \n  std::bitset<64> binary(avg);\n  std::string binary_string = \"0b\" + binary.to_string();\n  binary_string.erase(0, binary_string.find_first_not_of('0'));\n\n  return Union_std_string_long(binary_string);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return Union_std_string_long(-1);\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = round((double)sum / (m - n + 1));\n    std::string binary = \"0b\" + std::bitset<64>(avg).to_string();\n    binary.erase(0, binary.find_first_not_of('0'));\n    return Union_std_string_long(binary);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return Union_std_string_long(-1);\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = round((double)sum / (m - n + 1));\n    std::string binary = \"0b\" + std::bitset<32>(avg).to_string();\n    return Union_std_string_long(binary);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n  if (n > m) {\n    return Union_std_string_long(-1);\n  }\n  long sum = 0;\n  for (long i = n; i <= m; i++) {\n    sum += i;\n  }\n  long avg = round((double)sum / (m - n + 1));\n  std::bitset<64> binary(avg);\n  std::string binary_string = \"0b\" + binary.to_string();\n  return Union_std_string_long(binary_string);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return Union_std_string_long(-1);\n    }\n\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n\n    long avg = round(static_cast<double>(sum) / (m - n + 1));\n    std::bitset<32> binary(avg);\n\n    return Union_std_string_long(\"0b\" + binary.to_string());\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return Union_std_string_long(-1);\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = round((double)sum / (m - n + 1));\n    std::bitset<32> binary(avg);\n    std::string binary_string = \"0b\" + binary.to_string();\n    return Union_std_string_long(binary_string);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return Union_std_string_long(-1);\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = round((double)sum / (m - n + 1));\n    std::bitset<32> binary(avg);\n    std::string binary_str = \"0b\" + binary.to_string();\n    return Union_std_string_long(binary_str);\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (auto &str : lst) {\n    int oddCount = 0;\n    for (char c : str) {\n      if ((c - '0') % 2 != 0) {\n        oddCount++;\n      }\n    }\n    std::string res = \"the number of odd elements \" + std::to_string(oddCount) + \"n the str\" + std::to_string(oddCount) + \"ng \" + std::to_string(oddCount) + \" of the \" + std::to_string(oddCount) + \"nput.\";\n    result.push_back(res);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (auto &str : lst) {\n    int count = 0;\n    for (char c : str) {\n      if ((c - '0') % 2 != 0) {\n        count++;\n      }\n    }\n    std::string res = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n    result.push_back(res);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (const auto& str : lst) {\n    int count = 0;\n    for (const auto& ch : str) {\n      if ((ch - '0') % 2 != 0) {\n        count++;\n      }\n    }\n    std::string res = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n    result.push_back(res);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for(auto& str : lst) {\n    int count = 0;\n    for(auto& ch : str) {\n      if((ch - '0') % 2 != 0) {\n        count++;\n      }\n    }\n    std::string res = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n    result.push_back(res);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (auto &str : lst) {\n    int count = 0;\n    for (char c : str) {\n      if ((c - '0') % 2 != 0) {\n        count++;\n      }\n    }\n    std::string res = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n    result.push_back(res);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (auto &str : lst) {\n    int odd_count = 0;\n    for (auto &ch : str) {\n      if ((ch - '0') % 2 != 0) {\n        odd_count++;\n      }\n    }\n    std::string res = \"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\";\n    result.push_back(res);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for(const auto &str : lst) {\n    int count = 0;\n    for(const auto &ch : str) {\n      if((ch - '0') % 2 != 0) {\n        count++;\n      }\n    }\n    std::string res = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n    result.push_back(res);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (auto &str : lst) {\n    int count = 0;\n    for (char c : str) {\n      if ((c - '0') % 2 != 0) {\n        count++;\n      }\n    }\n    std::string res = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n    result.push_back(res);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (auto &str : lst) {\n    int odd_count = 0;\n    for (char &c : str) {\n      if ((c - '0') % 2 != 0) {\n        odd_count++;\n      }\n    }\n    std::string res = \"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\";\n    result.push_back(res);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (const auto &str : lst) {\n    int count = std::count_if(str.begin(), str.end(), [](char c) { return (c - '0') % 2 != 0; });\n    std::string res = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n    result.push_back(res);\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  if(arr.empty()) return true;\n  \n  int count = 0;\n  for(int i = 0; i < arr.size() - 1; i++) {\n    if(arr[i] > arr[i+1]) {\n      count++;\n    }\n  }\n  \n  if(arr.back() > arr.front()) {\n    count++;\n  }\n  \n  return count <= 1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  if(arr.empty()) return true;\n  int count = 0;\n  for(int i=0; i<arr.size()-1; i++) {\n    if(arr[i] > arr[i+1]) count++;\n    if(count > 1) return false;\n  }\n  if(arr[arr.size()-1] > arr[0] && count == 1) return false;\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  if(arr.empty()) return true;\n  int n = arr.size();\n  for(int i = 0; i < n; i++){\n    std::rotate(arr.begin(), arr.begin() + 1, arr.end());\n    if(std::is_sorted(arr.begin(), arr.end())) return true;\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  int n = arr.size();\n  if (n == 0) return true;\n  \n  int cnt = 0;\n  for (int i = 0; i < n; i++) {\n    if (arr[i] > arr[(i + 1) % n]) cnt++;\n  }\n  \n  return cnt <= 1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  int n = arr.size();\n  if (n == 0) return true;\n  \n  int count = 0;\n  for (int i = 0; i < n; i++) {\n    if (arr[i] > arr[(i + 1) % n]) {\n      count++;\n    }\n  }\n  \n  return (count <= 1);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  if (arr.empty()) {\n    return true;\n  }\n\n  std::vector<long> sortedArr = arr;\n  std::sort(sortedArr.begin(), sortedArr.end());\n\n  for (int i = 0; i < arr.size(); i++) {\n    std::rotate(arr.begin(), arr.begin() + 1, arr.end());\n    if (arr == sortedArr) {\n      return true;\n    }\n  }\n\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  int size = arr.size();\n  if (size == 0) return true;\n\n  int count = 0;\n  for (int i = 0; i < size - 1; i++) {\n    if (arr[i] > arr[i + 1]) {\n      count++;\n      if (count > 1) return false;\n    }\n  }\n\n  if (arr[size - 1] > arr[0]) count++;\n  return count <= 1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  if (arr.empty()) return true;\n  std::vector<long> sortedArr = arr;\n  std::sort(sortedArr.begin(), sortedArr.end());\n  for (int i = 0; i < arr.size(); i++) {\n    std::rotate(arr.begin(), arr.begin() + 1, arr.end());\n    if (arr == sortedArr) return true;\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  int n = arr.size();\n  if (n == 0) return true;\n  \n  for(int i = 0; i < n; i++) {\n    std::rotate(arr.begin(), arr.begin() + 1, arr.end());\n    if(std::is_sorted(arr.begin(), arr.end())) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n  int n = arr.size();\n  if (n == 0) return true;\n\n  for (int i = 0; i < n; i++) {\n    std::rotate(arr.begin(), arr.begin() + 1, arr.end());\n    if (std::is_sorted(arr.begin(), arr.end())) {\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even_count = 0;\n    long odd_count = 0;\n    for (long i = 1; i <= n; i++) {\n        std::string str = std::to_string(i);\n        std::string rev_str = str;\n        std::reverse(rev_str.begin(), rev_str.end());\n        if (str == rev_str) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even_count = 0;\n  long odd_count = 0;\n\n  for (long i = 1; i <= n; i++) {\n    std::string num_str = std::to_string(i);\n    std::string reversed_num_str = num_str;\n    std::reverse(reversed_num_str.begin(), reversed_num_str.end());\n\n    if (num_str == reversed_num_str) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n\n  return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even_count = 0;\n  long odd_count = 0;\n\n  for (long i = 1; i <= n; i++) {\n    std::string str = std::to_string(i);\n    std::string rev_str = str;\n    std::reverse(rev_str.begin(), rev_str.end());\n\n    if (str == rev_str) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n\n  return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even = 0, odd = 0;\n  for (long i = 1; i <= n; i++) {\n    std::string str = std::to_string(i);\n    std::string rev_str = str;\n    std::reverse(rev_str.begin(), rev_str.end());\n    if (str == rev_str) {\n      if (i % 2 == 0) {\n        even++;\n      } else {\n        odd++;\n      }\n    }\n  }\n  return std::make_tuple(even, odd);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even_count = 0;\n  long odd_count = 0;\n\n  for (long i = 1; i <= n; i++) {\n    std::string str = std::to_string(i);\n    std::string rev_str = str;\n    std::reverse(rev_str.begin(), rev_str.end());\n\n    if (str == rev_str) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n\n  return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even_count = 0;\n    long odd_count = 0;\n\n    for (long i = 1; i <= n; i++) {\n        std::string num = std::to_string(i);\n        std::string reversed_num = num;\n        std::reverse(reversed_num.begin(), reversed_num.end());\n\n        if (num == reversed_num) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even_count = 0, odd_count = 0;\n\n  for (long i = 1; i <= n; i++) {\n    std::string s = std::to_string(i);\n    std::string rs = s;\n    std::reverse(rs.begin(), rs.end());\n\n    if (s == rs) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n\n  return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even_count = 0;\n    long odd_count = 0;\n    for (long i = 1; i <= n; i++) {\n        std::string str = std::to_string(i);\n        std::string rev_str = str;\n        std::reverse(rev_str.begin(), rev_str.end());\n        if (str == rev_str) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even_count = 0;\n  long odd_count = 0;\n\n  for (long i = 1; i <= n; i++) {\n    std::string s = std::to_string(i);\n    std::string r = s;\n    std::reverse(r.begin(), r.end());\n\n    if (s == r) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n\n  return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even = 0, odd = 0;\n    for (long i = 1; i <= n; i++) {\n        std::string str = std::to_string(i);\n        std::string rev_str = str;\n        std::reverse(rev_str.begin(), rev_str.end());\n        if (str == rev_str) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    return std::make_tuple(even, odd);\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n  if (n >= 8 && n % 2 == 0) {\n    return true;\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n  if (n >= 8 && n % 2 == 0) {\n    return true;\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n  if (n < 8) {\n    return false;\n  }\n  return n % 2 == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n  if(n >= 8 && n % 2 == 0) {\n    return true;\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n  if (n < 8) {\n    return false;\n  }\n  if (n % 2 == 0) {\n    return true;\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n  if (n >= 8 && n % 2 == 0) {\n    return true;\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n  if(n >= 8 && n % 2 == 0) {\n    return true;\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n  if(n >= 8 && n % 2 == 0)\n    return true;\n  else\n    return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n  if(n >= 8 && n % 2 == 0) {\n    return true;\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n  if (n >= 8 && n % 2 == 0) {\n    return true;\n  }\n  return false;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n  std::vector<long> result;\n  for (int i = 1; i < xs.size(); i++) {\n    result.push_back(xs[i] * i);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n  std::vector<long> result;\n  for (int i = 1; i < xs.size(); i++) {\n    result.push_back(xs[i] * i);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n  std::vector<long> result;\n  for (int i = 1; i < xs.size(); i++) {\n    result.push_back(xs[i] * i);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n  std::vector<long> derivative;\n  for (int i = 1; i < xs.size(); i++) {\n    derivative.push_back(xs[i] * i);\n  }\n  return derivative;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n  std::vector<long> result;\n  for (int i = 1; i < xs.size(); i++) {\n    result.push_back(xs[i] * i);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n  std::vector<long> result;\n  for (int i = 1; i < xs.size(); i++) {\n    result.push_back(xs[i] * i);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n  std::vector<long> result;\n  for (int i = 1; i < xs.size(); i++) {\n    result.push_back(xs[i] * i);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n  std::vector<long> result;\n  for (int i = 1; i < xs.size(); i++) {\n    result.push_back(xs[i] * i);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n  std::vector<long> result;\n  for (int i = 1; i < xs.size(); i++) {\n    result.push_back(xs[i] * i);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n  std::vector<long> result;\n  for (int i = 1; i < xs.size(); i++) {\n    result.push_back(xs[i] * i);\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::unordered_map<long, int> count;\n  for (int i = 0; i < lst.size(); i++) {\n    count[lst[i]]++;\n    if (count[lst[i]] > 1) {\n      return false;\n    }\n    if (i > 0 && lst[i] < lst[i-1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::unordered_map<long, int> count;\n  for (int i = 0; i < lst.size(); i++) {\n    count[lst[i]]++;\n    if (count[lst[i]] > 1) {\n      return false;\n    }\n    if (i > 0 && lst[i] < lst[i - 1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::unordered_map<long, int> count;\n  for (int i = 0; i < lst.size(); ++i) {\n    count[lst[i]]++;\n    if (count[lst[i]] > 1) {\n      return false;\n    }\n    if (i > 0 && lst[i] < lst[i - 1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::unordered_map<long, int> count;\n  for (int i = 0; i < lst.size(); i++) {\n    count[lst[i]]++;\n    if (count[lst[i]] > 2)\n      return false;\n    if (i != 0 && lst[i] < lst[i - 1])\n      return false;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::unordered_map<long, int> num_count;\n  for (int i = 0; i < lst.size(); i++) {\n    num_count[lst[i]]++;\n    if (num_count[lst[i]] > 1) {\n      return false;\n    }\n    if (i > 0 && lst[i] < lst[i - 1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::unordered_map<long, int> count_map;\n  for (int i = 0; i < lst.size(); i++) {\n    count_map[lst[i]]++;\n    if (count_map[lst[i]] > 1) {\n      return false;\n    }\n    if (i > 0 && lst[i] < lst[i-1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::unordered_map<long, int> count_map;\n  for (int i = 0; i < lst.size(); i++) {\n    count_map[lst[i]]++;\n    if (count_map[lst[i]] > 1) {\n      return false;\n    }\n    if (i > 0 && lst[i] < lst[i-1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::unordered_map<long, int> count;\n  for (int i = 0; i < lst.size(); i++) {\n    count[lst[i]]++;\n    if (count[lst[i]] > 1) {\n      return false;\n    }\n    if (i > 0 && lst[i] < lst[i - 1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::unordered_map<long, int> count;\n  for (int i = 0; i < lst.size(); i++) {\n    count[lst[i]]++;\n    if (count[lst[i]] > 1) {\n      return false;\n    }\n    if (i > 0 && lst[i] < lst[i-1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  if (lst.size() < 2) return true;\n  std::unordered_map<long, int> counter;\n  for (int i = 0; i < lst.size() - 1; i++) {\n    if (lst[i] > lst[i + 1]) return false;\n    counter[lst[i]]++;\n    if (counter[lst[i]] > 1) return false;\n  }\n  counter[lst.back()]++;\n  if (counter[lst.back()] > 1) return false;\n  return true;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n  bool hasLetter = false;\n  for (char c : s) {\n    if (isalpha(c)) {\n      hasLetter = true;\n      break;\n    }\n  }\n\n  if (hasLetter) {\n    for (char& c : s) {\n      if (isupper(c)) c = tolower(c);\n      else if (islower(c)) c = toupper(c);\n    }\n  } else {\n    std::reverse(s.begin(), s.end());\n  }\n\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n  bool hasLetter = false;\n  for (char &c : s) {\n    if (isalpha(c)) {\n      hasLetter = true;\n      c = islower(c) ? toupper(c) : tolower(c);\n    }\n  }\n  if (!hasLetter) {\n    reverse(s.begin(), s.end());\n  }\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n  bool hasLetter = false;\n  for (char c : s) {\n    if (isalpha(c)) {\n      hasLetter = true;\n      break;\n    }\n  }\n\n  if (!hasLetter) {\n    std::reverse(s.begin(), s.end());\n    return s;\n  }\n\n  for (int i = 0; i < s.length(); i++) {\n    if (isalpha(s[i])) {\n      s[i] = islower(s[i]) ? toupper(s[i]) : tolower(s[i]);\n    }\n  }\n\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n  bool hasLetter = false;\n  for(char& c : s) {\n    if(isalpha(c)) {\n      hasLetter = true;\n      c = islower(c) ? toupper(c) : tolower(c);\n    }\n  }\n  if(!hasLetter) {\n    std::reverse(s.begin(), s.end());\n  }\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n  bool hasLetter = false;\n  for (char c : s) {\n    if (isalpha(c)) {\n      hasLetter = true;\n      break;\n    }\n  }\n\n  if (hasLetter) {\n    for (int i = 0; i < s.size(); i++) {\n      if (islower(s[i])) {\n        s[i] = toupper(s[i]);\n      } else if (isupper(s[i])) {\n        s[i] = tolower(s[i]);\n      }\n    }\n  } else {\n    std::reverse(s.begin(), s.end());\n  }\n\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n  bool hasLetter = false;\n  for (char c : s) {\n    if (isalpha(c)) {\n      hasLetter = true;\n      break;\n    }\n  }\n\n  if (!hasLetter) {\n    reverse(s.begin(), s.end());\n  } else {\n    for (char &c : s) {\n      if (isalpha(c)) {\n        c = islower(c) ? toupper(c) : tolower(c);\n      }\n    }\n  }\n\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n  bool hasLetter = false;\n  for (char c : s) {\n    if (isalpha(c)) {\n      hasLetter = true;\n      break;\n    }\n  }\n\n  if (!hasLetter) {\n    std::reverse(s.begin(), s.end());\n    return s;\n  }\n\n  for (int i = 0; i < s.length(); i++) {\n    if (isalpha(s[i])) {\n      s[i] = islower(s[i]) ? toupper(s[i]) : tolower(s[i]);\n    }\n  }\n\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n  bool hasLetter = false;\n  for (char c : s) {\n    if (isalpha(c)) {\n      hasLetter = true;\n      break;\n    }\n  }\n\n  if (!hasLetter) {\n    reverse(s.begin(), s.end());\n    return s;\n  }\n\n  for (int i = 0; i < s.length(); i++) {\n    if (isalpha(s[i])) {\n      s[i] = islower(s[i]) ? toupper(s[i]) : tolower(s[i]);\n    }\n  }\n\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n  bool hasLetter = false;\n  for (char c : s) {\n    if (isalpha(c)) {\n      hasLetter = true;\n      break;\n    }\n  }\n  \n  if (!hasLetter) {\n    std::reverse(s.begin(), s.end());\n  } else {\n    for (char& c : s) {\n      if (islower(c)) {\n        c = toupper(c);\n      } else if (isupper(c)) {\n        c = tolower(c);\n      }\n    }\n  }\n  \n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n  bool hasLetter = false;\n  for (char c : s) {\n    if (isalpha(c)) {\n      hasLetter = true;\n      break;\n    }\n  }\n\n  if (!hasLetter) {\n    std::reverse(s.begin(), s.end());\n  } else {\n    for (char &c : s) {\n      if (isalpha(c)) {\n        c = islower(c) ? toupper(c) : tolower(c);\n      }\n    }\n  }\n  \n  return s;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n  std::vector<long> tribonacci(n + 1, 0);\n  \n  tribonacci[1] = 3;\n  \n  if (n >= 2) {\n    tribonacci[2] = 2;\n  }\n  \n  for (long i = 3; i <= n; i++) {\n    if (i % 2 == 0) {\n      tribonacci[i] = 1 + i / 2;\n    } else {\n      tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3];\n    }\n  }\n  \n  return tribonacci;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n  std::vector<long> tribonacci(n+1, 0);\n  tribonacci[0] = 1;\n  tribonacci[1] = 3;\n  \n  for(long i = 2; i <= n; i++){\n    if(i % 2 == 0){\n      tribonacci[i] = 1 + i / 2;\n    } else {\n      tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + (i+1 <= n ? tribonacci[i + 1] : 1 + (i + 1) / 2);\n    }\n  }\n  \n  return tribonacci;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n  std::vector<long> tribonacci(n + 1);\n  \n  tribonacci[0] = 1;\n  tribonacci[1] = 3;\n  \n  for (long i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      tribonacci[i] = 1 + i / 2;\n    } else {\n      tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + ((i + 1 <= n) ? tribonacci[i + 1] : 1);\n    }\n  }\n  \n  return tribonacci;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n  std::vector<long> tribonacci(n+1);\n  tribonacci[0] = 0;\n  if (n > 0) tribonacci[1] = 3;\n  if (n > 1) tribonacci[2] = 2;\n\n  for (long i = 3; i <= n; i++) {\n    if (i % 2 == 0) {\n      tribonacci[i] = 1 + i / 2;\n    } else {\n      tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3];\n    }\n  }\n\n  return tribonacci;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n  std::vector<long> tribonacci(n + 1);\n  tribonacci[0] = 0;\n  tribonacci[1] = 3;\n  if (n >= 2) tribonacci[2] = 2;\n\n  for (long i = 3; i <= n; i++) {\n    if (i % 2 == 0) {\n      tribonacci[i] = 1 + i / 2;\n    } else {\n      tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3];\n    }\n  }\n  \n  return tribonacci;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n  std::vector<long> tribonacci(n + 1, 0);\n  \n  if (n >= 0) tribonacci[0] = 1;\n  if (n >= 1) tribonacci[1] = 3;\n  if (n >= 2) tribonacci[2] = 2;\n\n  for (long i = 3; i <= n; i++) {\n    if (i % 2 == 0) {\n      tribonacci[i] = 1 + i / 2;\n    } else {\n      tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3];\n    }\n  }\n  \n  return tribonacci;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n  std::vector<long> tribonacci(n+1);\n  tribonacci[0] = 0;\n  tribonacci[1] = 3;\n  if(n>=2) tribonacci[2] = 2;\n  \n  for (long i = 3; i <= n; i++) {\n    if(i%2 == 0) {\n      tribonacci[i] = 1 + i / 2;\n    } else {\n      tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3];\n    }\n  }\n  return tribonacci;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n  std::vector<long> tribonacci(n + 1);\n  tribonacci[0] = 0;\n  tribonacci[1] = 3;\n  if (n > 1) {\n    tribonacci[2] = 2;\n    for (long i = 3; i <= n; i++) {\n      if (i % 2 == 0) {\n        tribonacci[i] = 1 + i / 2;\n      } else {\n        tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3];\n      }\n    }\n  }\n  return tribonacci;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n  std::vector<long> tribonacci(n + 1);\n  tribonacci[0] = 1;\n  tribonacci[1] = 3;\n\n  for (long i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      tribonacci[i] = 1 + i / 2;\n    } else {\n      tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + (1 + (i + 1) / 2);\n    }\n  }\n\n  return tribonacci;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n  std::vector<long> result(n + 1);\n  result[0] = 1;\n  result[1] = 3;\n  for (long i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      result[i] = 1 + i / 2;\n    } else {\n      result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n    }\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n  long count = 0;\n  for (long i = 1; i < n; i++) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      std::string num = std::to_string(i);\n      count += std::count(num.begin(), num.end(), '7');\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n  long count = 0;\n  for (long i = 1; i < n; i++) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      std::string num = std::to_string(i);\n      count += std::count(num.begin(), num.end(), '7');\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n  long count = 0;\n  for (long i = 1; i < n; i++) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      std::string number = std::to_string(i);\n      count += std::count(number.begin(), number.end(), '7');\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n  long count = 0;\n  for (long i = 1; i < n; i++) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      std::string num = std::to_string(i);\n      count += std::count(num.begin(), num.end(), '7');\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n  long count = 0;\n  for (long i = 1; i < n; i++) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      std::string num = std::to_string(i);\n      for (char c : num) {\n        if (c == '7') {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n  long count = 0;\n  for (long i = 1; i < n; i++) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      std::string s = std::to_string(i);\n      count += std::count(s.begin(), s.end(), '7');\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n  long count = 0;\n  for (long i = 1; i < n; i++) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      std::string s = std::to_string(i);\n      count += std::count(s.begin(), s.end(), '7');\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n  long count = 0;\n  for (long i = 0; i < n; i++) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      std::string str = std::to_string(i);\n      count += std::count(str.begin(), str.end(), '7');\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n  long count = 0;\n  for (long i = 0; i < n; i++) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      std::string num = std::to_string(i);\n      count += std::count(num.begin(), num.end(), '7');\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n  long count = 0;\n  for (long i = 1; i < n; i++) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      std::string str = std::to_string(i);\n      count += std::count(str.begin(), str.end(), '7');\n    }\n  }\n  return count;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const auto& str : strings) {\n    if (str.substr(0, prefix.length()) == prefix) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const auto& str : strings) {\n    if (str.substr(0, prefix.size()) == prefix) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto &str : strings) {\n    if (str.substr(0, prefix.size()) == prefix) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const auto& str : strings) {\n    if (str.substr(0, prefix.size()) == prefix) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const auto& str : strings) {\n    if (str.substr(0, prefix.size()) == prefix) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto &str : strings) {\n    if (str.substr(0, prefix.size()) == prefix) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const auto& str : strings) {\n    if (str.substr(0, prefix.size()) == prefix) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const auto& str : strings) {\n    if (str.substr(0, prefix.size()) == prefix) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto &str : strings) {\n    if (str.substr(0, prefix.size()) == prefix) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const auto& str : strings) {\n    if (str.substr(0, prefix.size()) == prefix) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n  int sum = 0;\n  while (N > 0) {\n    sum += N % 2;\n    N /= 2;\n  }\n  return std::bitset<32>(sum).to_string();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n  std::bitset<14> binary(N);\n  return binary.to_string();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n  std::string binary = \"\";\n  while (N > 0) {\n    binary = std::to_string(N % 2) + binary;\n    N /= 2;\n  }\n  return binary;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n  std::bitset<14> binary(N);\n  std::string binary_str = binary.to_string();\n  binary_str.erase(0, binary_str.find_first_not_of('0'));\n  return binary_str;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n  int sum = 0;\n  while (N > 0) {\n    sum += N % 2;\n    N /= 2;\n  }\n  return std::bitset<32>(sum).to_string();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n  std::bitset<14> binary(N);\n  return binary.to_string();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n  int sum = 0;\n  while (N > 0) {\n    sum += N % 2;\n    N /= 2;\n  }\n  return std::bitset<64>(sum).to_string();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n  int sum = 0;\n  while (N > 0) {\n    sum += N % 2;\n    N /= 2;\n  }\n  return std::to_string(sum);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N /= 2;\n    }\n    return std::to_string(sum);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n  int sum = 0;\n  while (N > 0) {\n    sum += N % 2;\n    N /= 2;\n  }\n  return std::bitset<32>(sum).to_string();\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  std::vector<long> path;\n  long N = grid.size();\n  long min_val = N * N + 1;\n  std::pair<long, long> start;\n\n  // Find the minimum value and its position\n  for (long i = 0; i < N; ++i) {\n    for (long j = 0; j < N; ++j) {\n      if (grid[i][j] < min_val) {\n        min_val = grid[i][j];\n        start = {i, j};\n      }\n    }\n  }\n\n  // Initialize the path with the minimum value\n  path.push_back(min_val);\n\n  // Move to the neighbour cells and update the path\n  for (long i = 1; i < k; ++i) {\n    std::vector<long> neighbours;\n    if (start.first > 0) neighbours.push_back(grid[start.first - 1][start.second]);\n    if (start.first < N - 1) neighbours.push_back(grid[start.first + 1][start.second]);\n    if (start.second > 0) neighbours.push_back(grid[start.first][start.second - 1]);\n    if (start.second < N - 1) neighbours.push_back(grid[start.first][start.second + 1]);\n\n    // Find the minimum value among the neighbours\n    min_val = *std::min_element(neighbours.begin(), neighbours.end());\n    path.push_back(min_val);\n\n    // Update the position\n    for (long dx = -1; dx <= 1; ++dx) {\n      for (long dy = -1; dy <= 1; ++dy) {\n        if (std::abs(dx) + std::abs(dy) != 1) continue;\n        long nx = start.first + dx;\n        long ny = start.second + dy;\n        if (nx >= 0 && nx < N && ny >= 0 && ny < N && grid[nx][ny] == min_val) {\n          start = {nx, ny};\n          break;\n        }\n      }\n    }\n  }\n\n  return path;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  std::vector<long> result;\n  long N = grid.size();\n  std::priority_queue<std::pair<long, std::pair<int, int>>, std::vector<std::pair<long, std::pair<int, int>>>, std::greater<>> pq;\n  \n  for (long i = 0; i < N; ++i) {\n    for (long j = 0; j < N; ++j) {\n      pq.push({grid[i][j], {i, j}});\n    }\n  }\n  \n  for (long i = 0; i < k; ++i) {\n    auto [val, pos] = pq.top();\n    pq.pop();\n    result.push_back(val);\n  }\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  std::vector<long> path;\n  long N = grid.size();\n  long min_val = N*N + 1;\n  std::pair<long, long> start;\n\n  // Find the smallest value and its position\n  for (long i = 0; i < N; ++i) {\n    for (long j = 0; j < N; ++j) {\n      if (grid[i][j] < min_val) {\n        min_val = grid[i][j];\n        start = {i, j};\n      }\n    }\n  }\n\n  // Start from the smallest value\n  path.push_back(min_val);\n\n  // Move to the neighbor cell with the smallest value\n  for (long i = 1; i < k; ++i) {\n    long next_val = N*N + 1;\n    std::pair<long, long> next;\n\n    for (long dx = -1; dx <= 1; ++dx) {\n      for (long dy = -1; dy <= 1; ++dy) {\n        long x = start.first + dx;\n        long y = start.second + dy;\n\n        if (x >= 0 && x < N && y >= 0 && y < N && std::abs(dx) + std::abs(dy) == 1) {\n          if (grid[x][y] < next_val) {\n            next_val = grid[x][y];\n            next = {x, y};\n          }\n        }\n      }\n    }\n\n    path.push_back(next_val);\n    start = next;\n  }\n\n  return path;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  std::vector<long> result;\n  long n = grid.size();\n  long min_val = n * n + 1;\n  long min_i, min_j;\n\n  // Find the minimum value and its position\n  for (long i = 0; i < n; i++) {\n    for (long j = 0; j < n; j++) {\n      if (grid[i][j] < min_val) {\n        min_val = grid[i][j];\n        min_i = i;\n        min_j = j;\n      }\n    }\n  }\n\n  // Start from the cell with the minimum value\n  result.push_back(min_val);\n\n  // Move to the neighbor cells with the smallest value\n  for (long step = 1; step < k; step++) {\n    long next_val = n * n + 1;\n    long next_i, next_j;\n\n    // Check the neighbors\n    for (long i = std::max((long)0, min_i - 1); i <= std::min(n - 1, min_i + 1); i++) {\n      for (long j = std::max((long)0, min_j - 1); j <= std::min(n - 1, min_j + 1); j++) {\n        if (grid[i][j] < next_val) {\n          next_val = grid[i][j];\n          next_i = i;\n          next_j = j;\n        }\n      }\n    }\n\n    // Move to the cell with the smallest value among the neighbors\n    result.push_back(next_val);\n    min_i = next_i;\n    min_j = next_j;\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  std::vector<long> result;\n  long minVal = grid[0][0];\n  long minRow = 0;\n  long minCol = 0;\n  \n  // Find the minimum value and its position\n  for (long i = 0; i < grid.size(); i++) {\n    for (long j = 0; j < grid[i].size(); j++) {\n      if (grid[i][j] < minVal) {\n        minVal = grid[i][j];\n        minRow = i;\n        minCol = j;\n      }\n    }\n  }\n\n  // Start from the cell with the minimum value\n  result.push_back(minVal);\n  \n  for (long i = 1; i < k; i++) {\n    // If possible, move left\n    if (minCol > 0 && grid[minRow][minCol - 1] < minVal) {\n      minCol--;\n    }\n    // If possible, move up\n    else if (minRow > 0 && grid[minRow - 1][minCol] < minVal) {\n      minRow--;\n    }\n    // If possible, move right\n    else if (minCol < grid[0].size() - 1 && grid[minRow][minCol + 1] < minVal) {\n      minCol++;\n    }\n    // If possible, move down\n    else if (minRow < grid.size() - 1 && grid[minRow + 1][minCol] < minVal) {\n      minRow++;\n    }\n    // Add the current cell to the path\n    result.push_back(grid[minRow][minCol]);\n  }\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  std::vector<long> result;\n  long n = grid.size();\n  \n  // Find the minimum value in the grid\n  long min_val = grid[0][0];\n  int min_i = 0, min_j = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (grid[i][j] < min_val) {\n        min_val = grid[i][j];\n        min_i = i;\n        min_j = j;\n      }\n    }\n  }\n\n  // Add the minimum value to the result vector\n  result.push_back(min_val);\n\n  // Repeat the process for the remaining steps\n  for (long step = 1; step < k; step++) {\n    // Check the neighbors of the current cell\n    std::vector<std::pair<int, int>> neighbors = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    long next_val = LONG_MAX;\n    int next_i = min_i, next_j = min_j;\n    for (auto& neighbor : neighbors) {\n      int i = min_i + neighbor.first, j = min_j + neighbor.second;\n      if (i >= 0 && i < n && j >= 0 && j < n && grid[i][j] < next_val) {\n        next_val = grid[i][j];\n        next_i = i;\n        next_j = j;\n      }\n    }\n\n    // Move to the cell with the minimum value among the neighbors\n    min_i = next_i;\n    min_j = next_j;\n    result.push_back(next_val);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  std::vector<long> path;\n  long N = grid.size();\n  \n  // Find the smallest number in the grid\n  long min_value = grid[0][0];\n  std::pair<int, int> min_pos = {0, 0};\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n      if (grid[i][j] < min_value) {\n        min_value = grid[i][j];\n        min_pos = {i, j};\n      }\n    }\n  }\n  \n  // Start from the cell with the smallest number\n  path.push_back(min_value);\n  \n  // Move to the neighbor cells with the smallest number until the path length is k\n  for (long step = 1; step < k; ++step) {\n    std::pair<int, int> next_pos = min_pos;\n    long next_value = N * N + 1;\n    \n    // Check the four neighbor cells\n    for (int dx = -1; dx <= 1; ++dx) {\n      for (int dy = -1; dy <= 1; ++dy) {\n        if (std::abs(dx) + std::abs(dy) != 1) continue;  // Not a neighbor cell\n        int x = min_pos.first + dx;\n        int y = min_pos.second + dy;\n        if (x < 0 || x >= N || y < 0 || y >= N) continue;  // Off the grid\n        if (grid[x][y] < next_value) {\n          next_value = grid[x][y];\n          next_pos = {x, y};\n        }\n      }\n    }\n    \n    min_pos = next_pos;\n    path.push_back(next_value);\n  }\n  \n  return path;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  std::vector<long> result;\n  long min_val = *std::min_element(grid.begin(), grid.end());\n  for (int i = 0; i < k; i++) {\n    result.push_back(min_val);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  std::vector<long> path;\n  long N = grid.size();\n  std::priority_queue<std::pair<long, std::pair<int, int>>, std::vector<std::pair<long, std::pair<int, int>>>, std::greater<std::pair<long, std::pair<int, int>>>> pq;\n\n  for(int i=0; i<N; i++){\n    for(int j=0; j<N; j++){\n      pq.push({grid[i][j], {i, j}});\n    }\n  }\n\n  while(path.size() < k){\n    auto [val, pos] = pq.top();\n    pq.pop();\n    path.push_back(val);\n    int x = pos.first, y = pos.second;\n\n    if(x+1 < N) pq.push({grid[x+1][y], {x+1, y}});\n    if(x-1 >= 0) pq.push({grid[x-1][y], {x-1, y}});\n    if(y+1 < N) pq.push({grid[x][y+1], {x, y+1}});\n    if(y-1 >= 0) pq.push({grid[x][y-1], {x, y-1}});\n  }\n\n  return path;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  std::vector<long> result;\n  long N = grid.size();\n  long min_val = N * N + 1;\n  std::pair<long, long> start;\n\n  // Find the minimum value and its position\n  for (long i = 0; i < N; ++i) {\n    for (long j = 0; j < N; ++j) {\n      if (grid[i][j] < min_val) {\n        min_val = grid[i][j];\n        start = {i, j};\n      }\n    }\n  }\n\n  // Start from the cell with minimum value\n  result.push_back(min_val);\n\n  // Move to the neighboring cell with the smallest value until the path length is k\n  for (long step = 1; step < k; ++step) {\n    std::pair<long, long> dirs[4] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    min_val = N * N + 1;\n    std::pair<long, long> next;\n\n    // Check all 4 directions\n    for (auto &dir : dirs) {\n      long x = start.first + dir.first;\n      long y = start.second + dir.second;\n\n      // If the cell is valid and its value is smaller, update the next cell\n      if (x >= 0 && x < N && y >= 0 && y < N && grid[x][y] < min_val) {\n        min_val = grid[x][y];\n        next = {x, y};\n      }\n    }\n\n    // Move to the next cell\n    start = next;\n    result.push_back(min_val);\n  }\n\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.length(); i += 2) {\n    char c = s[i];\n    if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.size(); i += 2) {\n    char c = s[i];\n    if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.length(); i += 2) {\n    char c = s[i];\n    if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.length(); i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.length(); i += 2) {\n    char c = s[i];\n    if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.length(); i += 2) {\n    char c = s[i];\n    if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.length(); i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.length(); i += 2) {\n    char c = s[i];\n    if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.length(); i += 2) {\n    char c = s[i];\n    if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.length(); i += 2) {\n    char c = s[i];\n    if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n      count++;\n    }\n  }\n  return count;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.begin(), arr.end(), std::greater<long>());\n  std::vector<long> result(arr.begin(), arr.begin() + k);\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.begin(), arr.end(), std::greater<long>());\n  std::vector<long> result(arr.begin(), arr.begin() + k);\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.begin(), arr.end(), std::greater<long>());\n  arr.resize(k);\n  return arr;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.begin(), arr.end(), std::greater<long>());\n  arr.resize(k);\n  return arr;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.begin(), arr.end(), std::greater<long>());\n  arr.resize(k);\n  return arr;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.begin(), arr.end(), std::greater<long>());\n  arr.resize(k);\n  return arr;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.begin(), arr.end(), std::greater<long>());\n  arr.resize(k);\n  return arr;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.begin(), arr.end(), std::greater<long>());\n  arr.resize(k);\n  return arr;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.begin(), arr.end(), std::greater<long>());\n  arr.resize(k);\n  return arr;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.begin(), arr.end(), std::greater<long>());\n  arr.resize(k);\n  std::sort(arr.begin(), arr.end());\n  return arr;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n  for (long i = n - 1; i > 0; i--) {\n    if (n % i == 0) {\n      return i;\n    }\n  }\n  return 1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n  for (long i = n / 2; i >= 1; i--) {\n    if (n % i == 0) {\n      return i;\n    }\n  }\n  return 1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n  for (long i = n - 1; i > 0; i--) {\n    if (n % i == 0) {\n      return i;\n    }\n  }\n  return 1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n  for (long i = n - 1; i > 0; i--) {\n    if (n % i == 0) {\n      return i;\n    }\n  }\n  return 1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n  for (long i = n - 1; i > 0; i--) {\n    if (n % i == 0) {\n      return i;\n    }\n  }\n  return 1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n  for (long i = n - 1; i > 0; i--) {\n    if (n % i == 0) {\n      return i;\n    }\n  }\n  return 1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n  for (long i = n - 1; i > 0; i--) {\n    if (n % i == 0) {\n      return i;\n    }\n  }\n  return 1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n  for(long i = n - 1; i > 0; i--) {\n    if(n % i == 0) {\n      return i;\n    }\n  }\n  return 1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n  for (long i = n - 1; i > 0; i--) {\n    if (n % i == 0) {\n      return i;\n    }\n  }\n  return 1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n  for (long i = n - 1; i > 0; i--) {\n    if (n % i == 0) {\n      return i;\n    }\n  }\n  return 1;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> sorted_array = array;\n  if ((array.front() + array.back()) % 2 == 0) {\n    std::sort(sorted_array.begin(), sorted_array.end(), std::greater<long>());\n  } else {\n    std::sort(sorted_array.begin(), sorted_array.end());\n  }\n  return sorted_array;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> sorted_array = array;\n  if ((array.front() + array.back()) % 2 == 0) {\n    std::sort(sorted_array.begin(), sorted_array.end(), std::greater<long>());\n  } else {\n    std::sort(sorted_array.begin(), sorted_array.end());\n  }\n  return sorted_array;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> sorted_array = array;\n  if ((array.front() + array.back()) % 2 == 0) {\n    std::sort(sorted_array.begin(), sorted_array.end(), std::greater<long>());\n  } else {\n    std::sort(sorted_array.begin(), sorted_array.end());\n  }\n  return sorted_array;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> sorted_array = array;\n  if ((array.front() + array.back()) % 2 == 0) {\n    std::sort(sorted_array.begin(), sorted_array.end(), std::greater<long>());\n  } else {\n    std::sort(sorted_array.begin(), sorted_array.end());\n  }\n  return sorted_array;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> result = array;\n  if ((result.front() + result.back()) % 2 == 0) {\n    std::sort(result.rbegin(), result.rend());\n  } else {\n    std::sort(result.begin(), result.end());\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> sorted_array = array;\n  if ((sorted_array.front() + sorted_array.back()) % 2 == 0) {\n    std::sort(sorted_array.begin(), sorted_array.end(), std::greater<long>());\n  } else {\n    std::sort(sorted_array.begin(), sorted_array.end());\n  }\n  return sorted_array;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> sorted_array = array;\n  if ((array.front() + array.back()) % 2 == 0) {\n    std::sort(sorted_array.begin(), sorted_array.end(), std::greater<long>());\n  } else {\n    std::sort(sorted_array.begin(), sorted_array.end());\n  }\n  return sorted_array;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> sorted_array = array;\n  if ((sorted_array.front() + sorted_array.back()) % 2 == 0) {\n    std::sort(sorted_array.begin(), sorted_array.end(), std::greater<long>());\n  } else {\n    std::sort(sorted_array.begin(), sorted_array.end());\n  }\n  return sorted_array;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> sorted_array = array;\n  if ((array.front() + array.back()) % 2 == 0) {\n    std::sort(sorted_array.begin(), sorted_array.end(), std::greater<long>());\n  } else {\n    std::sort(sorted_array.begin(), sorted_array.end());\n  }\n  return sorted_array;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> sorted_array = array;\n  if ((array.front() + array.back()) % 2 == 0) {\n    std::sort(sorted_array.begin(), sorted_array.end(), std::greater<long>());\n  } else {\n    std::sort(sorted_array.begin(), sorted_array.end());\n  }\n  return sorted_array;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n  std::vector<long> result(n);\n  for (long i = 1; i <= n; i++) {\n    if (i % 2 == 0) {\n      long factorial = 1;\n      for (long j = 1; j <= i; j++) {\n        factorial *= j;\n      }\n      result[i-1] = factorial;\n    } else {\n      long sum = 0;\n      for (long j = 1; j <= i; j++) {\n        sum += j;\n      }\n      result[i-1] = sum;\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n  std::vector<long> result(n);\n  long factorial = 1;\n  long sum = 0;\n  \n  for (long i = 1; i <= n; i++) {\n    if (i % 2 == 0) {\n      factorial *= i;\n      result[i-1] = factorial;\n    } else {\n      sum += i;\n      result[i-1] = sum;\n    }\n  }\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n  std::vector<long> result(n);\n  long fact = 1;\n  long sum = 0;\n\n  for (long i = 1; i <= n; i++) {\n    if (i % 2 == 0) {\n      fact *= i;\n      result[i-1] = fact;\n    } else {\n      sum += i;\n      result[i-1] = sum;\n    }\n  }\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n  std::vector<long> result(n);\n  result[0] = 1;\n  for (long i = 1; i < n; i++) {\n    if (i % 2 == 0) {\n      result[i] = result[i - 2] * (i + 1);\n    } else {\n      result[i] = result[i - 1] + (i + 1);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n  std::vector<long> result(n);\n  result[0] = 1;\n  for (long i = 1; i < n; ++i) {\n    if (i % 2 == 0) {\n      result[i] = result[i-1] * (i+1);\n    } else {\n      result[i] = result[i-1] + (i+1);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n  std::vector<long> result(n);\n  long factorial = 1;\n  long sum = 0;\n\n  for (long i = 1; i <= n; i++) {\n    if (i % 2 == 0) {\n      factorial *= i;\n      result[i-1] = factorial;\n    } else {\n      sum += i;\n      result[i-1] = sum;\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n  std::vector<long> result(n);\n  long factorial = 1;\n  long sum = 0;\n\n  for (long i = 1; i <= n; i++) {\n    if (i % 2 == 0) {\n      factorial *= i;\n      result[i-1] = factorial;\n    } else {\n      sum += i;\n      result[i-1] = sum;\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n  std::vector<long> result(n);\n  long fact = 1;\n  long sum = 0;\n\n  for (long i = 1; i <= n; i++) {\n    if (i % 2 == 0) {\n      fact *= i;\n      result[i-1] = fact;\n    } else {\n      sum += i;\n      result[i-1] = sum;\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n  std::vector<long> result(n);\n  for (long i = 1; i <= n; i++) {\n    if (i % 2 == 0) {\n      long factorial = 1;\n      for (long j = 1; j <= i; j++) {\n        factorial *= j;\n      }\n      result[i - 1] = factorial;\n    } else {\n      long sum = 0;\n      for (long j = 1; j <= i; j++) {\n        sum += j;\n      }\n      result[i - 1] = sum;\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n  std::vector<long> result(n);\n  result[0] = 1;\n  for (long i = 1; i < n; i++) {\n    if (i % 2 == 0) {\n      result[i] = 1;\n      for (long j = 1; j <= i; j++) {\n        result[i] *= j;\n      }\n    } else {\n      result[i] = 0;\n      for (long j = 1; j <= i; j++) {\n        result[i] += j;\n      }\n    }\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n  long root = cbrt(a);\n  return root * root * root == a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n  long root = cbrt(a);\n  return root * root * root == a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n  long root = cbrt(a);\n  return root * root * root == a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n  long root = round(cbrt(a));\n  return root * root * root == a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n  long root = round(cbrt(a));\n  return root * root * root == a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n  long root = round(cbrt(a));\n  return root * root * root == a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n  long root = cbrt(a);\n  return root * root * root == a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n  long root = cbrt(a);\n  return root*root*root == a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n  long root = cbrt(a);\n  return root * root * root == a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n  long root = cbrt(a);\n  return root * root * root == a;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string result = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                c = toupper(c);\n                if (c == 'A') c = 'C';\n                else if (c == 'E') c = 'G';\n                else if (c == 'I') c = 'K';\n                else if (c == 'O') c = 'Q';\n                else if (c == 'U') c = 'W';\n            } else {\n                c = tolower(c);\n                if (c == 'a') c = 'c';\n                else if (c == 'e') c = 'g';\n                else if (c == 'i') c = 'k';\n                else if (c == 'o') c = 'q';\n                else if (c == 'u') c = 'w';\n            }\n        }\n        result += c;\n    }\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n  std::string encoded_message = \"\";\n  for (char c : message) {\n    if (isalpha(c)) {\n      if (isupper(c)) {\n        c = tolower(c);\n      } else {\n        c = toupper(c);\n      }\n      if (c == 'a') {\n        c = 'c';\n      } else if (c == 'e') {\n        c = 'g';\n      } else if (c == 'i') {\n        c = 'k';\n      } else if (c == 'o') {\n        c = 'q';\n      } else if (c == 'u') {\n        c = 'w';\n      }\n    }\n    encoded_message += c;\n  }\n  return encoded_message;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n  std::string encoded = \"\";\n  for (char c : message) {\n    if (isalpha(c)) {\n      if (islower(c)) {\n        c = toupper(c);\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n          c = c + 2;\n        }\n      } else {\n        c = tolower(c);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n          c = c + 2;\n        }\n      }\n    }\n    encoded += c;\n  }\n  return encoded;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n  std::string result = \"\";\n  for (char &c : message) {\n    if (isalpha(c)) {\n      if (islower(c)) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n          result += toupper(c + 2);\n        } else {\n          result += toupper(c);\n        }\n      } else {\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n          result += tolower(c + 2);\n        } else {\n          result += tolower(c);\n        }\n      }\n    } else {\n      result += c;\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n  std::string encoded = \"\";\n  for (char c : message) {\n    if (isalpha(c)) {\n      if (islower(c)) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n          encoded += toupper(c + 2);\n        } else {\n          encoded += toupper(c);\n        }\n      } else {\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n          encoded += tolower(c + 2);\n        } else {\n          encoded += tolower(c);\n        }\n      }\n    } else {\n      encoded += c;\n    }\n  }\n  return encoded;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n  std::string result = \"\";\n  for (char& c : message) {\n    if (isalpha(c)) {\n      if (islower(c)) {\n        c = toupper(c);\n        if (c == 'A') c = 'C';\n        else if (c == 'E') c = 'G';\n        else if (c == 'I') c = 'K';\n        else if (c == 'O') c = 'Q';\n        else if (c == 'U') c = 'W';\n      } else {\n        c = tolower(c);\n        if (c == 'a') c = 'c';\n        else if (c == 'e') c = 'g';\n        else if (c == 'i') c = 'k';\n        else if (c == 'o') c = 'q';\n        else if (c == 'u') c = 'w';\n      }\n    }\n    result += c;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string encoded = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            if (isupper(c)) {\n                if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                    encoded += (c == 'U') ? 'A' : (c + 2);\n                } else {\n                    encoded += tolower(c);\n                }\n            } else {\n                if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                    encoded += (c == 'u') ? 'A' : toupper(c + 2);\n                } else {\n                    encoded += toupper(c);\n                }\n            }\n        } else {\n            encoded += c;\n        }\n    }\n    return encoded;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n  std::string encoded = \"\";\n  for (char& c : message) {\n    if (isalpha(c)) {\n      if (isupper(c)) {\n        c = tolower(c);\n      } else {\n        c = toupper(c);\n      }\n      if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n        c += 2;\n      }\n    }\n    encoded += c;\n  }\n  return encoded;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n  std::string encoded = \"\";\n  for (char c : message) {\n    if (isalpha(c)) {\n      if (islower(c)) {\n        c = toupper(c);\n      } else {\n        c = tolower(c);\n      }\n      if (c == 'a') {\n        c = 'c';\n      } else if (c == 'e') {\n        c = 'g';\n      } else if (c == 'i') {\n        c = 'k';\n      } else if (c == 'o') {\n        c = 'q';\n      } else if (c == 'u') {\n        c = 'w';\n      } else if (c == 'y') {\n        c = 'a';\n      }\n    }\n    encoded += c;\n  }\n  return encoded;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n  for(int i = 0; i < message.length(); i++) {\n    if(isalpha(message[i])) {\n      if(isupper(message[i])) {\n        message[i] = tolower(message[i]);\n      } else {\n        message[i] = toupper(message[i]);\n      }\n      \n      if(message[i] == 'A' || message[i] == 'E' || message[i] == 'I' || message[i] == 'O' || message[i] == 'U') {\n        message[i] += 2;\n      }\n    }\n  }\n  return message;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n  long count = 0;\n  std::istringstream iss(S);\n  std::string sentence;\n  while (std::getline(iss, sentence, '.')) {\n    std::istringstream iss2(sentence);\n    std::string word;\n    if (iss2 >> word && word == \"I\") {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    long count = 0;\n    std::istringstream iss(S);\n    std::string sentence;\n\n    while (std::getline(iss, sentence, '.')) {\n        std::istringstream iss2(sentence);\n        std::string word;\n        if (iss2 >> word && word == \"I\") {\n            count++;\n        }\n    }\n\n    return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n  long count = 0;\n  std::istringstream iss(S);\n  std::string sentence;\n  while (std::getline(iss, sentence, '.')) {\n    std::istringstream iss2(sentence);\n    std::string word;\n    if (iss2 >> word && word == \"I\") {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n  long count = 0;\n  std::istringstream iss(S);\n  std::string sentence;\n  \n  while (std::getline(iss, sentence, '.')) {\n    std::istringstream iss2(sentence);\n    std::string word;\n    if (iss2 >> word && word == \"I\") {\n      count++;\n    }\n  }\n  \n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n  long count = 0;\n  std::istringstream iss(S);\n  std::string sentence;\n\n  while (std::getline(iss, sentence, '.')) {\n    std::istringstream iss_sentence(sentence);\n    std::string first_word;\n    iss_sentence >> first_word;\n    if (first_word == \"I\") {\n      count++;\n    }\n  }\n\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n  long count = 0;\n  std::istringstream ss(S);\n  std::string sentence;\n  while(std::getline(ss, sentence, '.')) {\n    std::istringstream iss(sentence);\n    std::string word;\n    if(iss >> word) {\n      if(word == \"I\") {\n        count++;\n      }\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n  long count = 0;\n  std::istringstream iss(S);\n  std::string sentence;\n  while (std::getline(iss, sentence, '.')) {\n    std::istringstream iss2(sentence);\n    std::string word;\n    if (iss2 >> word && word == \"I\") {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n  long count = 0;\n  std::istringstream iss(S);\n  std::string sentence;\n  \n  while(std::getline(iss, sentence, '.')) {\n    std::istringstream iss2(sentence);\n    std::string word;\n    if(iss2 >> word) {\n      if(word == \"I\") {\n        count++;\n      }\n    }\n  }\n  \n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n  long count = 0;\n  std::istringstream iss(S);\n  std::string sentence;\n  \n  while (std::getline(iss, sentence, '.')) {\n    std::istringstream iss2(sentence);\n    std::string word;\n    if (iss2 >> word && word == \"I\") {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n  long count = 0;\n  std::istringstream iss(S);\n  std::string sentence;\n\n  while (std::getline(iss, sentence, '.')) {\n    std::istringstream iss_sentence(sentence);\n    std::string word;\n    if (iss_sentence >> word && word == \"I\") {\n      count++;\n    }\n  }\n\n  return count;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n  std::unordered_set<long> s;\n  for (long i : l) {\n    if (s.find(-i) != s.end()) {\n      return true;\n    }\n    s.insert(i);\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n  std::unordered_set<long> s;\n  for (long i : l) {\n    if (s.find(-i) != s.end()) {\n      return true;\n    }\n    s.insert(i);\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n  std::unordered_set<long> s;\n  for (long i : l) {\n    if (s.find(-i) != s.end()) {\n      return true;\n    }\n    s.insert(i);\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n  std::unordered_set<long> set;\n  for (long i : l) {\n    if (set.find(-i) != set.end()) {\n      return true;\n    }\n    set.insert(i);\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n  std::unordered_set<long> set;\n  for (long i : l) {\n    if (set.find(-i) != set.end()) {\n      return true;\n    }\n    set.insert(i);\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n  std::unordered_set<long> set;\n  for (long i : l) {\n    if (set.find(-i) != set.end())\n      return true;\n    set.insert(i);\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n  std::unordered_set<long> set;\n  for (long i : l) {\n    if (set.find(-i) != set.end()) {\n      return true;\n    }\n    set.insert(i);\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n  std::unordered_set<long> set;\n  for (long i : l) {\n    if (set.find(-i) != set.end()) {\n      return true;\n    }\n    set.insert(i);\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n  std::unordered_set<long> set;\n  for (long i : l) {\n    if (set.find(-i) != set.end()) {\n      return true;\n    }\n    set.insert(i);\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n  std::unordered_set<long> set;\n  for (long i : l) {\n    if (set.find(-i) != set.end()) {\n      return true;\n    }\n    set.insert(i);\n  }\n  return false;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return roundf(area * 100) / 100;\n  } else {\n    return -1;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100.0) / 100.0;\n  } else {\n    return -1;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100;\n  } else {\n    return -1;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100.0;\n  } else {\n    return -1;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100.0;\n  } else {\n    return -1;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100.0;\n  } else {\n    return -1;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100.0;\n  } else {\n    return -1;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100.0;\n  } else {\n    return -1;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100;\n  }\n  else {\n    return -1;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100.0;\n  }\n  else {\n    return -1;\n  }\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n  std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  std::vector<std::string> result;\n  auto it1 = std::find(planets.begin(), planets.end(), planet1);\n  auto it2 = std::find(planets.begin(), planets.end(), planet2);\n  \n  if(it1 == planets.end() || it2 == planets.end()) {\n    return result;\n  }\n  \n  if(it1 > it2) {\n    std::swap(it1, it2);\n  }\n  \n  for(auto it = it1 + 1; it < it2; ++it) {\n    result.push_back(*it);\n  }\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n  std::map<std::string, int> planets = {{\"Mercury\", 1}, {\"Venus\", 2}, {\"Earth\", 3}, {\"Mars\", 4}, {\"Jupiter\", 5}, {\"Saturn\", 6}, {\"Uranus\", 7}, {\"Neptune\", 8}};\n  std::vector<std::string> result;\n\n  if(planets.find(planet1) == planets.end() || planets.find(planet2) == planets.end()){\n    return result;\n  }\n\n  int start = std::min(planets[planet1], planets[planet2]);\n  int end = std::max(planets[planet1], planets[planet2]);\n\n  for(auto& planet : planets){\n    if(planet.second > start && planet.second < end){\n      result.push_back(planet.first);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n  std::map<std::string, int> planet_order = {\n    {\"Mercury\", 1},\n    {\"Venus\", 2},\n    {\"Earth\", 3},\n    {\"Mars\", 4},\n    {\"Jupiter\", 5},\n    {\"Saturn\", 6},\n    {\"Uranus\", 7},\n    {\"Neptune\", 8}\n  };\n\n  std::vector<std::string> planets = {\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\"\n  };\n\n  if(planet_order.find(planet1) == planet_order.end() || planet_order.find(planet2) == planet_order.end()) {\n    return std::vector<std::string>();\n  }\n\n  int start = std::min(planet_order[planet1], planet_order[planet2]);\n  int end = std::max(planet_order[planet1], planet_order[planet2]);\n\n  std::vector<std::string> result;\n  for(int i = start; i < end - 1; i++) {\n    result.push_back(planets[i]);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n  std::map<std::string, int> planets = {\n    {\"Mercury\", 1}, {\"Venus\", 2}, {\"Earth\", 3}, {\"Mars\", 4}, \n    {\"Jupiter\", 5}, {\"Saturn\", 6}, {\"Uranus\", 7}, {\"Neptune\", 8}\n  };\n\n  if (planets.find(planet1) == planets.end() || planets.find(planet2) == planets.end()) {\n    return std::vector<std::string>();\n  }\n\n  int start = std::min(planets[planet1], planets[planet2]);\n  int end = std::max(planets[planet1], planets[planet2]);\n\n  std::vector<std::string> result;\n  for (const auto& planet : planets) {\n    if (planet.second > start && planet.second < end) {\n      result.push_back(planet.first);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n  std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  std::vector<std::string> result;\n  \n  auto it1 = std::find(planets.begin(), planets.end(), planet1);\n  auto it2 = std::find(planets.begin(), planets.end(), planet2);\n  \n  if (it1 == planets.end() || it2 == planets.end()) {\n    return result; // empty vector\n  }\n  \n  if (it1 > it2) {\n    std::swap(it1, it2);\n  }\n  \n  for (auto it = it1 + 1; it < it2; ++it) {\n    result.push_back(*it);\n  }\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n  std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  std::vector<std::string> result;\n  auto it1 = std::find(planets.begin(), planets.end(), planet1);\n  auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n  if (it1 == planets.end() || it2 == planets.end()) {\n    return result;\n  }\n\n  if (it1 > it2) {\n    std::swap(it1, it2);\n  }\n\n  for (auto it = it1 + 1; it < it2; ++it) {\n    result.push_back(*it);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n  std::map<std::string, int> planets = {{\"Mercury\", 1}, {\"Venus\", 2}, {\"Earth\", 3}, {\"Mars\", 4}, {\"Jupiter\", 5}, {\"Saturn\", 6}, {\"Uranus\", 7}, {\"Neptune\", 8}};\n  std::vector<std::string> result;\n  \n  if (planets.find(planet1) == planets.end() || planets.find(planet2) == planets.end()) {\n    return result;\n  }\n  \n  int start = std::min(planets[planet1], planets[planet2]);\n  int end = std::max(planets[planet1], planets[planet2]);\n  \n  for (auto& planet : planets) {\n    if (planet.second > start && planet.second < end) {\n      result.push_back(planet.first);\n    }\n  }\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n  std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  std::vector<std::string> result;\n  auto it1 = std::find(planets.begin(), planets.end(), planet1);\n  auto it2 = std::find(planets.begin(), planets.end(), planet2);\n  \n  if (it1 == planets.end() || it2 == planets.end() || it1 == it2)\n    return result;\n\n  if (it1 > it2)\n    std::swap(it1, it2);\n\n  for (auto it = it1 + 1; it < it2; ++it)\n    result.push_back(*it);\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n  std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  std::vector<std::string> result;\n  \n  auto it1 = std::find(planets.begin(), planets.end(), planet1);\n  auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n  if (it1 == planets.end() || it2 == planets.end()) {\n    return result;\n  }\n\n  if (it1 > it2) {\n    std::swap(it1, it2);\n  }\n\n  for (auto it = it1 + 1; it < it2; ++it) {\n    result.push_back(*it);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n  std::map<std::string, int> planets = {{\"Mercury\", 1}, {\"Venus\", 2}, {\"Earth\", 3}, {\"Mars\", 4}, {\"Jupiter\", 5}, {\"Saturn\", 6}, {\"Uranus\", 7}, {\"Neptune\", 8}};\n  std::vector<std::string> result;\n  \n  if (planets.find(planet1) == planets.end() || planets.find(planet2) == planets.end()) {\n    return result;\n  }\n  \n  int start = std::min(planets[planet1], planets[planet2]);\n  int end = std::max(planets[planet1], planets[planet2]);\n\n  for (auto& planet : planets) {\n    if (planet.second > start && planet.second < end) {\n      result.push_back(planet.first);\n    }\n  }\n  \n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n  long product = 1;\n  bool hasOdd = false;\n  while (n > 0) {\n    int digit = n % 10;\n    if (digit % 2 != 0) {\n      product *= digit;\n      hasOdd = true;\n    }\n    n /= 10;\n  }\n  return hasOdd ? product : 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n  long product = 1;\n  bool hasOdd = false;\n  while (n > 0) {\n    long digit = n % 10;\n    if (digit % 2 != 0) {\n      product *= digit;\n      hasOdd = true;\n    }\n    n /= 10;\n  }\n  return hasOdd ? product : 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n  long product = 1;\n  bool hasOdd = false;\n  while (n > 0) {\n    long digit = n % 10;\n    if (digit % 2 != 0) {\n      product *= digit;\n      hasOdd = true;\n    }\n    n /= 10;\n  }\n  return hasOdd ? product : 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n  long product = 1;\n  bool allEven = true;\n  while (n > 0) {\n    int digit = n % 10;\n    if (digit % 2 != 0) {\n      product *= digit;\n      allEven = false;\n    }\n    n /= 10;\n  }\n  return allEven ? 0 : product;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n  long product = 1;\n  bool hasOdd = false;\n  while (n > 0) {\n    long digit = n % 10;\n    if (digit % 2 != 0) {\n      product *= digit;\n      hasOdd = true;\n    }\n    n /= 10;\n  }\n  return hasOdd ? product : 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n  long product = 1;\n  bool hasOdd = false;\n  while (n > 0) {\n    long digit = n % 10;\n    if (digit % 2 != 0) {\n      product *= digit;\n      hasOdd = true;\n    }\n    n /= 10;\n  }\n  return hasOdd ? product : 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n  long product = 1;\n  bool isOdd = false;\n  while (n != 0) {\n    long digit = n % 10;\n    if (digit % 2 != 0) {\n      product *= digit;\n      isOdd = true;\n    }\n    n /= 10;\n  }\n  return isOdd ? product : 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n  long product = 1;\n  bool hasOdd = false;\n  while (n > 0) {\n    long digit = n % 10;\n    if (digit % 2 != 0) {\n      product *= digit;\n      hasOdd = true;\n    }\n    n /= 10;\n  }\n  return hasOdd ? product : 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n  long product = 1;\n  bool hasOdd = false;\n  while (n > 0) {\n    int digit = n % 10;\n    if (digit % 2 != 0) {\n      product *= digit;\n      hasOdd = true;\n    }\n    n /= 10;\n  }\n  if (hasOdd) {\n    return product;\n  } else {\n    return 0;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n  long product = 1;\n  bool hasOdd = false;\n\n  while (n > 0) {\n    long digit = n % 10;\n    if (digit % 2 != 0) {\n      product *= digit;\n      hasOdd = true;\n    }\n    n /= 10;\n  }\n\n  return hasOdd ? product : 0;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word = \"\";\n  for (auto x : s) {\n    if (x == ' ' || x == ',') {\n      if (!word.empty()) {\n        words.push_back(word);\n        word = \"\";\n      }\n    } else {\n      word = word + x;\n    }\n  }\n  if (!word.empty()) {\n    words.push_back(word);\n  }\n  return words;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word;\n  std::stringstream ss(s);\n  while (getline(ss, word, ' ')) {\n    words.push_back(word);\n  }\n  return words;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word = \"\";\n  for (auto x : s) {\n    if (x == ' ' || x == ',') {\n      if (!word.empty()) {\n        words.push_back(word);\n        word = \"\";\n      }\n    } else {\n      word = word + x;\n    }\n  }\n  if (!word.empty()) {\n    words.push_back(word);\n  }\n  return words;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word;\n  std::stringstream ss(s);\n  while (getline(ss, word, ' ')) {\n    words.push_back(word);\n  }\n  return words;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word;\n  std::stringstream ss(s);\n  while (getline(ss, word, ' ')) {\n    words.push_back(word);\n  }\n  return words;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word;\n  std::stringstream ss(s);\n  while (getline(ss, word, ' ')) {\n    words.push_back(word);\n  }\n  return words;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word;\n  std::stringstream ss(s);\n  \n  while (getline(ss, word, ' ')) {\n    words.push_back(word);\n  }\n  \n  return words;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word;\n  std::stringstream ss(s);\n\n  while (getline(ss, word, ' ')) {\n    words.push_back(word);\n  }\n  \n  return words;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word;\n  std::stringstream ss(s);\n  \n  while (getline(ss, word, ' ')) {\n    words.push_back(word);\n  }\n  \n  return words;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word;\n  std::stringstream ss(s);\n  while (getline(ss, word, ' ')) {\n    words.push_back(word);\n  }\n  return words;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n  long count = 0;\n  size_t pos = 0;\n  \n  while ((pos = string.find(substring, pos)) != std::string::npos) {\n    count++;\n    pos++;\n  }\n  \n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n  long count = 0;\n  size_t pos = 0;\n  while ((pos = string.find(substring, pos)) != std::string::npos) {\n    count++;\n    pos++;\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n  long count = 0;\n  size_t pos = 0;\n  while ((pos = string.find(substring, pos)) != std::string::npos) {\n    count++;\n    pos++;\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n  long count = 0;\n  size_t pos = 0;\n  while ((pos = string.find(substring, pos)) != std::string::npos) {\n    count++;\n    pos++;\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n  long count = 0;\n  size_t pos = 0;\n  while ((pos = string.find(substring, pos)) != std::string::npos) {\n     count++;\n     pos++;\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n  long count = 0;\n  size_t pos = 0;\n  while ((pos = string.find(substring, pos)) != std::string::npos) {\n    ++count;\n    ++pos;\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n  long count = 0;\n  size_t pos = 0;\n  while ((pos = string.find(substring, pos)) != std::string::npos) {\n    count++;\n    pos++;\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n  long count = 0;\n  size_t pos = 0;\n  while ((pos = string.find(substring, pos)) != std::string::npos) {\n    count++;\n    pos++;\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n  long count = 0;\n  size_t pos = 0;\n  while ((pos = string.find(substring, pos)) != std::string::npos) {\n    count++;\n    pos++;\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n  long count = 0;\n  size_t pos = 0;\n  while ((pos = string.find(substring, pos)) != std::string::npos) {\n    ++count;\n    ++pos;\n  }\n  return count;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n  if (a.f0 == b.f0 && a.f1 == b.f1 && a.f2 == b.f2) {\n    return Union_long_float_std_string_std_nullopt(std::nullopt);\n  } else if (a.f0 > b.f0) {\n    return Union_long_float_std_string_std_nullopt(a.f0);\n  } else if (a.f1 > b.f1) {\n    return Union_long_float_std_string_std_nullopt(a.f1);\n  } else if (a.f2 > b.f2) {\n    return Union_long_float_std_string_std_nullopt(a.f2);\n  } else if (b.f0 > a.f0) {\n    return Union_long_float_std_string_std_nullopt(b.f0);\n  } else if (b.f1 > a.f1) {\n    return Union_long_float_std_string_std_nullopt(b.f1);\n  } else if (b.f2 > a.f2) {\n    return Union_long_float_std_string_std_nullopt(b.f2);\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n  if(a.f0 == b.f0 && a.f1 == b.f1 && a.f2 == b.f2) {\n    return std::nullopt;\n  }\n\n  if(a.f0 > b.f0) {\n    return Union_long_float_std_string_std_nullopt(a.f0);\n  } else if(a.f1 > b.f1) {\n    return Union_long_float_std_string_std_nullopt(a.f1);\n  } else if(a.f2 > b.f2) {\n    return Union_long_float_std_string_std_nullopt(a.f2);\n  }\n\n  if(b.f0 > a.f0) {\n    return Union_long_float_std_string_std_nullopt(b.f0);\n  } else if(b.f1 > a.f1) {\n    return Union_long_float_std_string_std_nullopt(b.f1);\n  } else if(b.f2 > a.f2) {\n    return Union_long_float_std_string_std_nullopt(b.f2);\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n  if (a == b) {\n    return Union_long_float_std_string_std_nullopt(std::nullopt);\n  } else if (a.f0 > b.f0) {\n    return Union_long_float_std_string_std_nullopt(a.f0);\n  } else if (a.f1 > b.f1) {\n    return Union_long_float_std_string_std_nullopt(a.f1);\n  } else if (a.f2 > b.f2) {\n    return Union_long_float_std_string_std_nullopt(a.f2);\n  } else {\n    return Union_long_float_std_string_std_nullopt(b.f0 ? b.f0 : (b.f1 ? b.f1 : b.f2));\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n  if (a.f0 == b.f0 && a.f1 == b.f1 && a.f2 == b.f2) {\n    return Union_long_float_std_string_std_nullopt(std::nullopt);\n  }\n  if (a.f0 > b.f0) {\n    return Union_long_float_std_string_std_nullopt(a.f0);\n  }\n  if (a.f1 > b.f1) {\n    return Union_long_float_std_string_std_nullopt(a.f1);\n  }\n  if (a.f2 > b.f2) {\n    return Union_long_float_std_string_std_nullopt(a.f2);\n  }\n  if (b.f0 > a.f0) {\n    return Union_long_float_std_string_std_nullopt(b.f0);\n  }\n  if (b.f1 > a.f1) {\n    return Union_long_float_std_string_std_nullopt(b.f1);\n  }\n  if (b.f2 > a.f2) {\n    return Union_long_float_std_string_std_nullopt(b.f2);\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n  if (a.f0 == b.f0 && a.f1 == b.f1 && a.f2 == b.f2) {\n    return Union_long_float_std_string_std_nullopt(std::nullopt);\n  }\n  if (a.f0 > b.f0) {\n    return Union_long_float_std_string_std_nullopt(a.f0);\n  }\n  if (a.f1 > b.f1) {\n    return Union_long_float_std_string_std_nullopt(a.f1);\n  }\n  if (a.f2 > b.f2) {\n    return Union_long_float_std_string_std_nullopt(a.f2);\n  }\n  if (b.f0 > a.f0) {\n    return Union_long_float_std_string_std_nullopt(b.f0);\n  }\n  if (b.f1 > a.f1) {\n    return Union_long_float_std_string_std_nullopt(b.f1);\n  }\n  return Union_long_float_std_string_std_nullopt(b.f2);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n  if (a == b) {\n    return std::nullopt;\n  }\n  if (a.f0 > b.f0) {\n    return a.f0;\n  }\n  if (a.f1 > b.f1) {\n    return a.f1;\n  }\n  if (a.f2 > b.f2) {\n    return a.f2;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    } else if (a.f0 > b.f0) {\n        return a.f0;\n    } else if (a.f1 > b.f1) {\n        return a.f1;\n    } else if (a.f2 > b.f2) {\n        return a.f2;\n    } else {\n        return b;\n    }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a.f0 == b.f0 && a.f1 == b.f1 && a.f2 == b.f2) {\n        return Union_long_float_std_string_std_nullopt(std::nullopt);\n    } else if (a.f0 > b.f0) {\n        return Union_long_float_std_string_std_nullopt(a.f0);\n    } else if (a.f1 > b.f1) {\n        return Union_long_float_std_string_std_nullopt(a.f1);\n    } else if (a.f2 > b.f2) {\n        return Union_long_float_std_string_std_nullopt(a.f2);\n    } else {\n        if (b.f0 != 0) {\n            return Union_long_float_std_string_std_nullopt(b.f0);\n        } else if (b.f1 != 0.0f) {\n            return Union_long_float_std_string_std_nullopt(b.f1);\n        } else {\n            return Union_long_float_std_string_std_nullopt(b.f2);\n        }\n    }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n  if (a == b) {\n    return std::nullopt;\n  } else if (a.f0 > b.f0) {\n    return Union_long_float_std_string_std_nullopt(a.f0);\n  } else if (a.f1 > b.f1) {\n    return Union_long_float_std_string_std_nullopt(a.f1);\n  } else {\n    return Union_long_float_std_string_std_nullopt(a.f2);\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n  if (a.f0 == b.f0 && a.f1 == b.f1 && a.f2 == b.f2) {\n    return Union_long_float_std_string_std_nullopt(std::nullopt);\n  }\n  if (a.f0 > b.f0) {\n    return Union_long_float_std_string_std_nullopt(a.f0);\n  }\n  if (a.f1 > b.f1) {\n    return Union_long_float_std_string_std_nullopt(a.f1);\n  }\n  if (a.f2 > b.f2) {\n    return Union_long_float_std_string_std_nullopt(a.f2);\n  }\n  if (b.f0 > a.f0) {\n    return Union_long_float_std_string_std_nullopt(b.f0);\n  }\n  if (b.f1 > a.f1) {\n    return Union_long_float_std_string_std_nullopt(b.f1);\n  }\n  if (b.f2 > a.f2) {\n    return Union_long_float_std_string_std_nullopt(b.f2);\n  }\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n  std::string result = \"\";\n  for (char c : text) {\n    if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && \n        c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n      result += c;\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n  std::string result;\n  for (char c : text) {\n    if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n        c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n      result += c;\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n  std::string result;\n  for (char c : text) {\n    if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n        c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n      result += c;\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n  std::string result = \"\";\n  for (char c : text) {\n    if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n        c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n      result += c;\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n  std::string result = \"\";\n  for (char c : text) {\n    if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && \n        c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n      result += c;\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n  std::string result = \"\";\n  for (char c : text) {\n    if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n        c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n      result += c;\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n  std::string result;\n  for (char c : text) {\n    if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n        c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n      result += c;\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n  std::string result = \"\";\n  for (char c : text) {\n    if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n        c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n      result += c;\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n  std::string result;\n  for (char c : text) {\n    if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n        c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n      result += c;\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n  std::string result;\n  for (char c : text) {\n    if (!(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n          c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')) {\n      result += c;\n    }\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  std::sort(lst.begin(), lst.end());\n  std::vector<long> result;\n  while (!lst.empty()) {\n    result.push_back(lst.front());\n    lst.erase(lst.begin());\n    if (!lst.empty()) {\n      result.push_back(lst.back());\n      lst.pop_back();\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  std::sort(lst.begin(), lst.end());\n  std::vector<long> result;\n  while (!lst.empty()) {\n    result.push_back(lst.front());\n    lst.erase(lst.begin());\n    if (!lst.empty()) {\n      result.push_back(lst.back());\n      lst.pop_back();\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  std::sort(lst.begin(), lst.end());\n  std::vector<long> result;\n  while (!lst.empty()) {\n    result.push_back(lst.front());\n    lst.erase(lst.begin());\n    if (!lst.empty()) {\n      result.push_back(lst.back());\n      lst.pop_back();\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  std::vector<long> result;\n  std::sort(lst.begin(), lst.end());\n\n  while (!lst.empty()) {\n    result.push_back(lst.front());\n    lst.erase(lst.begin());\n\n    if (!lst.empty()) {\n      result.push_back(lst.back());\n      lst.pop_back();\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  std::vector<long> result;\n  std::sort(lst.begin(), lst.end());\n\n  while (!lst.empty()) {\n    result.push_back(lst.front());\n    lst.erase(lst.begin());\n    if (!lst.empty()) {\n      result.push_back(lst.back());\n      lst.pop_back();\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  std::vector<long> result;\n  std::sort(lst.begin(), lst.end());\n\n  while (!lst.empty()) {\n    result.push_back(lst.front());\n    lst.erase(lst.begin());\n\n    if (!lst.empty()) {\n      result.push_back(lst.back());\n      lst.pop_back();\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  std::sort(lst.begin(), lst.end());\n  std::vector<long> result;\n  while (!lst.empty()) {\n    result.push_back(lst.front());\n    lst.erase(lst.begin());\n    if (!lst.empty()) {\n      result.push_back(lst.back());\n      lst.pop_back();\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  std::sort(lst.begin(), lst.end());\n  std::vector<long> result;\n  while (!lst.empty()) {\n    result.push_back(lst.front());\n    lst.erase(lst.begin());\n    if (!lst.empty()) {\n      result.push_back(lst.back());\n      lst.pop_back();\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  std::vector<long> result;\n  std::sort(lst.begin(), lst.end());\n\n  while (!lst.empty()) {\n    result.push_back(lst.front());\n    lst.erase(lst.begin());\n\n    if (!lst.empty()) {\n      result.push_back(lst.back());\n      lst.pop_back();\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  std::vector<long> result;\n  std::sort(lst.begin(), lst.end());\n\n  while (!lst.empty()) {\n    result.push_back(lst.front());\n    lst.erase(lst.begin());\n\n    if (!lst.empty()) {\n      result.push_back(lst.back());\n      lst.pop_back();\n    }\n  }\n\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n  std::sort(numbers.begin(), numbers.end());\n  float min_diff = std::numeric_limits<float>::max();\n  std::tuple<float, float> closest_pair;\n\n  for (int i = 0; i < numbers.size() - 1; i++) {\n    float diff = numbers[i+1] - numbers[i];\n    if (diff < min_diff) {\n      min_diff = diff;\n      closest_pair = std::make_tuple(numbers[i], numbers[i+1]);\n    }\n  }\n\n  return closest_pair;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n  std::sort(numbers.begin(), numbers.end());\n  float min_diff = FLT_MAX;\n  std::tuple<float, float> result;\n\n  for (int i = 0; i < numbers.size() - 1; ++i) {\n    float diff = numbers[i+1] - numbers[i];\n    if (diff < min_diff) {\n      min_diff = diff;\n      result = std::make_tuple(numbers[i], numbers[i+1]);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n  std::sort(numbers.begin(), numbers.end());\n  float min_diff = FLT_MAX;\n  float first, second;\n  \n  for (int i = 0; i < numbers.size() - 1; i++) {\n    float diff = numbers[i+1] - numbers[i];\n    if (diff < min_diff) {\n      min_diff = diff;\n      first = numbers[i];\n      second = numbers[i+1];\n    }\n  }\n  \n  return std::make_tuple(first, second);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n  sort(numbers.begin(), numbers.end());\n  float min_diff = FLT_MAX;\n  std::tuple<float, float> closest_pair;\n\n  for (int i = 0; i < numbers.size() - 1; i++) {\n    float diff = numbers[i+1] - numbers[i];\n    if (diff < min_diff) {\n      min_diff = diff;\n      closest_pair = std::make_tuple(numbers[i], numbers[i+1]);\n    }\n  }\n\n  return closest_pair;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n  std::sort(numbers.begin(), numbers.end());\n  float min_diff = FLT_MAX;\n  float first, second;\n  for (int i = 0; i < numbers.size() - 1; i++) {\n    float diff = numbers[i+1] - numbers[i];\n    if (diff < min_diff) {\n      min_diff = diff;\n      first = numbers[i];\n      second = numbers[i+1];\n    }\n  }\n  return std::make_tuple(first, second);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n  sort(numbers.begin(), numbers.end());\n\n  float minDiff = FLT_MAX;\n  float x, y;\n\n  for (int i = 0; i < numbers.size() - 1; i++) {\n    float diff = numbers[i + 1] - numbers[i];\n    if (diff < minDiff) {\n      minDiff = diff;\n      x = numbers[i];\n      y = numbers[i + 1];\n    }\n  }\n\n  return std::make_tuple(x, y);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n  std::sort(numbers.begin(), numbers.end());\n  float min_diff = std::numeric_limits<float>::max();\n  std::tuple<float, float> closest_elements;\n\n  for (int i = 0; i < numbers.size() - 1; ++i) {\n    float diff = numbers[i+1] - numbers[i];\n    if (diff < min_diff) {\n      min_diff = diff;\n      closest_elements = std::make_tuple(numbers[i], numbers[i+1]);\n    }\n  }\n\n  return closest_elements;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n  std::sort(numbers.begin(), numbers.end());\n  float min_diff = FLT_MAX;\n  float num1, num2;\n\n  for (int i = 0; i < numbers.size() - 1; i++) {\n    float diff = numbers[i+1] - numbers[i];\n    if (diff < min_diff) {\n      min_diff = diff;\n      num1 = numbers[i];\n      num2 = numbers[i+1];\n    }\n  }\n\n  return std::make_tuple(num1, num2);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n  std::sort(numbers.begin(), numbers.end());\n\n  float min_diff = FLT_MAX;\n  std::tuple<float, float> result;\n\n  for (int i = 0; i < numbers.size() - 1; i++) {\n    float diff = numbers[i+1] - numbers[i];\n    if (diff < min_diff) {\n      min_diff = diff;\n      result = std::make_tuple(numbers[i], numbers[i+1]);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n  std::sort(numbers.begin(), numbers.end());\n  float min_diff = FLT_MAX;\n  std::tuple<float, float> result;\n  for (int i = 0; i < numbers.size() - 1; i++) {\n    float diff = numbers[i+1] - numbers[i];\n    if (diff < min_diff) {\n      min_diff = diff;\n      result = std::make_tuple(numbers[i], numbers[i+1]);\n    }\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n  if (x == 1) {\n    return true;\n  }\n  while (x != 1) {\n    if (x % n != 0) {\n      return false;\n    }\n    x /= n;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n  if (x == 1) return true;\n  if (n == 1) return false;\n  while (x != 1) {\n    if (x % n != 0) return false;\n    x = x / n;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n  if (x == 1) return true;\n  if (n == 1) return false;\n  while (x != 1) {\n    if (x % n != 0) return false;\n    x /= n;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n  if (x == 1) return true;\n  if (n == 1) return false;\n  \n  while (x != 1) {\n    if (x % n != 0) return false;\n    x /= n;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n  if (x == 1) {\n    return true;\n  }\n  while (x % n == 0) {\n    x = x / n;\n  }\n  return x == 1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n  if (x == 1) return true;\n  if (n == 1) return false;\n  while (x != 1) {\n    if (x % n != 0) return false;\n    x /= n;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n  if (x == 1) return true;\n  if (n == 1) return false;\n  \n  while (x != 1) {\n    if (x % n != 0) return false;\n    x /= n;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n  if (x == 1) return true;\n  if (n == 1) return false;\n\n  while (x != 1) {\n    if (x % n != 0) return false;\n    x /= n;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n  if (x == 1) return true;\n  while (x != 1) {\n    if (x % n != 0) return false;\n    x /= n;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n  if (x == 1) return true;\n  if (n == 1) return false;\n  \n  while (x != 1) {\n    if (x % n != 0) return false;\n    x /= n;\n  }\n  \n  return true;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n  std::vector<long> fib = {0, 1};\n  std::vector<long> prime_fibs;\n  long i = 2;\n  while (prime_fibs.size() < n) {\n    fib.push_back(fib[i - 1] + fib[i - 2]);\n    if (is_prime(fib[i])) {\n      prime_fibs.push_back(fib[i]);\n    }\n    i++;\n  }\n  return prime_fibs[n - 1];\n}\n\nbool is_prime(long n) {\n  if (n <= 1) return false;\n  if (n == 2) return true;\n  if (n % 2 == 0) return false;\n  for (long i = 3; i <= sqrt(n); i += 2) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n  std::vector<long> fib = {0, 1};\n  std::vector<long> primeFib;\n\n  for (long i = 2; primeFib.size() < n; i++) {\n    fib.push_back(fib[i - 1] + fib[i - 2]);\n\n    if (fib[i] < 2) continue;\n\n    bool isPrime = true;\n    for (long j = 2; j * j <= fib[i]; j++) {\n      if (fib[i] % j == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n\n    if (isPrime) primeFib.push_back(fib[i]);\n  }\n\n  return primeFib[n - 1];\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n  std::vector<long> fib = {0, 1};\n  std::vector<long> primeFib;\n  \n  while (primeFib.size() < n) {\n    long nextFib = fib[fib.size() - 1] + fib[fib.size() - 2];\n    fib.push_back(nextFib);\n    \n    bool isPrime = true;\n    if (nextFib < 2) isPrime = false;\n    for (long i = 2; i * i <= nextFib; i++) {\n      if (nextFib % i == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    \n    if (isPrime) primeFib.push_back(nextFib);\n  }\n  \n  return primeFib[n - 1];\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n  long a = 0, b = 1, c = a + b;\n  std::vector<long> primeFibs;\n  \n  // Function to check if number is prime\n  auto isPrime = [](long n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (long i = 3; i * i <= n; i += 2) {\n      if (n % i == 0) return false;\n    }\n    return true;\n  };\n  \n  // Generate prime Fibonacci numbers\n  while (primeFibs.size() < n) {\n    if (isPrime(c)) {\n      primeFibs.push_back(c);\n    }\n    a = b;\n    b = c;\n    c = a + b;\n  }\n  \n  return primeFibs[n - 1];\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n  std::vector<long> fib = {0, 1};\n  std::vector<long> prime_fibs;\n  long i = 2;\n\n  auto is_prime = [](long n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (long i = 3; i * i <= n; i += 2) {\n      if (n % i == 0) return false;\n    }\n    return true;\n  };\n\n  while (prime_fibs.size() < n) {\n    fib.push_back(fib[i - 1] + fib[i - 2]);\n    if (is_prime(fib[i])) prime_fibs.push_back(fib[i]);\n    i++;\n  }\n\n  return prime_fibs[n - 1];\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n  long fib1 = 0, fib2 = 1, fib = fib1 + fib2;\n  std::vector<long> primeFibs;\n\n  // Function to check prime number\n  auto isPrime = [](int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i = i + 6)\n      if (n % i == 0 || n % (i + 2) == 0)\n        return false;\n    return true;\n  };\n\n  // Generate prime Fibonacci numbers until we have enough\n  while (primeFibs.size() < n) {\n    if (isPrime(fib)) {\n      primeFibs.push_back(fib);\n    }\n    fib1 = fib2;\n    fib2 = fib;\n    fib = fib1 + fib2;\n  }\n\n  return primeFibs[n - 1];\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n  std::vector<long> fib = {0, 1};\n  std::vector<long> primeFibs;\n  \n  for (long i = 2; primeFibs.size() < n; i++) {\n    fib.push_back(fib[i-1] + fib[i-2]);\n    \n    if (fib[i] < 2) continue;\n    bool isPrime = true;\n    for (long j = 2; j*j <= fib[i]; j++) {\n      if (fib[i] % j == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    \n    if (isPrime) primeFibs.push_back(fib[i]);\n  }\n  \n  return primeFibs[n-1];\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n  long a = 0, b = 1, c = a + b;\n  long count = 0;\n\n  while(count < n){\n    long j;\n    for(j = 2; j <= sqrt(c); j++){\n      if(c % j == 0)\n        break;\n    }\n    if(j > sqrt(c) && c != 1){\n      count++;\n    }\n    a = b;\n    b = c;\n    c = a + b;\n  }\n  return b;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n  long i = 2, count = 0;\n  while (true) {\n    long fib = fibonacci(i);\n    if (is_prime(fib)) {\n      count++;\n      if (count == n) {\n        return fib;\n      }\n    }\n    i++;\n  }\n}\n\nlong fibonacci(long n) {\n  if (n <= 1) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nbool is_prime(long n) {\n  if (n <= 1) {\n    return false;\n  }\n  for (long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n  std::vector<long> fib = {0, 1};\n  std::vector<long> primeFib;\n\n  for (long i = 2; primeFib.size() < n; i++) {\n    fib.push_back(fib[i - 1] + fib[i - 2]);\n\n    bool isPrime = true;\n    for (long j = 2; j * j <= fib[i]; j++) {\n      if (fib[i] % j == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n\n    if (isPrime && fib[i] != 1) {\n      primeFib.push_back(fib[i]);\n    }\n  }\n\n  return primeFib[n - 1];\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n  std::stable_sort(nums.begin(), nums.end(), [](long a, long b) {\n    long sum_a = 0, sum_b = 0;\n    a = abs(a);\n    b = abs(b);\n    while (a) {\n      sum_a += a % 10;\n      a /= 10;\n    }\n    while (b) {\n      sum_b += b % 10;\n      b /= 10;\n    }\n    return sum_a < sum_b;\n  });\n  return nums;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n  auto sum_of_digits = [](long n) {\n    n = std::abs(n);\n    int sum = 0;\n    while (n) {\n      sum += n % 10;\n      n /= 10;\n    }\n    return sum;\n  };\n\n  std::stable_sort(nums.begin(), nums.end(), [&](long a, long b) {\n    return sum_of_digits(a) < sum_of_digits(b);\n  });\n\n  return nums;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n  std::stable_sort(nums.begin(), nums.end(), [](long a, long b) {\n    long sumA = 0, sumB = 0;\n    a = std::abs(a);\n    b = std::abs(b);\n    while (a) {\n      sumA += a % 10;\n      a /= 10;\n    }\n    while (b) {\n      sumB += b % 10;\n      b /= 10;\n    }\n    return sumA < sumB;\n  });\n  return nums;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n  std::stable_sort(nums.begin(), nums.end(), [](long a, long b) {\n    long sum_a = 0, sum_b = 0;\n    a = abs(a);\n    b = abs(b);\n    while (a) {\n      sum_a += a % 10;\n      a /= 10;\n    }\n    while (b) {\n      sum_b += b % 10;\n      b /= 10;\n    }\n    return sum_a < sum_b;\n  });\n  return nums;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n  std::stable_sort(nums.begin(), nums.end(), [](long a, long b) {\n    int sum_a = 0, sum_b = 0;\n    a = abs(a);\n    b = abs(b);\n    while (a != 0) {\n      sum_a += a % 10;\n      a /= 10;\n    }\n    while (b != 0) {\n      sum_b += b % 10;\n      b /= 10;\n    }\n    return sum_a < sum_b;\n  });\n  return nums;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n  std::stable_sort(nums.begin(), nums.end(), [](long a, long b) {\n    int sum_a = 0, sum_b = 0;\n    a = abs(a);\n    b = abs(b);\n    while (a > 0) {\n      sum_a += a % 10;\n      a /= 10;\n    }\n    while (b > 0) {\n      sum_b += b % 10;\n      b /= 10;\n    }\n    return sum_a < sum_b;\n  });\n  return nums;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n  std::stable_sort(nums.begin(), nums.end(), [](long a, long b) {\n    int sum_a = 0, sum_b = 0;\n    a = std::abs(a);\n    b = std::abs(b);\n    while (a > 0) {\n      sum_a += a % 10;\n      a /= 10;\n    }\n    while (b > 0) {\n      sum_b += b % 10;\n      b /= 10;\n    }\n    return sum_a < sum_b;\n  });\n  return nums;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n  std::stable_sort(nums.begin(), nums.end(), [](long a, long b) {\n    int sum_a = 0, sum_b = 0;\n    a = std::abs(a);\n    b = std::abs(b);\n    while(a > 0) {\n      sum_a += a % 10;\n      a /= 10;\n    }\n    while(b > 0) {\n      sum_b += b % 10;\n      b /= 10;\n    }\n    return sum_a < sum_b;\n  });\n  return nums;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n  std::stable_sort(nums.begin(), nums.end(), [](long a, long b) {\n    int sum_a = 0, sum_b = 0;\n    a = std::abs(a);\n    b = std::abs(b);\n    while (a != 0) {\n      sum_a += a % 10;\n      a /= 10;\n    }\n    while (b != 0) {\n      sum_b += b % 10;\n      b /= 10;\n    }\n    return sum_a < sum_b;\n  });\n  return nums;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n  std::stable_sort(nums.begin(), nums.end(), [](long a, long b) {\n    int sumA = 0, sumB = 0;\n    a = abs(a), b = abs(b);\n    while (a) {\n      sumA += a % 10;\n      a /= 10;\n    }\n    while (b) {\n      sumB += b % 10;\n      b /= 10;\n    }\n    return sumA < sumB;\n  });\n  return nums;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n  for (int i = 0; i < numbers.size(); i++) {\n    for (int j = i + 1; j < numbers.size(); j++) {\n      if (abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n  for (int i = 0; i < numbers.size(); i++) {\n    for (int j = i + 1; j < numbers.size(); j++) {\n      if (abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n  for (int i = 0; i < numbers.size(); i++) {\n    for (int j = i + 1; j < numbers.size(); j++) {\n      if (abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n  for (int i = 0; i < numbers.size(); i++) {\n    for (int j = i + 1; j < numbers.size(); j++) {\n      if (abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n  for (int i = 0; i < numbers.size(); i++) {\n    for (int j = i + 1; j < numbers.size(); j++) {\n      if (abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n  for (int i = 0; i < numbers.size(); i++) {\n    for (int j = i + 1; j < numbers.size(); j++) {\n      if (abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n  for (int i = 0; i < numbers.size(); i++) {\n    for (int j = i + 1; j < numbers.size(); j++) {\n      if (abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n  for (int i = 0; i < numbers.size(); i++) {\n    for (int j = i + 1; j < numbers.size(); j++) {\n      if (abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n  for (int i = 0; i < numbers.size(); i++) {\n    for (int j = i + 1; j < numbers.size(); j++) {\n      if (abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n  for(int i=0; i<numbers.size(); i++) {\n    for(int j=i+1; j<numbers.size(); j++) {\n      if(abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n  std::string rev_s = string;\n  std::reverse(rev_s.begin(), rev_s.end());\n  \n  for (int i = 0; i < rev_s.size(); ++i) {\n    if (string.substr(0, string.size() - i) == rev_s.substr(i)) {\n      return string + rev_s.substr(0, i);\n    }\n  }\n  \n  return \"\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    std::string rev = string;\n    std::reverse(rev.begin(), rev.end());\n    int n = string.size();\n\n    for (int i = 0; i < n; i++) {\n        if (string.substr(0, n - i) == rev.substr(i)) {\n            return string + rev.substr(0, i);\n        }\n    }\n\n    return \"\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n  std::string rev = string;\n  std::reverse(rev.begin(), rev.end());\n  \n  for (int i = 0; i < rev.size(); i++) {\n    if (string.substr(0, string.size() - i) == rev.substr(i)) {\n      return string + rev.substr(0, i);\n    }\n  }\n  \n  return string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n  std::string reverse_string = string;\n  std::reverse(reverse_string.begin(), reverse_string.end());\n\n  int n = string.size();\n  for (int i = 0; i < n; i++) {\n    if (string.substr(0, n - i) == reverse_string.substr(i)) {\n      return string + reverse_string.substr(0, i);\n    }\n  }\n\n  return \"\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    int n = string.size();\n    std::string rev = string;\n    std::reverse(rev.begin(), rev.end());\n    std::string s = string + \"#\" + rev;\n    int m = s.size();\n    std::vector<int> p(m, 0);\n    for (int i = 1; i < m; ++i) {\n        int j = p[i - 1];\n        while (j > 0 && s[i] != s[j]) {\n            j = p[j - 1];\n        }\n        if (s[i] == s[j]) {\n            ++j;\n        }\n        p[i] = j;\n    }\n    return string + rev.substr(0, n - p[m - 1]);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n  std::string rev = string;\n  std::reverse(rev.begin(), rev.end());\n  \n  for (int i = 0; i < string.size(); i++) {\n    if (string.substr(0, string.size() - i) == rev.substr(i)) {\n      return string + rev.substr(0, i);\n    }\n  }\n  \n  return string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n  std::string rev = string;\n  std::reverse(rev.begin(), rev.end());\n\n  for (int i = 0; i < rev.size(); ++i) {\n    if (string.substr(0, string.size() - i) == rev.substr(i)) {\n      return string + rev.substr(0, i);\n    }\n  }\n\n  return string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n  std::string rev_string = string;\n  std::reverse(rev_string.begin(), rev_string.end());\n  \n  for (int i = 0; i < string.size(); ++i) {\n    if (string.substr(0, string.size() - i) == rev_string.substr(i)) {\n      return string + rev_string.substr(0, i);\n    }\n  }\n  \n  return string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n  std::string rev = string;\n  std::reverse(rev.begin(), rev.end());\n  for (int i = 0; i < string.length(); ++i) {\n    if (string.substr(0, string.length() - i) == rev.substr(i)) {\n      return string + rev.substr(0, i);\n    }\n  }\n  return \"\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n  int n = string.length();\n  int i = 0;\n  for (int j = n - 1; j >= 0; j--) {\n    if (string[i] == string[j]) {\n      i++;\n    }\n  }\n\n  if (i == n) {\n    return string;\n  }\n\n  std::string suffix = string.substr(i, n);\n  std::reverse(suffix.begin(), suffix.end());\n  return suffix + make_palindrome(string.substr(0, i)) + string.substr(i, n);\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n  std::string result = \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i]) {\n      result += \"0\";\n    } else {\n      result += \"1\";\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n  std::string result = \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i]) {\n      result += \"0\";\n    } else {\n      result += \"1\";\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n  std::string result = \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i]) {\n      result += '0';\n    } else {\n      result += '1';\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n  std::string result = \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i])\n      result += \"0\";\n    else\n      result += \"1\";\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n  std::string result = \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i]) {\n      result += '0';\n    } else {\n      result += '1';\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n  std::string result = \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i])\n      result += \"0\";\n    else\n      result += \"1\";\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n  std::string result = \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i]) {\n      result += '0';\n    } else {\n      result += '1';\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n  std::string result = \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i]) {\n      result += '0';\n    } else {\n      result += '1';\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n  std::string result = \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i])\n      result += \"0\";\n    else\n      result += \"1\";\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n  std::string result = \"\";\n  for (int i = 0; i < a.size(); i++) {\n    if (a[i] == b[i]) {\n      result += \"0\";\n    } else {\n      result += \"1\";\n    }\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n  long long result = 1;\n  for (long i = n; i > 0; i--) {\n    long long fact = 1;\n    for (long j = i; j > 0; j--) {\n      fact *= j;\n    }\n    result *= fact;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n  long long result = 1;\n  long long temp = 1;\n  for (long i = 1; i <= n; i++) {\n    temp *= i;\n    result *= temp;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n  long long result = 1;\n  for (long i = n; i > 0; i--) {\n    long long factorial = 1;\n    for (long j = i; j > 0; j--) {\n      factorial *= j;\n    }\n    result *= factorial;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n  long long result = 1;\n  long long factorial = 1;\n  for (long i = 1; i <= n; i++) {\n    factorial *= i;\n    result *= factorial;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n  long long factorial = 1;\n  long long brazilian_factorial = 1;\n  for (long i = 1; i <= n; i++) {\n    factorial *= i;\n    brazilian_factorial *= factorial;\n  }\n  return brazilian_factorial;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n  long long factorial = 1;\n  for (long i = n; i > 0; i--) {\n    for (long j = i; j > 0; j--) {\n      factorial *= j;\n    }\n  }\n  return factorial;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n  long long result = 1;\n  for(long i = n; i > 0; i--){\n    long long factorial = 1;\n    for(long j = i; j > 0; j--){\n      factorial *= j;\n    }\n    result *= factorial;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n  long long result = 1;\n  for (long i = n; i > 0; i--) {\n    for (long j = i; j > 0; j--) {\n      result *= j;\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n  long long result = 1;\n  long long factorial = 1;\n  for (long i = 1; i <= n; i++) {\n    factorial *= i;\n    result *= factorial;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n  long long result = 1;\n  for (long i = n; i > 0; i--) {\n    long long factorial = 1;\n    for (long j = i; j > 0; j--) {\n      factorial *= j;\n    }\n    result *= factorial;\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (int i = 0; i < k; i++) {\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (int i = 0; i < k; i++) {\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (int i = 0; i < k; i++) {\n    if (arr[i] >= 10 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (int i = 0; i < k; i++) {\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (int i = 0; i < k; i++) {\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (int i = 0; i < k; i++) {\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (int i = 0; i < k; i++) {\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (int i = 0; i < k; i++) {\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (int i = 0; i < k; i++) {\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (int i = 0; i < k; i++) {\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n  if(n == 0 || n == 1 || n == 3) return 0;\n  if(n == 2) return 2;\n\n  long a = 0, b = 0, c = 2, d = 0, e;\n\n  for(long i = 4; i <= n; i++) {\n    e = a + b + c + d;\n    a = b;\n    b = c;\n    c = d;\n    d = e;\n  }\n\n  return d;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n  if (n == 0 || n == 1 || n == 3) return 0;\n  if (n == 2) return 2;\n\n  long fib[n+1];\n  fib[0] = 0;\n  fib[1] = 0;\n  fib[2] = 2;\n  fib[3] = 0;\n\n  for (long i = 4; i <= n; i++) {\n    fib[i] = fib[i-1] + fib[i-2] + fib[i-3] + fib[i-4];\n  }\n\n  return fib[n];\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n  if(n==0 || n==1 || n==3) return 0;\n  if(n==2) return 2;\n\n  long fib4_n_minus_4 = 0;\n  long fib4_n_minus_3 = 0;\n  long fib4_n_minus_2 = 2;\n  long fib4_n_minus_1 = 0;\n  long fib4_n;\n\n  for(long i=4; i<=n; i++){\n    fib4_n = fib4_n_minus_1 + fib4_n_minus_2 + fib4_n_minus_3 + fib4_n_minus_4;\n    fib4_n_minus_4 = fib4_n_minus_3;\n    fib4_n_minus_3 = fib4_n_minus_2;\n    fib4_n_minus_2 = fib4_n_minus_1;\n    fib4_n_minus_1 = fib4_n;\n  }\n\n  return fib4_n;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n  if (n == 0 || n == 1 || n == 3)\n    return 0;\n  if (n == 2)\n    return 2;\n\n  long a = 0, b = 0, c = 2, d = 0, e;\n  for (long i = 4; i <= n; i++) {\n    e = a + b + c + d;\n    a = b;\n    b = c;\n    c = d;\n    d = e;\n  }\n  return d;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n  if (n == 0 || n == 1 || n == 3) return 0;\n  if (n == 2) return 2;\n\n  long fib_n_minus_4 = 0;\n  long fib_n_minus_3 = 0;\n  long fib_n_minus_2 = 2;\n  long fib_n_minus_1 = 0;\n\n  long fib_n;\n\n  for (long i = 4; i <= n; i++) {\n    fib_n = fib_n_minus_1 + fib_n_minus_2 + fib_n_minus_3 + fib_n_minus_4;\n    fib_n_minus_4 = fib_n_minus_3;\n    fib_n_minus_3 = fib_n_minus_2;\n    fib_n_minus_2 = fib_n_minus_1;\n    fib_n_minus_1 = fib_n;\n  }\n\n  return fib_n;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n  if(n == 0 || n == 1 || n == 3) return 0;\n  if(n == 2) return 2;\n\n  long a = 0, b = 0, c = 2, d = 0, e;\n\n  for(long i = 4; i <= n; i++) {\n    e = a + b + c + d;\n    a = b;\n    b = c;\n    c = d;\n    d = e;\n  }\n  \n  return d;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n  if (n == 0 || n == 1 || n == 3) return 0;\n  if (n == 2) return 2;\n\n  long a = 0, b = 0, c = 2, d = 0;\n  for (long i = 4; i <= n; i++) {\n    long temp = a;\n    a = b;\n    b = c;\n    c = d;\n    d = temp + a + b + c;\n  }\n  return d;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n  if (n == 0 || n == 1 || n == 3) return 0;\n  if (n == 2) return 2;\n\n  long a = 0, b = 0, c = 2, d = 0;\n  for (long i = 4; i <= n; ++i) {\n    long temp = a + b + c + d;\n    a = b;\n    b = c;\n    c = d;\n    d = temp;\n  }\n  return d;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n  if (n == 0 || n == 1 || n == 3) return 0;\n  if (n == 2) return 2;\n\n  long a = 0, b = 0, c = 2, d = 0, e;\n\n  for (long i = 4; i <= n; i++) {\n    e = a + b + c + d;\n    a = b;\n    b = c;\n    c = d;\n    d = e;\n  }\n\n  return d;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n  if(n == 0 || n == 1 || n == 3) return 0;\n  if(n == 2) return 2;\n\n  long a = 0, b = 0, c = 2, d = 0;\n  for(long i = 4; i <= n; i++) {\n    long temp = a + b + c + d;\n    a = b;\n    b = c;\n    c = d;\n    d = temp;\n  }\n  return d;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (long num : x) {\n        bool hasEvenDigit = false;\n        long temp = num;\n        while (temp != 0) {\n            if ((temp % 10) % 2 == 0) {\n                hasEvenDigit = true;\n                break;\n            }\n            temp /= 10;\n        }\n        if (!hasEvenDigit) {\n            result.push_back(num);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n  std::vector<long> result;\n  for (long num : x) {\n    bool hasEvenDigit = false;\n    long temp = num;\n    while (temp > 0) {\n      if ((temp % 10) % 2 == 0) {\n        hasEvenDigit = true;\n        break;\n      }\n      temp /= 10;\n    }\n    if (!hasEvenDigit) {\n      result.push_back(num);\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n  std::vector<long> result;\n  for (auto num : x) {\n    bool hasEvenDigit = false;\n    long temp = num;\n    while (temp > 0) {\n      if ((temp % 10) % 2 == 0) {\n        hasEvenDigit = true;\n        break;\n      }\n      temp /= 10;\n    }\n    if (!hasEvenDigit) {\n      result.push_back(num);\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for(auto num : x) {\n        bool hasEvenDigit = false;\n        long temp = num;\n        while(temp > 0) {\n            if((temp % 10) % 2 == 0) {\n                hasEvenDigit = true;\n                break;\n            }\n            temp /= 10;\n        }\n        if(!hasEvenDigit) {\n            result.push_back(num);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n  std::vector<long> result;\n\n  for (auto num : x) {\n    bool hasEvenDigit = false;\n    long temp = num;\n\n    while (temp) {\n      if ((temp % 10) % 2 == 0) {\n        hasEvenDigit = true;\n        break;\n      }\n      temp /= 10;\n    }\n\n    if (!hasEvenDigit) {\n      result.push_back(num);\n    }\n  }\n\n  std::sort(result.begin(), result.end());\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n  std::vector<long> result;\n  for (auto num : x) {\n    bool hasEvenDigit = false;\n    long temp = num;\n    while (temp != 0) {\n      if ((temp % 10) % 2 == 0) {\n        hasEvenDigit = true;\n        break;\n      }\n      temp /= 10;\n    }\n    if (!hasEvenDigit) {\n      result.push_back(num);\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n  std::vector<long> result;\n  for (auto num : x) {\n    bool hasEvenDigit = false;\n    long temp = num;\n    while (temp != 0) {\n      if ((temp % 10) % 2 == 0) {\n        hasEvenDigit = true;\n        break;\n      }\n      temp /= 10;\n    }\n    if (!hasEvenDigit) {\n      result.push_back(num);\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n  std::vector<long> result;\n  for (long num : x) {\n    bool hasEvenDigit = false;\n    long temp = num;\n    while (temp > 0) {\n      if ((temp % 10) % 2 == 0) {\n        hasEvenDigit = true;\n        break;\n      }\n      temp /= 10;\n    }\n    if (!hasEvenDigit) {\n      result.push_back(num);\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\nstd::vector<long> result;\nfor (auto num : x) {\n    bool hasEvenDigit = false;\n    long temp = num;\n    while (temp > 0) {\n        if ((temp % 10) % 2 == 0) {\n            hasEvenDigit = true;\n            break;\n        }\n        temp /= 10;\n    }\n    if (!hasEvenDigit) {\n        result.push_back(num);\n    }\n}\nstd::sort(result.begin(), result.end());\nreturn result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n  std::vector<long> result;\n  for (long num : x) {\n    bool hasEvenDigit = false;\n    long temp = num;\n    while (temp > 0) {\n      if ((temp % 10) % 2 == 0) {\n        hasEvenDigit = true;\n        break;\n      }\n      temp /= 10;\n    }\n    if (!hasEvenDigit) {\n      result.push_back(num);\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::istringstream iss(s);\n  std::string word;\n  while (iss >> word) {\n    long count = 0;\n    for (char c : word) {\n      c = tolower(c);\n      if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n        continue;\n      } else {\n        count++;\n      }\n    }\n    if (count == n) {\n      result.push_back(word);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::string word;\n  std::stringstream ss(s);\n\n  while (ss >> word) {\n    int consonants = 0;\n    for (char c : word) {\n      c = tolower(c);\n      if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n        consonants++;\n      }\n    }\n    if (consonants == n) {\n      result.push_back(word);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::string word;\n  std::stringstream ss(s);\n  while (ss >> word) {\n    long consonants = 0;\n    for (char c : word) {\n      c = tolower(c);\n      if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n        consonants++;\n      }\n    }\n    if (consonants == n) {\n      result.push_back(word);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::stringstream ss(s);\n  std::string word;\n  while (ss >> word) {\n    long count = 0;\n    for (char c : word) {\n      c = std::tolower(c);\n      if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n        count++;\n      }\n    }\n    if (count == n) {\n      result.push_back(word);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::istringstream iss(s);\n  std::string word;\n  while (iss >> word) {\n    int consonantCount = 0;\n    for (char c : word) {\n      c = tolower(c);\n      if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n        consonantCount++;\n      }\n    }\n    if (consonantCount == n) {\n      result.push_back(word);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::string word;\n  std::stringstream ss(s);\n  \n  while (ss >> word) {\n    int consonants = 0;\n    for (char c : word) {\n      c = tolower(c);\n      if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n        consonants++;\n      }\n    }\n    if (consonants == n) {\n      result.push_back(word);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::istringstream iss(s);\n  std::string word;\n  while (iss >> word) {\n    int consonants = 0;\n    for (char c : word) {\n      c = tolower(c);\n      if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && c != ' ') {\n        consonants++;\n      }\n    }\n    if (consonants == n) {\n      result.push_back(word);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::stringstream ss(s);\n  std::string word;\n  while (ss >> word) {\n    long consonants = 0;\n    for (char c : word) {\n      c = std::tolower(c);\n      if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n        consonants++;\n      }\n    }\n    if (consonants == n) {\n      result.push_back(word);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::istringstream iss(s);\n  std::string word;\n  std::string vowels = \"aeiouAEIOU\";\n\n  while (iss >> word) {\n    long consonant_count = 0;\n    for (char c : word) {\n      if (vowels.find(c) == std::string::npos) {\n        consonant_count++;\n      }\n    }\n    if (consonant_count == n) {\n      result.push_back(word);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::stringstream ss(s);\n  std::string word;\n  std::string vowels = \"aeiouAEIOU\";\n\n  while (ss >> word) {\n    long consonants = 0;\n    for (char c : word) {\n      if (vowels.find(c) == std::string::npos) {\n        consonants++;\n      }\n    }\n    if (consonants == n) {\n      result.push_back(word);\n    }\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n  long sum = 0;\n  for (int i = 0; i < q.size(); i++) {\n    sum += q[i];\n  }\n  if (sum > w) {\n    return false;\n  }\n  \n  for (int i = 0; i < q.size() / 2; i++) {\n    if (q[i] != q[q.size() - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n  long sum = 0;\n  for (int i = 0; i < q.size(); i++) {\n    sum += q[i];\n  }\n  if (sum > w) {\n    return false;\n  }\n\n  for (int i = 0; i < q.size() / 2; i++) {\n    if (q[i] != q[q.size() - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n  long sum = 0;\n  for (int i = 0; i < q.size(); i++) {\n    sum += q[i];\n  }\n\n  if (sum > w) {\n    return false;\n  }\n\n  for (int i = 0; i < q.size() / 2; i++) {\n    if (q[i] != q[q.size() - 1 - i]) {\n      return false;\n    }\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n  long sum = 0;\n  for (int i = 0; i < q.size(); i++) {\n    sum += q[i];\n  }\n  \n  if (sum > w) {\n    return false;\n  }\n  \n  for (int i = 0; i < q.size() / 2; i++) {\n    if (q[i] != q[q.size() - i - 1]) {\n      return false;\n    }\n  }\n  \n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n  long sum = 0;\n  for(int i = 0; i < q.size(); i++) {\n    sum += q[i];\n  }\n  if(sum > w) {\n    return false;\n  }\n  for(int i = 0; i < q.size()/2; i++) {\n    if(q[i] != q[q.size()-i-1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n  long sum = 0;\n  for (int i = 0; i < q.size(); i++) {\n    sum += q[i];\n  }\n  if (sum > w) {\n    return false;\n  }\n\n  for (int i = 0; i < q.size() / 2; i++) {\n    if (q[i] != q[q.size() - i - 1]) {\n      return false;\n    }\n  }\n  \n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n  long sum = 0;\n  for (auto &num : q) {\n    sum += num;\n  }\n  if (sum > w) {\n    return false;\n  }\n  \n  int i = 0, j = q.size() - 1;\n  while (i < j) {\n    if (q[i] != q[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n  long sum = 0;\n  for (int i = 0; i < q.size(); i++) {\n    sum += q[i];\n  }\n  if (sum > w) {\n    return false;\n  }\n\n  for (int i = 0; i < q.size() / 2; i++) {\n    if (q[i] != q[q.size() - 1 - i]) {\n      return false;\n    }\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n  long sum = 0;\n  for (int i = 0; i < q.size(); i++) {\n    sum += q[i];\n  }\n  if (sum > w) {\n    return false;\n  }\n  for (int i = 0; i < q.size() / 2; i++) {\n    if (q[i] != q[q.size() - 1 - i]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n  long sum = 0;\n  for (int i = 0; i < q.size(); i++) {\n    sum += q[i];\n  }\n  if (sum > w) {\n    return false;\n  }\n  \n  for (int i = 0, j = q.size() - 1; i < j; i++, j--) {\n    if (q[i] != q[j]) {\n      return false;\n    }\n  }\n  return true;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n  long a = 0, b = 1, c;\n  if (n == 0)\n    return a;\n  for (long i = 2; i <= n; i++) {\n    c = a + b;\n    a = b;\n    b = c;\n  }\n  return b;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n  long a = 0, b = 1, c;\n  if(n == 0)\n    return a;\n  for(long i = 2; i <= n; i++){\n    c = a + b;\n    a = b;\n    b = c;\n  }\n  return b;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n  long a = 0, b = 1, c, i;\n  if(n == 0)\n    return a;\n  for(i = 2; i <= n; i++)\n  {\n     c = a + b;\n     a = b;\n     b = c;\n  }\n  return b;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n  long a = 0, b = 1, c;\n  if(n == 0)\n    return a;\n  for(long i = 2; i <= n; i++){\n     c = a + b;\n     a = b;\n     b = c;\n  }\n  return b;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n  long a = 0;\n  long b = 1;\n  for (int i = 2; i <= n; i++) {\n    long c = a + b;\n    a = b;\n    b = c;\n  }\n  return b;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n  long a = 0;\n  long b = 1;\n  for (int i = 2; i <= n; i++) {\n    long c = a + b;\n    a = b;\n    b = c;\n  }\n  return b;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n  long a = 0, b = 1, c;\n  if (n == 0)\n    return a;\n  for (long i = 2; i <= n; i++) {\n    c = a + b;\n    a = b;\n    b = c;\n  }\n  return b;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n  long a = 0, b = 1, c;\n  if(n == 0)\n    return a;\n  for(long i = 2; i <= n; i++){\n     c = a + b;\n     a = b;\n     b = c;\n  }\n  return b;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n  long a = 0, b = 1, c;\n  if(n == 0)\n    return a;\n  for(long i = 2; i <= n; i++){\n     c = a + b;\n     a = b;\n     b = c;\n  }\n  return b;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n  long a = 0, b = 1, c;\n  if(n == 0)\n    return a;\n  for(long i = 2; i <= n; i++) {\n     c = a + b;\n     a = b;\n     b = c;\n  }\n  return b;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n  std::string strongest_extension = \"\";\n  int max_strength = INT_MIN;\n\n  for (const auto& extension : extensions) {\n    int cap = 0, sm = 0;\n    for (const auto& ch : extension) {\n      if (isupper(ch)) {\n        cap++;\n      } else if (islower(ch)) {\n        sm++;\n      }\n    }\n\n    int strength = cap - sm;\n    if (strength > max_strength) {\n      max_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n\n  return class_name + \".\" + strongest_extension;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n  std::string strongest_extension = \"\";\n  int max_strength = INT_MIN;\n\n  for(auto &extension : extensions) {\n    int strength = 0;\n    for(auto &ch : extension) {\n      if(isupper(ch)) strength++;\n      else if(islower(ch)) strength--;\n    }\n\n    if(strength > max_strength) {\n      max_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n\n  return class_name + \".\" + strongest_extension;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n  int max_strength = INT_MIN;\n  std::string strongest_extension;\n  \n  for (const auto& extension : extensions) {\n    int cap = 0, sm = 0;\n    for (const auto& ch : extension) {\n      if (isupper(ch)) cap++;\n      else if (islower(ch)) sm++;\n    }\n    int strength = cap - sm;\n    if (strength > max_strength) {\n      max_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n  \n  return class_name + \".\" + strongest_extension;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n  std::string strongest_extension = \"\";\n  int max_strength = INT_MIN;\n\n  for (const auto& extension : extensions) {\n    int strength = 0;\n    for (const auto& ch : extension) {\n      if (std::isupper(ch)) {\n        strength++;\n      } else if (std::islower(ch)) {\n        strength--;\n      }\n    }\n\n    if (strength > max_strength) {\n      max_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n\n  return class_name + \".\" + strongest_extension;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n  int max_strength = INT_MIN;\n  std::string strongest_extension;\n  for (const auto& extension : extensions) {\n    int CAP = 0, SM = 0;\n    for (char c : extension) {\n      if (isupper(c)) CAP++;\n      else if (islower(c)) SM++;\n    }\n    int strength = CAP - SM;\n    if (strength > max_strength) {\n      max_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n  return class_name + \".\" + strongest_extension;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n  int max_strength = INT_MIN;\n  std::string strongest_extension = \"\";\n\n  for (const auto& extension : extensions) {\n    int cap = 0, sm = 0;\n    for (const auto& ch : extension) {\n      if (isupper(ch)) cap++;\n      else if (islower(ch)) sm++;\n    }\n    int strength = cap - sm;\n    if (strength > max_strength) {\n      max_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n\n  return class_name + \".\" + strongest_extension;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n  std::string strongest_extension = \"\";\n  int max_strength = INT_MIN;\n\n  for (const auto& extension : extensions) {\n    int cap = 0;\n    int sm = 0;\n    for (const auto& ch : extension) {\n      if (std::isupper(ch)) {\n        cap++;\n      } else if (std::islower(ch)) {\n        sm++;\n      }\n    }\n    int strength = cap - sm;\n    if (strength > max_strength) {\n      max_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n\n  return class_name + \".\" + strongest_extension;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n  int max_strength = INT_MIN;\n  std::string strongest_extension;\n  for (const auto& extension : extensions) {\n    int CAP = 0, SM = 0;\n    for (const auto& ch : extension) {\n      if (isupper(ch)) CAP++;\n      else if (islower(ch)) SM++;\n    }\n    int strength = CAP - SM;\n    if (strength > max_strength) {\n      max_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n  return class_name + \".\" + strongest_extension;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n  int max_strength = INT_MIN;\n  std::string strongest_extension = \"\";\n  \n  for (auto &extension : extensions) {\n    int cap = 0, sm = 0;\n    for (auto &ch : extension) {\n      if (isupper(ch)) cap++;\n      else if (islower(ch)) sm++;\n    }\n    \n    int strength = cap - sm;\n    if (strength > max_strength) {\n      max_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n  \n  return class_name + \".\" + strongest_extension;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n  std::string strongest_extension = \"\";\n  int max_strength = INT_MIN;\n  for (const auto& extension : extensions) {\n    int cap = 0, sm = 0;\n    for (const auto& ch : extension) {\n      if (isupper(ch)) cap++;\n      else if (islower(ch)) sm++;\n    }\n    int strength = cap - sm;\n    if (strength > max_strength) {\n      max_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n  return class_name + \".\" + strongest_extension;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string first = lst[0], second = lst[1];\n  int balance = 0;\n\n  for (char c : first) {\n    if (c == '(') {\n      balance++;\n    } else {\n      if (balance == 0) {\n        return \"No\";\n      }\n      balance--;\n    }\n  }\n\n  for (char c : second) {\n    if (c == '(') {\n      balance++;\n    } else {\n      if (balance == 0) {\n        return \"No\";\n      }\n      balance--;\n    }\n  }\n\n  return balance == 0 ? \"Yes\" : \"No\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  int open = 0, close = 0;\n  for (auto &s : lst) {\n    for (char c : s) {\n      if (c == '(') open++;\n      else close++;\n    }\n  }\n  if (open != close) return \"No\";\n  open = 0;\n  for (auto &s : lst) {\n    for (char c : s) {\n      if (c == '(') open++;\n      else open--;\n      if (open < 0) return \"No\";\n    }\n  }\n  return \"Yes\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  int balance = 0;\n  for (auto &s : lst) {\n    for (auto &c : s) {\n      if (c == '(') {\n        balance++;\n      } else if (c == ')') {\n        if (balance == 0) {\n          return \"No\";\n        }\n        balance--;\n      }\n    }\n  }\n  return balance == 0 ? \"Yes\" : \"No\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  int balance = 0;\n  for (auto &s : lst) {\n    for (char c : s) {\n      balance += (c == '(' ? 1 : -1);\n      if (balance < 0) {\n        return \"No\";\n      }\n    }\n  }\n  return balance == 0 ? \"Yes\" : \"No\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string first = lst[0], second = lst[1];\n  int balance = 0;\n\n  for (char c : first) {\n    if (c == '(') {\n      balance++;\n    } else {\n      if (balance == 0) {\n        return \"No\";\n      }\n      balance--;\n    }\n  }\n\n  for (char c : second) {\n    if (c == '(') {\n      balance++;\n    } else {\n      if (balance == 0) {\n        return \"No\";\n      }\n      balance--;\n    }\n  }\n\n  return balance == 0 ? \"Yes\" : \"No\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  int balance = 0;\n  for (auto &s : lst) {\n    for (auto &c : s) {\n      if (c == '(') {\n        ++balance;\n      } else if (c == ')') {\n        --balance;\n      }\n      if (balance < 0) {\n        return \"No\";\n      }\n    }\n  }\n  return balance == 0 ? \"Yes\" : \"No\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  int balance = 0;\n  for (const auto& str : lst) {\n    for (const auto& ch : str) {\n      balance += (ch == '(') ? 1 : -1;\n      if (balance < 0) {\n        return \"No\";\n      }\n    }\n  }\n  return (balance == 0) ? \"Yes\" : \"No\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string str1 = lst[0];\n  std::string str2 = lst[1];\n\n  int balance1 = 0;\n  int balance2 = 0;\n  \n  for (char c : str1) {\n    if (c == '(') {\n      balance1++;\n    } else {\n      if (balance1 == 0) {\n        return \"No\";\n      }\n      balance1--;\n    }\n  }\n\n  for (char c : str2) {\n    if (c == '(') {\n      balance2++;\n    } else {\n      if (balance2 == 0) {\n        return \"No\";\n      }\n      balance2--;\n    }\n  }\n\n  return (balance1 == balance2) ? \"Yes\" : \"No\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string str1 = lst[0];\n  std::string str2 = lst[1];\n  int balance1 = 0, balance2 = 0;\n  \n  for (char c : str1) {\n    if (c == '(') {\n      balance1++;\n    } else {\n      if (balance1 == 0) return \"No\";\n      balance1--;\n    }\n  }\n  \n  for (char c : str2) {\n    if (c == '(') {\n      balance2++;\n    } else {\n      if (balance2 == 0) return \"No\";\n      balance2--;\n    }\n  }\n  \n  if (balance1 == balance2) return \"Yes\";\n  return \"No\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  int balance = 0;\n  for (const auto& str : lst) {\n    for (const char& ch : str) {\n      balance += (ch == '(' ? 1 : -1);\n      if (balance < 0) {\n        return \"No\";\n      }\n    }\n  }\n  return (balance == 0 ? \"Yes\" : \"No\");\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  \n  std::sort(lst.begin(), lst.end());\n  \n  for (int i = 1; i < lst.size(); i++) {\n    if (lst[i] > lst[0]) {\n      return lst[i];\n    }\n  }\n  \n  return std::nullopt;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n\n  std::sort(lst.begin(), lst.end());\n  \n  for (int i = 1; i < lst.size(); i++) {\n    if (lst[i] != lst[0]) {\n      return lst[i];\n    }\n  }\n  \n  return std::nullopt;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  std::sort(lst.begin(), lst.end());\n  for (int i = 1; i < lst.size(); i++) {\n    if (lst[i] > lst[0]) {\n      return lst[i];\n    }\n  }\n  return std::nullopt;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if(lst.size() < 2) return std::nullopt;\n  std::sort(lst.begin(), lst.end());\n  long smallest = lst[0];\n  for(int i = 1; i < lst.size(); i++) {\n    if(lst[i] > smallest) return lst[i];\n  }\n  return std::nullopt;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  \n  std::sort(lst.begin(), lst.end());\n  \n  for (int i = 1; i < lst.size(); i++) {\n    if (lst[i] != lst[0]) {\n      return lst[i];\n    }\n  }\n  \n  return std::nullopt;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  std::sort(lst.begin(), lst.end());\n  for (int i = 1; i < lst.size(); i++) {\n    if (lst[i] > lst[0]) {\n      return lst[i];\n    }\n  }\n  return std::nullopt;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  std::sort(lst.begin(), lst.end());\n  for (int i = 1; i < lst.size(); i++) {\n    if (lst[i] > lst[0]) {\n      return lst[i];\n    }\n  }\n  return std::nullopt;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n\n  std::sort(lst.begin(), lst.end());\n\n  for (int i = 1; i < lst.size(); i++) {\n    if (lst[i] > lst[0]) {\n      return lst[i];\n    }\n  }\n\n  return std::nullopt;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  std::sort(lst.begin(), lst.end());\n  for (int i = 1; i < lst.size(); i++) {\n    if (lst[i] > lst[0]) {\n      return lst[i];\n    }\n  }\n  return std::nullopt;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  \n  std::sort(lst.begin(), lst.end());\n\n  for (int i = 1; i < lst.size(); i++) {\n    if (lst[i] > lst[0]) {\n      return lst[i];\n    }\n  }\n\n  return std::nullopt;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n  if (floor(x) == x && floor(y) == y && floor(z) == z) {\n    int a = (int)x, b = (int)y, c = (int)z;\n    if (a + b == c || a + c == b || b + c == a) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n  if (floor(x) == x && floor(y) == y && floor(z) == z) {\n    if ((x + y == z) || (x + z == y) || (y + z == x)) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n  if (floor(x) == x && floor(y) == y && floor(z) == z) {\n    int ix = (int)x;\n    int iy = (int)y;\n    int iz = (int)z;\n    return (ix + iy == iz) || (ix + iz == iy) || (iy + iz == ix);\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n  if (floor(x) == x && floor(y) == y && floor(z) == z) {\n    if ((x + y == z) || (x + z == y) || (y + z == x)) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n  if (floor(x) == x && floor(y) == y && floor(z) == z) {\n    if (x == y + z || y == x + z || z == x + y) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n  if (floor(x) == x && floor(y) == y && floor(z) == z) {\n    if ((x == y + z) || (y == x + z) || (z == x + y)) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n  if (floor(x) == x && floor(y) == y && floor(z) == z) {\n    int a = (int)x;\n    int b = (int)y;\n    int c = (int)z;\n\n    return (a + b == c) || (a + c == b) || (b + c == a);\n  } else {\n    return false;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n  if (floor(x) == x && floor(y) == y && floor(z) == z) {\n    int a = (int)x;\n    int b = (int)y;\n    int c = (int)z;\n    return (a + b == c) || (a + c == b) || (b + c == a);\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n  if (floor(x) == x && floor(y) == y && floor(z) == z) {\n    if (x == y + z || y == x + z || z == x + y) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n  if (floor(x) == x && floor(y) == y && floor(z) == z) {\n    if ((x + y == z) || (x + z == y) || (y + z == x)) {\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n  int intPart = (int)number;\n  float decimalPart = number - intPart;\n  return decimalPart;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n  int intPart = (int)number;\n  float decimalPart = number - intPart;\n  return decimalPart;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n  int intPart = (int)number;\n  float decimalPart = number - intPart;\n  return decimalPart;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n  int intPart = (int)number;\n  float decimalPart = number - intPart;\n  return decimalPart;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n  int intPart = (int)number;\n  float decimalPart = number - intPart;\n  return decimalPart;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n  int intPart = (int)number;\n  float decimalPart = number - intPart;\n  return decimalPart;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n  int intPart = (int)number;\n  float decimalPart = number - intPart;\n  return decimalPart;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n  int intPart = (int)number;\n  float decimalPart = number - intPart;\n  return decimalPart;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n  int intPart = (int) number;\n  float decimalPart = number - intPart;\n  return decimalPart;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n  int intPart = (int)number;\n  float decimalPart = number - intPart;\n  return decimalPart;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n  for (int i = 0; i < l.size(); i++) {\n    l[i] += 1;\n  }\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n  for (int i = 0; i < l.size(); i++) {\n    l[i] += 1;\n  }\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n  for (int i = 0; i < l.size(); i++) {\n    l[i] += 1;\n  }\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n  for (int i = 0; i < l.size(); i++) {\n    l[i]++;\n  }\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n  for (int i = 0; i < l.size(); i++) {\n    l[i]++;\n  }\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n  for (int i = 0; i < l.size(); i++) {\n    l[i]++;\n  }\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n  for (int i = 0; i < l.size(); i++) {\n    l[i]++;\n  }\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n  for (int i = 0; i < l.size(); i++) {\n    l[i]++;\n  }\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n  for (int i = 0; i < l.size(); i++) {\n    l[i] += 1;\n  }\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n  for (int i = 0; i < l.size(); i++) {\n    l[i] += 1;\n  }\n  return l;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n  bool isPrime = true;\n\n  if (n <= 1) {\n    isPrime = false;\n  } else {\n    for (int i = 2; i <= sqrt(n); i++) {\n      if (n % i == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n  }\n\n  if (isPrime) {\n    return x;\n  } else {\n    return y;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n  bool isPrime = true;\n  if (n <= 1)\n    isPrime = false;\n  else {\n    for (long i = 2; i <= sqrt(n); i++) {\n      if (n % i == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n  }\n  return isPrime ? x : y;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n  bool prime = true;\n  if(n < 2) prime = false;\n  for(int i = 2; i <= sqrt(n); i++) {\n    if(n % i == 0) {\n      prime = false;\n      break;\n    }\n  }\n  if(prime) return x;\n  else return y;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n  bool isPrime = true;\n  if (n <= 1) {\n    isPrime = false;\n  }\n  else {\n    for (long i = 2; i <= sqrt(n); i++) {\n      if (n % i == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n  }\n  if (isPrime) {\n    return x;\n  }\n  else {\n    return y;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n  bool prime = true;\n  if (n <= 1) {\n    prime = false;\n  } else {\n    for (int i = 2; i <= sqrt(n); i++) {\n      if (n % i == 0) {\n        prime = false;\n        break;\n      }\n    }\n  }\n  return (prime ? x : y);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n  bool prime = true;\n  if (n < 2) {\n    prime = false;\n  } else {\n    for (int i = 2; i <= sqrt(n); i++) {\n      if (n % i == 0) {\n        prime = false;\n        break;\n      }\n    }\n  }\n  return prime ? x : y;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n  bool isPrime = true;\n\n  if (n <= 1) {\n    isPrime = false;\n  }\n  else {\n    for (long i = 2; i <= sqrt(n); i++) {\n      if (n % i == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n  }\n\n  if (isPrime) {\n    return x;\n  } else {\n    return y;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n  bool isPrime = true;\n  if (n <= 1) {\n    isPrime = false;\n  } else {\n    for (long i = 2; i * i <= n; i++) {\n      if (n % i == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n  }\n  if (isPrime) {\n    return x;\n  } else {\n    return y;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n  bool isPrime = true;\n  if (n <= 1) {\n    isPrime = false;\n  } else {\n    for (long i = 2; i <= sqrt(n); i++) {\n      if (n % i == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n  }\n  return isPrime ? x : y;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n  bool isPrime = true;\n  if (n <= 1) {\n    isPrime = false;\n  } else {\n    for (long i = 2; i <= sqrt(n); i++) {\n      if (n % i == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n  }\n  return isPrime ? x : y;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n  long result = 1;\n  long square = 2;\n  while (n > 0) {\n    if (n % 2 == 1) {\n      result = (result * square) % p;\n    }\n    square = (square * square) % p;\n    n /= 2;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n  long result = 1;\n  for(int i = 0; i < n; i++) {\n    result = (result * 2) % p;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n  long result = 1;\n  for(int i = 0; i < n; i++) {\n    result = (result * 2) % p;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n  long res = 1;\n  long base = 2;\n\n  while (n > 0) {\n    if (n & 1) {\n      res = (res * base) % p;\n    }\n    base = (base * base) % p;\n    n = n >> 1;\n  }\n\n  return res % p;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n  long result = 1;\n  for(int i = 0; i < n; i++) {\n    result = (result * 2) % p;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n  long result = 1;\n  long base = 2;\n\n  while (n > 0) {\n    if (n & 1) {\n      result = (result * base) % p;\n    }\n    base = (base * base) % p;\n    n = n >> 1;\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n  long res = 1;\n  long base = 2;\n  while (n > 0) {\n    if (n & 1)\n      res = (res * base) % p;\n    base = (base * base) % p;\n    n >>= 1;\n  }\n  return res;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n  long result = 1;\n  for (int i = 0; i < n; i++) {\n    result = (result * 2) % p;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n  long result = 1;\n  for(int i = 0; i < n; i++) {\n    result = (result * 2) % p;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n  long result = 1;\n  for(int i = 0; i < n; i++) {\n    result = (result * 2) % p;\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n  long even_count = 0;\n  long odd_count = 0;\n  \n  num = abs(num); // Make the number positive to handle negative numbers\n  \n  while(num > 0) {\n    long digit = num % 10;\n    if(digit % 2 == 0) {\n      even_count++;\n    } else {\n      odd_count++;\n    }\n    num /= 10;\n  }\n  \n  return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n  long even_count = 0;\n  long odd_count = 0;\n\n  num = abs(num);\n\n  while (num > 0) {\n    long digit = num % 10;\n    if (digit % 2 == 0) {\n      even_count++;\n    } else {\n      odd_count++;\n    }\n    num /= 10;\n  }\n\n  return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n  long even_count = 0;\n  long odd_count = 0;\n  \n  num = abs(num); // Make sure the number is positive\n  \n  while (num > 0) {\n    long digit = num % 10;\n    if (digit % 2 == 0) {\n      even_count++;\n    } else {\n      odd_count++;\n    }\n    num /= 10;\n  }\n  \n  return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n  long even_count = 0, odd_count = 0;\n  num = std::abs(num);\n  while (num > 0) {\n    long digit = num % 10;\n    if (digit % 2 == 0) {\n      even_count++;\n    } else {\n      odd_count++;\n    }\n    num /= 10;\n  }\n  return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n  long even_count = 0, odd_count = 0;\n  num = abs(num);\n  while (num > 0) {\n    long digit = num % 10;\n    if (digit % 2 == 0) {\n      even_count++;\n    } else {\n      odd_count++;\n    }\n    num /= 10;\n  }\n  return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n  long even_count = 0;\n  long odd_count = 0;\n\n  num = abs(num);\n\n  while (num > 0) {\n    long digit = num % 10;\n    if (digit % 2 == 0) {\n      even_count++;\n    } else {\n      odd_count++;\n    }\n    num /= 10;\n  }\n\n  return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n  long even_count = 0;\n  long odd_count = 0;\n  num = abs(num);\n\n  while (num > 0) {\n    long digit = num % 10;\n    if (digit % 2 == 0) {\n      even_count++;\n    } else {\n      odd_count++;\n    }\n    num /= 10;\n  }\n\n  return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n  long even_count = 0, odd_count = 0;\n  num = abs(num);\n  while (num > 0) {\n    long digit = num % 10;\n    if (digit % 2 == 0) {\n      even_count++;\n    } else {\n      odd_count++;\n    }\n    num /= 10;\n  }\n  return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n  long even_count = 0;\n  long odd_count = 0;\n  num = abs(num);\n  \n  while (num > 0) {\n    long digit = num % 10;\n    if (digit % 2 == 0) {\n      even_count++;\n    } else {\n      odd_count++;\n    }\n    num /= 10;\n  }\n  \n  return std::make_tuple(even_count, odd_count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n  long even_count = 0, odd_count = 0;\n  num = abs(num);\n  while (num != 0) {\n    long digit = num % 10;\n    if (digit % 2 == 0)\n      even_count++;\n    else\n      odd_count++;\n    num = num / 10;\n  }\n  return std::make_tuple(even_count, odd_count);\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n  if (s.length() < 3)\n    return false;\n  for (int i = 0; i < s.length() - 2; i++) {\n    if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2])\n      return false;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (int i = 0; i < s.length() - 2; i++) {\n    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (int i = 0; i < s.length() - 2; i++) {\n    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (int i = 0; i < s.length() - 2; i++) {\n    if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (int i = 0; i < s.length() - 2; i++) {\n    if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (int i = 2; i < s.length(); i++) {\n    if (s[i] == s[i-1] || s[i] == s[i-2] || s[i-1] == s[i-2]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (int i = 0; i < s.length() - 2; i++) {\n    if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (int i = 0; i < s.length() - 2; i++) {\n    if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (int i = 0; i < s.length() - 2; i++) {\n    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  \n  for (int i = 0; i < s.length() - 2; i++) {\n    if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n      return false;\n    }\n  }\n  \n  return true;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    long maxPrime = -1;\n\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n >>= 1;\n    }\n\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            maxPrime = i;\n            n = n / i;\n        }\n    }\n\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n  long max_prime = -1;\n\n  while (n % 2 == 0) {\n    max_prime = 2;\n    n >>= 1;\n  }\n\n  for (int i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n      max_prime = i;\n      n = n / i;\n    }\n  }\n\n  if (n > 2)\n    max_prime = n;\n\n  return max_prime;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n  long maxPrime = -1;\n\n  while (n % 2 == 0) {\n    maxPrime = 2;\n    n >>= 1;\n  }\n\n  for (int i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n      maxPrime = i;\n      n = n / i;\n    }\n  }\n\n  if (n > 2)\n    maxPrime = n;\n\n  return maxPrime;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n  long maxPrime = -1;\n\n  while (n % 2 == 0) {\n    maxPrime = 2;\n    n >>= 1;\n  }\n\n  for (int i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n      maxPrime = i;\n      n = n / i;\n    }\n  }\n\n  if (n > 2)\n    maxPrime = n;\n\n  return maxPrime;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n  long maxPrime = -1;\n\n  while (n % 2 == 0) {\n    maxPrime = 2;\n    n >>= 1;\n  }\n\n  for (int i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n      maxPrime = i;\n      n = n / i;\n    }\n  }\n\n  if (n > 2)\n    maxPrime = n;\n\n  return maxPrime;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n  long max_prime = -1;\n\n  while (n % 2 == 0) {\n    max_prime = 2;\n    n >>= 1;\n  }\n\n  for (int i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n      max_prime = i;\n      n = n / i;\n    }\n  }\n\n  if (n > 2)\n    max_prime = n;\n\n  return max_prime;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n  long maxPrime = -1;\n\n  while (n % 2 == 0) {\n    maxPrime = 2;\n    n >>= 1;\n  }\n\n  for (int i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n      maxPrime = i;\n      n = n / i;\n    }\n  }\n\n  if (n > 2)\n    maxPrime = n;\n\n  return maxPrime;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n  long maxPrime = -1;\n  \n  while (n % 2 == 0) {\n    maxPrime = 2;\n    n >>= 1;\n  }\n\n  for (int i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n      maxPrime = i;\n      n = n / i;\n    }\n  }\n\n  if (n > 2)\n    maxPrime = n;\n\n  return maxPrime;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n  long max_prime = -1;\n\n  while (n % 2 == 0) {\n    max_prime = 2;\n    n >>= 1;\n  }\n\n  for (int i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n      max_prime = i;\n      n = n / i;\n    }\n  }\n\n  if (n > 2)\n    max_prime = n;\n\n  return max_prime;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n  long maxPrime = -1;\n\n  while (n % 2 == 0) {\n    maxPrime = 2;\n    n >>= 1;\n  }\n\n  for (int i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n      maxPrime = i;\n      n = n / i;\n    }\n  }\n\n  if (n > 2)\n    maxPrime = n;\n\n  return maxPrime;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += c;\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += (int)c;\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += c;\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += (long)c;\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += (int)c;\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += c;\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += (long)c;\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += (long)c;\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += (long)c;\n    }\n  }\n  return sum;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min_num = *std::min_element(numbers.begin(), numbers.end());\n  float max_num = *std::max_element(numbers.begin(), numbers.end());\n\n  for (int i = 0; i < numbers.size(); i++) {\n    numbers[i] = (numbers[i] - min_num) / (max_num - min_num);\n  }\n\n  return numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min = *min_element(numbers.begin(), numbers.end());\n  float max = *max_element(numbers.begin(), numbers.end());\n  \n  for (int i = 0; i < numbers.size(); i++) {\n    numbers[i] = (numbers[i] - min) / (max - min);\n  }\n  \n  return numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min_num = *min_element(numbers.begin(), numbers.end());\n  float max_num = *max_element(numbers.begin(), numbers.end());\n\n  for (int i = 0; i < numbers.size(); i++) {\n    numbers[i] = (numbers[i] - min_num) / (max_num - min_num);\n  }\n\n  return numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min_val = *min_element(numbers.begin(), numbers.end());\n  float max_val = *max_element(numbers.begin(), numbers.end());\n\n  for (int i = 0; i < numbers.size(); i++) {\n    numbers[i] = (numbers[i] - min_val) / (max_val - min_val);\n  }\n\n  return numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min_val = *min_element(numbers.begin(), numbers.end());\n  float max_val = *max_element(numbers.begin(), numbers.end());\n\n  for (int i = 0; i < numbers.size(); i++) {\n    numbers[i] = (numbers[i] - min_val) / (max_val - min_val);\n  }\n\n  return numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min = *min_element(numbers.begin(), numbers.end());\n  float max = *max_element(numbers.begin(), numbers.end());\n\n  for (int i = 0; i < numbers.size(); i++) {\n    numbers[i] = (numbers[i] - min) / (max - min);\n  }\n\n  return numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min = *min_element(numbers.begin(), numbers.end());\n  float max = *max_element(numbers.begin(), numbers.end());\n\n  for (int i = 0; i < numbers.size(); i++) {\n    numbers[i] = (numbers[i] - min) / (max - min);\n  }\n\n  return numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min = *std::min_element(numbers.begin(), numbers.end());\n  float max = *std::max_element(numbers.begin(), numbers.end());\n\n  for (int i = 0; i < numbers.size(); i++) {\n    numbers[i] = (numbers[i] - min) / (max - min);\n  }\n\n  return numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min = *min_element(numbers.begin(), numbers.end());\n  float max = *max_element(numbers.begin(), numbers.end());\n\n  for (int i = 0; i < numbers.size(); i++) {\n    numbers[i] = (numbers[i] - min) / (max - min);\n  }\n\n  return numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min_num = *min_element(numbers.begin(), numbers.end());\n  float max_num = *max_element(numbers.begin(), numbers.end());\n  \n  for (int i = 0; i < numbers.size(); i++) {\n    numbers[i] = (numbers[i] - min_num) / (max_num - min_num);\n  }\n  \n  return numbers;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n  std::vector<long> result;\n  long smallest = LONG_MAX;\n  int index = -1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i] < smallest) {\n      smallest = arr[i];\n      index = i;\n    }\n  }\n  if (index != -1) {\n    result.push_back(smallest);\n    result.push_back(index);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n  std::vector<long> result;\n  long min = LONG_MAX;\n  int index = -1;\n  \n  for(int i = 0; i < arr.size(); i++) {\n    if(arr[i] % 2 == 0 && arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  \n  if(index != -1) {\n    result.push_back(min);\n    result.push_back(index);\n  }\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n  std::vector<long> result;\n  long min_val = LONG_MAX;\n  int min_index = -1;\n  \n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i] < min_val) {\n      min_val = arr[i];\n      min_index = i;\n    }\n  }\n  \n  if (min_index != -1) {\n    result.push_back(min_val);\n    result.push_back(min_index);\n  }\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n  std::vector<long> result;\n  long min_val = LONG_MAX;\n  int min_index = -1;\n\n  for(int i = 0; i < arr.size(); i++) {\n    if(arr[i] % 2 == 0 && arr[i] < min_val) {\n      min_val = arr[i];\n      min_index = i;\n    }\n  }\n\n  if(min_index != -1) {\n    result.push_back(min_val);\n    result.push_back(min_index);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n  std::vector<long> result;\n  long smallestEven = LONG_MAX;\n  int index = -1;\n\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i] < smallestEven) {\n      smallestEven = arr[i];\n      index = i;\n    }\n  }\n\n  if (index != -1) {\n    result.push_back(smallestEven);\n    result.push_back(index);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n  std::vector<long> result;\n  long min_val = LONG_MAX;\n  int min_idx = -1;\n\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i] < min_val) {\n      min_val = arr[i];\n      min_idx = i;\n    }\n  }\n\n  if (min_idx != -1) {\n    result.push_back(min_val);\n    result.push_back(min_idx);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n  std::vector<long> result;\n  long minEven = LONG_MAX;\n  int minIndex = -1;\n\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i] < minEven) {\n      minEven = arr[i];\n      minIndex = i;\n    }\n  }\n\n  if (minIndex != -1) {\n    result.push_back(minEven);\n    result.push_back(minIndex);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n  std::vector<long> result;\n  long min = LONG_MAX;\n  int index = -1;\n\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n\n  if (index != -1) {\n    result.push_back(min);\n    result.push_back(index);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n  std::vector<long> result;\n  long min_value = LONG_MAX;\n  int min_index = -1;\n\n  for(int i = 0; i < arr.size(); i++){\n    if(arr[i] % 2 == 0 && arr[i] < min_value){\n      min_value = arr[i];\n      min_index = i;\n    }\n  }\n\n  if(min_index != -1){\n    result.push_back(min_value);\n    result.push_back(min_index);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n  std::vector<long> result;\n  long min = LONG_MAX;\n  int index = -1;\n\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0 && arr[i] < min) {\n      min = arr[i];\n      index = i;\n    }\n  }\n\n  if (index != -1) {\n    result.push_back(min);\n    result.push_back(index);\n  }\n\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n  std::vector<long> a(n);\n  for (long i = 0; i < n; i++) {\n    a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n  }\n  \n  long count = 0;\n  for (long i = 0; i < n; i++) {\n    for (long j = i + 1; j < n; j++) {\n      for (long k = j + 1; k < n; k++) {\n        if ((a[i] + a[j] + a[k]) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n  \n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n  std::vector<long> a(n);\n  for (long i = 0; i < n; i++) {\n    a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n  }\n\n  long count = 0;\n  for (long i = 0; i < n; i++) {\n    for (long j = i + 1; j < n; j++) {\n      for (long k = j + 1; k < n; k++) {\n        if ((a[i] + a[j] + a[k]) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n  std::vector<long> a(n);\n  for (long i = 0; i < n; i++) {\n    a[i] = i * i - i + 1;\n  }\n\n  long count = 0;\n  for (long i = 0; i < n; i++) {\n    for (long j = i + 1; j < n; j++) {\n      for (long k = j + 1; k < n; k++) {\n        if ((a[i] + a[j] + a[k]) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n  std::vector<long> a(n);\n  for (long i = 0; i < n; i++) {\n    a[i] = i * i - i + 1;\n  }\n\n  long count = 0;\n  for (long i = 0; i < n; i++) {\n    for (long j = i + 1; j < n; j++) {\n      for (long k = j + 1; k < n; k++) {\n        if ((a[i] + a[j] + a[k]) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n  std::vector<long> a(n);\n  for (long i = 1; i <= n; i++) {\n    a[i-1] = i * i - i + 1;\n  }\n\n  long count = 0;\n  for (long i = 0; i < n; i++) {\n    for (long j = i + 1; j < n; j++) {\n      for (long k = j + 1; k < n; k++) {\n        if ((a[i] + a[j] + a[k]) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n  std::vector<long> a(n);\n  for (long i = 1; i <= n; i++) {\n    a[i - 1] = i * i - i + 1;\n  }\n\n  long count = 0;\n  for (long i = 0; i < n; i++) {\n    for (long j = i + 1; j < n; j++) {\n      for (long k = j + 1; k < n; k++) {\n        if ((a[i] + a[j] + a[k]) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n  std::vector<long> a(n);\n  for (long i = 0; i < n; i++) {\n    a[i] = i * i - i + 1;\n  }\n\n  long count = 0;\n  for (long i = 0; i < n; i++) {\n    for (long j = i + 1; j < n; j++) {\n      for (long k = j + 1; k < n; k++) {\n        if ((a[i] + a[j] + a[k]) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n  std::vector<long> a(n);\n  for (long i = 0; i < n; i++) {\n    a[i] = i * i - i + 1;\n  }\n  \n  long count = 0;\n  for (long i = 0; i < n; i++) {\n    for (long j = i + 1; j < n; j++) {\n      for (long k = j + 1; k < n; k++) {\n        if ((a[i] + a[j] + a[k]) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n  \n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n  std::vector<long> a(n);\n  for (long i = 0; i < n; ++i) {\n    a[i] = i * i - i + 1;\n  }\n\n  long count = 0;\n  for (long i = 0; i < n; ++i) {\n    for (long j = i + 1; j < n; ++j) {\n      for (long k = j + 1; k < n; ++k) {\n        if ((a[i] + a[j] + a[k]) % 3 == 0) {\n          ++count;\n        }\n      }\n    }\n  }\n\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n  std::vector<long> a(n);\n  for (long i = 0; i < n; ++i) {\n    a[i] = i * i - i + 1;\n  }\n\n  long count = 0;\n  for (long i = 0; i < n; ++i) {\n    for (long j = i + 1; j < n; ++j) {\n      for (long k = j + 1; k < n; ++k) {\n        if ((a[i] + a[j] + a[k]) % 3 == 0) {\n          ++count;\n        }\n      }\n    }\n  }\n\n  return count;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  for (long num : lst1) {\n    if (num % 2 != 0) {\n      bool found = false;\n      for (int i = 0; i < lst2.size(); i++) {\n        if (lst2[i] % 2 == 0) {\n          lst1.push_back(lst2[i]);\n          lst2.erase(lst2.begin() + i);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        return \"NO\";\n      }\n    }\n  }\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  for (long num : lst1) {\n    if (num % 2 != 0) {\n      bool found = false;\n      for (int i = 0; i < lst2.size(); i++) {\n        if (lst2[i] % 2 == 0) {\n          lst1.push_back(lst2[i]);\n          lst2.erase(lst2.begin() + i);\n          found = true;\n          break;\n        }\n      }\n      if (!found) return \"NO\";\n    }\n  }\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  for (long i : lst1) {\n    if (i % 2 != 0) {\n      bool foundEven = false;\n      for (long j = 0; j < lst2.size(); j++) {\n        if (lst2[j] % 2 == 0) {\n          lst1.push_back(lst2[j]);\n          lst2.erase(lst2.begin() + j);\n          foundEven = true;\n          break;\n        }\n      }\n      if (!foundEven) {\n        return \"NO\";\n      }\n    }\n  }\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  for (int i = 0; i < lst1.size(); i++) {\n    if (lst1[i] % 2 != 0) {\n      bool found = false;\n      for (int j = 0; j < lst2.size(); j++) {\n        if (lst2[j] % 2 == 0) {\n          std::swap(lst1[i], lst2[j]);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        return \"NO\";\n      }\n    }\n  }\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  for (auto &num : lst1) {\n    if (num % 2 != 0) {\n      bool found = false;\n      for (auto &num2 : lst2) {\n        if (num2 % 2 == 0) {\n          num = num2;\n          num2 = num;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        return \"NO\";\n      }\n    }\n  }\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  for (auto num : lst1) {\n    if (num % 2 != 0) {\n      bool found = false;\n      for (auto &num2 : lst2) {\n        if (num2 % 2 == 0) {\n          num2 = num;\n          found = true;\n          break;\n        }\n      }\n      if (!found) return \"NO\";\n    }\n  }\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  // Count odd numbers in lst1\n  int oddCount1 = std::count_if(lst1.begin(), lst1.end(), [](int i){return i%2 != 0;});\n\n  // Count even numbers in lst2\n  int evenCount2 = std::count_if(lst2.begin(), lst2.end(), [](int i){return i%2 == 0;});\n\n  // If there are enough even numbers in lst2 to replace the odd numbers in lst1, return \"YES\"\n  if (evenCount2 >= oddCount1) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  for (long &num : lst1) {\n    if (num % 2 != 0) {\n      bool found = false;\n      for (long &num2 : lst2) {\n        if (num2 % 2 == 0) {\n          std::swap(num, num2);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        return \"NO\";\n      }\n    }\n  }\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  for (int i = 0; i < lst1.size(); i++) {\n    if (lst1[i] % 2 != 0) {\n      bool found = false;\n      for (int j = 0; j < lst2.size(); j++) {\n        if (lst2[j] % 2 == 0) {\n          std::swap(lst1[i], lst2[j]);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        return \"NO\";\n      }\n    }\n  }\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  for (long num : lst1) {\n    if (num % 2 != 0) {\n      bool found = false;\n      for (long &num2 : lst2) {\n        if (num2 % 2 == 0) {\n          num2 = num;\n          found = true;\n          break;\n        }\n      }\n      if (!found) return \"NO\";\n    }\n  }\n  return \"YES\";\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n  sort(l.begin(), l.end());\n  int n = l.size();\n  if (n % 2 != 0) {\n    return (float)l[n / 2];\n  } else {\n    return (float)(l[(n - 1) / 2] + l[n / 2]) / 2.0;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n  sort(l.begin(), l.end());\n  int n = l.size();\n  if (n % 2 == 0) {\n    return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n  } else {\n    return l[n / 2];\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n  sort(l.begin(), l.end());\n  int size = l.size();\n  if (size % 2 == 0) {\n    return (l[size / 2 - 1] + l[size / 2]) / 2.0;\n  } else {\n    return l[size / 2];\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n  sort(l.begin(), l.end());\n  int n = l.size();\n  if (n % 2 == 0) {\n    return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n  } else {\n    return l[n / 2];\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n  sort(l.begin(), l.end());\n  int size = l.size();\n  if (size % 2 == 0) {\n    return (l[size / 2 - 1] + l[size / 2]) / 2.0;\n  } else {\n    return l[size / 2];\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n  sort(l.begin(), l.end());\n  int n = l.size();\n  if (n % 2 == 0) {\n    return (float)(l[n / 2 - 1] + l[n / 2]) / 2.0f;\n  } else {\n    return (float)l[n / 2];\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n  sort(l.begin(), l.end());\n  int n = l.size();\n  if (n % 2 == 0) {\n    return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n  } else {\n    return l[n / 2];\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n  sort(l.begin(), l.end());\n  int n = l.size();\n  if (n % 2 == 0) {\n    return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n  } else {\n    return l[n / 2];\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n  sort(l.begin(), l.end());\n  int n = l.size();\n  if (n % 2 == 0) {\n    return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n  } else {\n    return l[n / 2];\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n  sort(l.begin(), l.end());\n  int n = l.size();\n  if (n % 2 != 0)\n    return (float)l[n / 2];\n  else\n    return (float)(l[(n - 1) / 2] + l[n / 2]) / 2.0;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n  int length = string.length();\n  if (length <= 1) return false;\n  if (length == 2) return true;\n  if (length % 2 == 0) return false;\n  for (int i = 3; i * i <= length; i += 2) {\n    if (length % i == 0) return false;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n  int n = string.length();\n  if (n <= 1) {\n    return false;\n  }\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int n = string.length();\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int n = string.length();\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int n = string.length();\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int n = string.length();\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int n = string.length();\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n  int n = string.length();\n  if (n <= 1) return false;\n  if (n == 2 || n == 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (int i = 5; i * i <= n; i += 6) {\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int n = string.length();\n\n    if (n <= 1) {\n        return false;\n    }\n\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n  int n = string.length();\n  if (n <= 1) {\n    return false;\n  }\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n  long changes = 0;\n  int i = 0, j = arr.size() - 1;\n  while (i < j) {\n    if (arr[i] != arr[j]) {\n      changes++;\n    }\n    i++;\n    j--;\n  }\n  return changes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n  long changes = 0;\n  int i = 0, j = arr.size() - 1;\n  while (i < j) {\n    if (arr[i] != arr[j]) {\n      changes++;\n    }\n    i++;\n    j--;\n  }\n  return changes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n  long changes = 0;\n  int start = 0;\n  int end = arr.size() - 1;\n\n  while (start <= end) {\n    if (arr[start] != arr[end]) {\n      changes++;\n    }\n    start++;\n    end--;\n  }\n  \n  return changes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n  long changes = 0;\n  int start = 0;\n  int end = arr.size() - 1;\n  while (start < end) {\n    if (arr[start] != arr[end]) {\n      changes++;\n    }\n    start++;\n    end--;\n  }\n  return changes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n  long changes = 0;\n  int start = 0;\n  int end = arr.size() - 1;\n\n  while (start < end) {\n    if (arr[start] != arr[end]) {\n      changes++;\n    }\n    start++;\n    end--;\n  }\n  return changes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n  long changes = 0;\n  int start = 0;\n  int end = arr.size() - 1;\n\n  while (start <= end) {\n    if (arr[start] != arr[end]) {\n      changes++;\n    }\n    start++;\n    end--;\n  }\n\n  return changes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n  long count = 0;\n  int i = 0, j = arr.size() - 1;\n  \n  while (i < j) {\n    if (arr[i] != arr[j]) {\n      count++;\n    }\n    i++;\n    j--;\n  }\n  \n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n  long changes = 0;\n  int start = 0;\n  int end = arr.size() - 1;\n\n  while (start <= end) {\n    if (arr[start] != arr[end]) {\n      changes++;\n    }\n    start++;\n    end--;\n  }\n  return changes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n  long changes = 0;\n  int i = 0;\n  int j = arr.size() - 1;\n  \n  while (i < j) {\n    if (arr[i] != arr[j]) {\n      changes++;\n    }\n    i++;\n    j--;\n  }\n  \n  return changes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n  long changes = 0;\n  int i = 0, j = arr.size() - 1;\n  while (i < j) {\n    if (arr[i] != arr[j]) {\n      changes++;\n    }\n    i++;\n    j--;\n  }\n  return changes;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    int ceil_val = std::ceil(lst[i]);\n    sum += ceil_val * ceil_val;\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (float num : lst) {\n    int ceilNum = std::ceil(num);\n    sum += ceilNum * ceilNum;\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (float num : lst) {\n    int ceil_num = std::ceil(num);\n    sum += ceil_num * ceil_num;\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (auto &num : lst) {\n    long rounded_num = std::ceil(num);\n    sum += rounded_num * rounded_num;\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    int rounded = std::ceil(lst[i]);\n    sum += rounded * rounded;\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (float num : lst) {\n    int rounded_num = std::ceil(num);\n    sum += rounded_num * rounded_num;\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (float num : lst) {\n    int ceiling = std::ceil(num);\n    sum += ceiling * ceiling;\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    int num = ceil(lst[i]);\n    sum += num * num;\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (float num : lst) {\n    int ceilNum = std::ceil(num);\n    sum += ceilNum * ceilNum;\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (float num : lst) {\n    int ceilNum = std::ceil(num);\n    sum += ceilNum * ceilNum;\n  }\n  return sum;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n  int digitCount = 0;\n  for (char c : file_name) {\n    if (isdigit(c)) digitCount++;\n  }\n  if (digitCount > 3) return \"No\";\n\n  size_t dotPos = file_name.find('.');\n  if (dotPos == std::string::npos || dotPos == 0 || !isalpha(file_name[0])) return \"No\";\n\n  std::string extension = file_name.substr(dotPos + 1);\n  if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") return \"No\";\n\n  return \"Yes\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n  int digit_count = 0;\n  for (char c : file_name) {\n    if (isdigit(c)) digit_count++;\n  }\n  if (digit_count > 3) return \"No\";\n\n  size_t dot_pos = file_name.find('.');\n  if (dot_pos == std::string::npos || dot_pos == 0 || !isalpha(file_name[0])) return \"No\";\n\n  std::string extension = file_name.substr(dot_pos + 1);\n  if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") return \"No\";\n\n  return \"Yes\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n  std::regex pattern(\"^[a-zA-Z][a-zA-Z0-9]{0,2}\\\\.(txt|exe|dll)$\");\n  if (std::regex_match(file_name, pattern)) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n  int dotCount = 0, digitCount = 0;\n  std::string beforeDot = \"\", afterDot = \"\";\n  bool startWithLetter = false;\n\n  for (char c : file_name) {\n    if (c == '.') {\n      dotCount++;\n      if (dotCount > 1) return \"No\";\n      continue;\n    }\n    if (dotCount == 0) {\n      if (isdigit(c)) digitCount++;\n      if (!startWithLetter && isalpha(c)) startWithLetter = true;\n      beforeDot += c;\n    } else {\n      afterDot += c;\n    }\n  }\n\n  if (dotCount != 1 || digitCount > 3 || !startWithLetter || beforeDot.empty()) return \"No\";\n  if (afterDot != \"txt\" && afterDot != \"exe\" && afterDot != \"dll\") return \"No\";\n  \n  return \"Yes\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n  int digitCount = 0;\n  int dotCount = 0;\n  std::string beforeDot = \"\";\n  std::string afterDot = \"\";\n  for (char c : file_name) {\n    if (isdigit(c)) {\n      digitCount++;\n    }\n    if (c == '.') {\n      dotCount++;\n    }\n  }\n\n  if (digitCount > 3 || dotCount != 1) {\n    return \"No\";\n  }\n\n  std::size_t dotPosition = file_name.find(\".\");\n  beforeDot = file_name.substr(0, dotPosition);\n  afterDot = file_name.substr(dotPosition + 1);\n\n  if (beforeDot.empty() || !isalpha(beforeDot[0])) {\n    return \"No\";\n  }\n\n  if (afterDot != \"txt\" && afterDot != \"exe\" && afterDot != \"dll\") {\n    return \"No\";\n  }\n\n  return \"Yes\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n  std::string valid_extensions[] = {\"txt\", \"exe\", \"dll\"};\n  int count_digits = 0;\n  int count_dots = 0;\n  std::string before_dot = \"\", after_dot = \"\";\n  bool dot_encountered = false;\n\n  for (char c : file_name) {\n    if (isdigit(c)) {\n      count_digits++;\n    }\n    if (c == '.') {\n      count_dots++;\n      dot_encountered = true;\n      continue;\n    }\n    if (!dot_encountered) {\n      before_dot += c;\n    } else {\n      after_dot += c;\n    }\n  }\n\n  if (count_dots != 1 || count_digits > 3 || before_dot.empty() || !isalpha(before_dot[0])) {\n    return \"No\";\n  }\n\n  for (std::string ext : valid_extensions) {\n    if (ext == after_dot) {\n      return \"Yes\";\n    }\n  }\n\n  return \"No\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    int digitCount = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) digitCount++;\n    }\n    if (digitCount > 3) return \"No\";\n\n    size_t found = file_name.find('.');\n    if (found == std::string::npos || found == 0 || !isalpha(file_name[0])) return \"No\";\n\n    std::string extension = file_name.substr(found + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") return \"No\";\n\n    return \"Yes\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n  int dotCount = 0;\n  int digitCount = 0;\n  std::string beforeDot = \"\";\n  std::string afterDot = \"\";\n  std::vector<std::string> validExtensions = {\"txt\", \"exe\", \"dll\"};\n\n  for (char c : file_name) {\n    if (isdigit(c)) digitCount++;\n    if (c == '.') dotCount++;\n  }\n\n  if (dotCount != 1 || digitCount > 3) return \"No\";\n\n  size_t dotPos = file_name.find('.');\n  beforeDot = file_name.substr(0, dotPos);\n  afterDot = file_name.substr(dotPos + 1);\n\n  if (beforeDot.empty() || !isalpha(beforeDot[0])) return \"No\";\n\n  if (std::find(validExtensions.begin(), validExtensions.end(), afterDot) == validExtensions.end()) return \"No\";\n\n  return \"Yes\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n  int dot_count = 0, digit_count = 0;\n  size_t dot_position;\n  std::vector<std::string> valid_extensions = {\"txt\", \"exe\", \"dll\"};\n\n  for (size_t i = 0; i < file_name.size(); i++) {\n    if (file_name[i] == '.') {\n      dot_count++;\n      dot_position = i;\n    } else if (isdigit(file_name[i])) {\n      digit_count++;\n    }\n  }\n\n  if (dot_count != 1 || digit_count > 3) {\n    return \"No\";\n  }\n\n  std::string name = file_name.substr(0, dot_position);\n  std::string extension = file_name.substr(dot_position + 1);\n\n  if (name.empty() || !isalpha(name[0])) {\n    return \"No\";\n  }\n\n  if (std::find(valid_extensions.begin(), valid_extensions.end(), extension) == valid_extensions.end()) {\n    return \"No\";\n  }\n\n  return \"Yes\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n  int digitCount = 0;\n  for (char c : file_name) {\n    if (isdigit(c)) digitCount++;\n  }\n  if (digitCount > 3) return \"No\";\n\n  size_t dotPos = file_name.find('.');\n  if (dotPos == std::string::npos || dotPos == 0 || !isalpha(file_name[0])) return \"No\";\n\n  std::string extension = file_name.substr(dotPos + 1);\n  if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") return \"No\";\n\n  return \"Yes\";\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n  int n = l.size();\n  sort(l.begin(), l.end());\n\n  for (int i = 0; i < n - 2; i++) {\n    int left = i + 1;\n    int right = n - 1;\n\n    while (left < right) {\n      long sum = l[i] + l[left] + l[right];\n\n      if (sum == 0) {\n        return true;\n      } else if (sum < 0) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n  int n = l.size();\n  std::sort(l.begin(), l.end());\n\n  for (int i = 0; i < n - 2; i++) {\n    int start = i + 1;\n    int end = n - 1;\n\n    while (start < end) {\n      long sum = l[i] + l[start] + l[end];\n\n      if (sum == 0) {\n        return true;\n      } else if (sum < 0) {\n        start++;\n      } else {\n        end--;\n      }\n    }\n  }\n\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n  int n = l.size();\n  sort(l.begin(), l.end());\n\n  for (int i = 0; i < n - 2; i++) {\n    int start = i + 1;\n    int end = n - 1;\n\n    while (start < end) {\n      long sum = l[i] + l[start] + l[end];\n\n      if (sum == 0) {\n        return true;\n      } else if (sum < 0) {\n        start++;\n      } else {\n        end--;\n      }\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n  int n = l.size();\n  sort(l.begin(), l.end());\n\n  for (int i = 0; i < n - 2; i++) {\n    int start = i + 1;\n    int end = n - 1;\n\n    while (start < end) {\n      long sum = l[i] + l[start] + l[end];\n\n      if (sum == 0) {\n        return true;\n      } else if (sum < 0) {\n        start++;\n      } else {\n        end--;\n      }\n    }\n  }\n\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n  int n = l.size();\n  std::sort(l.begin(), l.end());\n  for (int i = 0; i < n - 2; i++) {\n    int start = i + 1;\n    int end = n - 1;\n    while (start < end) {\n      long sum = l[i] + l[start] + l[end];\n      if (sum == 0) {\n        return true;\n      } else if (sum < 0) {\n        start++;\n      } else {\n        end--;\n      }\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n  int n = l.size();\n  std::sort(l.begin(), l.end());\n\n  for(int i=0; i<n-2; i++){\n    int start = i+1;\n    int end = n-1;\n\n    while(start < end){\n      long sum = l[i] + l[start] + l[end];\n      if(sum == 0){\n        return true;\n      } else if(sum < 0){\n        start++;\n      } else {\n        end--;\n      }\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n  int n = l.size();\n  sort(l.begin(), l.end());\n\n  for (int i = 0; i < n - 2; i++) {\n    int start = i + 1;\n    int end = n - 1;\n    while (start < end) {\n      long sum = l[i] + l[start] + l[end];\n      if (sum == 0) {\n        return true;\n      } else if (sum < 0) {\n        start++;\n      } else {\n        end--;\n      }\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n  int n = l.size();\n  sort(l.begin(), l.end());\n\n  for (int i = 0; i < n - 2; i++) {\n    int start = i + 1;\n    int end = n - 1;\n\n    while (start < end) {\n      long sum = l[i] + l[start] + l[end];\n\n      if (sum == 0) {\n        return true;\n      } else if (sum < 0) {\n        start++;\n      } else {\n        end--;\n      }\n    }\n  }\n\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n  int n = l.size();\n  sort(l.begin(), l.end());\n  for (int i = 0; i < n - 2; i++) {\n    int start = i + 1;\n    int end = n - 1;\n    while (start < end) {\n      long sum = l[i] + l[start] + l[end];\n      if (sum == 0) {\n        return true;\n      } else if (sum < 0) {\n        start++;\n      } else {\n        end--;\n      }\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n  int n = l.size();\n  sort(l.begin(), l.end());\n  \n  for (int i = 0; i < n - 2; i++) {\n    int j = i + 1;\n    int k = n - 1;\n  \n    while (j < k) {\n      long sum = l[i] + l[j] + l[k];\n  \n      if (sum == 0) {\n        return true;\n      } else if (sum < 0) {\n        j++;\n      } else {\n        k--;\n      }\n    }\n  }\n  \n  return false;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n  long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n\n  if (start > end) {\n    return \"NO\";\n  }\n\n  long length = end - start + 1;\n\n  if (length < 2) {\n    return \"NO\";\n  }\n\n  for (long i = 2; i * i <= length; i++) {\n    if (length % i == 0) {\n      return \"NO\";\n    }\n  }\n\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n  long end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n  \n  if (start > end) {\n    return \"NO\";\n  }\n\n  long length = end - start + 1;\n\n  if (length < 2) {\n    return \"NO\";\n  }\n\n  for (long i = 2; i * i <= length; i++) {\n    if (length % i == 0) {\n      return \"NO\";\n    }\n  }\n\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n  long end2 = std::get<1>(interval2);\n\n  long intersectionStart = std::max(start1, start2);\n  long intersectionEnd = std::min(end1, end2);\n\n  if (intersectionStart > intersectionEnd) {\n    return \"NO\";\n  }\n\n  long length = intersectionEnd - intersectionStart;\n\n  if (length < 2) {\n    return \"NO\";\n  }\n\n  for (long i = 2; i * i <= length; ++i) {\n    if (length % i == 0) {\n      return \"NO\";\n    }\n  }\n\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n  long end2 = std::get<1>(interval2);\n\n  long start = std::max(start1, start2);\n  long end = std::min(end1, end2);\n\n  if (start > end) {\n    return \"NO\";\n  }\n\n  long length = end - start + 1;\n\n  if (length < 2) {\n    return \"NO\";\n  }\n\n  for (long i = 2; i * i <= length; i++) {\n    if (length % i == 0) {\n      return \"NO\";\n    }\n  }\n\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n  long end2 = std::get<1>(interval2);\n\n  long start = std::max(start1, start2);\n  long end = std::min(end1, end2);\n\n  if (start > end) {\n    return \"NO\";\n  }\n\n  long length = end - start + 1;\n\n  if (length < 2) {\n    return \"NO\";\n  }\n\n  for (long i = 2; i * i <= length; i++) {\n    if (length % i == 0) {\n      return \"NO\";\n    }\n  }\n\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n  long end2 = std::get<1>(interval2);\n\n  long start = std::max(start1, start2);\n  long end = std::min(end1, end2);\n\n  if (start > end) {\n    return \"NO\";\n  }\n\n  long length = end - start + 1;\n\n  if (length < 2) {\n    return \"NO\";\n  }\n\n  for (long i = 2; i * i <= length; i++) {\n    if (length % i == 0) {\n      return \"NO\";\n    }\n  }\n\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n  long end2 = std::get<1>(interval2);\n\n  long start = std::max(start1, start2);\n  long end = std::min(end1, end2);\n\n  if (start > end) {\n    return \"NO\";\n  }\n\n  long length = end - start + 1;\n\n  if (length < 2) {\n    return \"NO\";\n  }\n\n  for (long i = 2; i * i <= length; ++i) {\n    if (length % i == 0) {\n      return \"NO\";\n    }\n  }\n\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n  long end2 = std::get<1>(interval2);\n\n  long intersectionStart = std::max(start1, start2);\n  long intersectionEnd = std::min(end1, end2);\n\n  if (intersectionStart > intersectionEnd) {\n    return \"NO\";\n  }\n\n  long length = intersectionEnd - intersectionStart + 1;\n\n  if (length < 2) {\n    return \"NO\";\n  }\n\n  for (long i = 2; i * i <= length; i++) {\n    if (length % i == 0) {\n      return \"NO\";\n    }\n  }\n\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n  long end2 = std::get<1>(interval2);\n\n  long start = std::max(start1, start2);\n  long end = std::min(end1, end2);\n\n  if (start > end) {\n    return \"NO\";\n  }\n\n  long length = end - start + 1;\n  \n  if (length < 2) {\n    return \"NO\";\n  }\n\n  for (long i = 2; i * i <= length; i++) {\n    if (length % i == 0) {\n      return \"NO\";\n    }\n  }\n\n  return \"YES\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n  long end2 = std::get<1>(interval2);\n\n  long start = std::max(start1, start2);\n  long end = std::min(end1, end2);\n\n  if (start > end) {\n    return \"NO\";\n  }\n\n  long length = end - start + 1;\n\n  if (length < 2) {\n    return \"NO\";\n  }\n\n  for (long i = 2; i * i <= length; i++) {\n    if (length % i == 0) {\n      return \"NO\";\n    }\n  }\n\n  return \"YES\";\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n  std::vector<std::string> groups;\n  std::string group;\n  int openCount = 0;\n\n  for (char c : paren_string) {\n    if (c == ' ') continue;\n    if (c == '(') {\n      openCount++;\n    } else if (c == ')') {\n      openCount--;\n    }\n    group += c;\n\n    if (openCount == 0) {\n      groups.push_back(group);\n      group.clear();\n    }\n  }\n  return groups;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n  std::vector<std::string> paren_groups;\n  std::string current_group;\n  int open_paren_count = 0;\n\n  for (char c : paren_string) {\n    if (c == ' ') continue;\n\n    if (c == '(') {\n      open_paren_count++;\n    } else if (c == ')') {\n      open_paren_count--;\n    }\n\n    current_group += c;\n\n    if (open_paren_count == 0) {\n      paren_groups.push_back(current_group);\n      current_group = \"\";\n    }\n  }\n\n  return paren_groups;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n  std::vector<std::string> result;\n  std::string current_group;\n  int open_count = 0;\n\n  for (char c : paren_string) {\n    if (c == ' ') continue;\n    current_group += c;\n    if (c == '(') open_count++;\n    else if (c == ')') open_count--;\n    if (open_count == 0) {\n      result.push_back(current_group);\n      current_group = \"\";\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n  std::vector<std::string> result;\n  std::string temp;\n  int open = 0;\n\n  for (char c : paren_string) {\n    if (c == ' ') continue;\n    if (c == '(') {\n      open++;\n    } else if (c == ')') {\n      open--;\n    }\n    temp += c;\n    if (open == 0) {\n      result.push_back(temp);\n      temp.clear();\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n  std::vector<std::string> result;\n  std::string temp;\n  int openCount = 0;\n\n  for (char c : paren_string) {\n    if (c == ' ') continue;\n    if (c == '(') {\n      openCount++;\n    } else if (c == ')') {\n      openCount--;\n    }\n    temp += c;\n    if (openCount == 0 && !temp.empty()) {\n      result.push_back(temp);\n      temp.clear();\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n  std::vector<std::string> groups;\n  std::string group;\n  int open = 0;\n\n  for (char c : paren_string) {\n    if (c == '(') {\n      open++;\n      group += c;\n    } else if (c == ')') {\n      open--;\n      group += c;\n      if (open == 0) {\n        groups.push_back(group);\n        group.clear();\n      }\n    }\n  }\n\n  return groups;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n  std::vector<std::string> groups;\n  std::string group;\n  int balance = 0;\n\n  for (char c : paren_string) {\n    if (c == ' ') continue;\n    if (c == '(') {\n      balance++;\n      group += c;\n    } else if (c == ')') {\n      balance--;\n      group += c;\n      if (balance == 0) {\n        groups.push_back(group);\n        group.clear();\n      }\n    }\n  }\n  return groups;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n  std::vector<std::string> groups;\n  std::string group;\n  int open_count = 0;\n\n  for (char c : paren_string) {\n    if (c == ' ') continue;\n    if (c == '(') {\n      open_count++;\n    } else if (c == ')') {\n      open_count--;\n    }\n    group += c;\n    if (open_count == 0) {\n      groups.push_back(group);\n      group.clear();\n    }\n  }\n  return groups;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n  std::vector<std::string> result;\n  std::string current;\n  int balance = 0;\n\n  for (char c : paren_string) {\n    if (c == ' ') continue;\n    current += c;\n    if (c == '(') balance++;\n    else if (c == ')') balance--;\n\n    if (balance == 0) {\n      result.push_back(current);\n      current.clear();\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n  std::vector<std::string> result;\n  std::string temp;\n  int open = 0;\n\n  for (char c : paren_string) {\n    if (c == ' ') continue;\n    if (c == '(') {\n      open++;\n    } else if (c == ')') {\n      open--;\n    }\n    temp += c;\n    if (open == 0) {\n      result.push_back(temp);\n      temp.clear();\n    }\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n  std::vector<long> result;\n  for (int i = 0; i < game.size(); i++) {\n    result.push_back(abs(game[i] - guess[i]));\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n  std::vector<long> result;\n  for (int i = 0; i < game.size(); i++) {\n    result.push_back(abs(game[i] - guess[i]));\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n  std::vector<long> result;\n  for (int i = 0; i < game.size(); i++) {\n    result.push_back(abs(game[i] - guess[i]));\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n  std::vector<long> result;\n  for (int i = 0; i < game.size(); i++) {\n    result.push_back(abs(game[i] - guess[i]));\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n  std::vector<long> result;\n  for (int i = 0; i < game.size(); i++) {\n    long difference = abs(game[i] - guess[i]);\n    result.push_back(difference);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n  std::vector<long> result;\n  for (int i = 0; i < game.size(); i++) {\n    result.push_back(abs(game[i] - guess[i]));\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n  std::vector<long> result;\n  for (int i = 0; i < game.size(); i++) {\n    result.push_back(abs(game[i] - guess[i]));\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n  std::vector<long> result;\n  for (int i = 0; i < game.size(); i++) {\n    result.push_back(abs(game[i] - guess[i]));\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n  std::vector<long> result;\n  for (int i = 0; i < game.size(); i++) {\n    result.push_back(abs(game[i] - guess[i]));\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n  std::vector<long> result;\n  for (int i = 0; i < game.size(); i++) {\n    result.push_back(abs(game[i] - guess[i]));\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n  if (n == 1) {\n    return 1;\n  } else {\n    return 2 * pow(10, n - 1);\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n  if (n == 1) {\n    return 1;\n  } else {\n    return 2 * pow(10, n - 1);\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n  if (n == 1) {\n    return 1;\n  } else {\n    return 2 * pow(10, n - 1);\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n  if (n <= 0) {\n    return 0;\n  }\n  // There are 10^(n-1) n-digit numbers.\n  // Since 1 of them starts with 1 and 1 of them ends with 1,\n  // there are 2 * 10^(n-1) numbers that start or end with 1.\n  // But we have double counted the numbers that start and end with 1.\n  // There are 10^(n-2) such numbers.\n  // So the total is 2 * 10^(n-1) - 10^(n-2).\n  return 2 * pow(10, n - 1) - pow(10, n - 2);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n  if (n == 1) {\n    return 1;\n  }\n  return 2 * pow(10, n - 1);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n  if (n == 1) {\n    return 1;\n  }\n  // There are 10^(n-1) n-digit numbers.\n  // Among them, 1*10^(n-2) start with 1 and 1*10^(n-2) end with 1.\n  // But the numbers that start and end with 1 have been counted twice, so we subtract 1*10^(n-3).\n  return 2 * pow(10, n - 2) - pow(10, n - 3);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n  if (n == 1) {\n    return 1;\n  }\n  else {\n    return 2 * pow(10, n - 1);\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n  if (n == 1) {\n    return 2; // 1 and 1\n  } else {\n    return 2 * pow(10, n - 1); // 10^(n-1) for numbers starting with 1 and 10^(n-1) for numbers ending with 1\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n  if (n == 1) \n    return 1;\n  else \n    return 2 * pow(10, n - 1);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n  if(n == 1) \n    return 1;\n  else\n    return 2 * pow(10, n - 1);\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty()) return false;\n  char lastChar = txt[txt.size() - 1];\n  if (lastChar == ' ') return false;\n  return isalpha(lastChar);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty() || txt.back() == ' ') {\n    return false;\n  }\n  return isalpha(txt.back());\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty()) {\n    return false;\n  }\n\n  char lastChar = txt[txt.length() - 1];\n\n  if (lastChar == ' ') {\n    return false;\n  }\n\n  if (isalpha(lastChar)) {\n    if (txt.length() == 1 || txt[txt.length() - 2] == ' ') {\n      return true;\n    }\n  }\n\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if(txt.empty())\n    return false;\n  char lastChar = txt[txt.length() - 1];\n  if(isspace(lastChar))\n    return false;\n  if(isalpha(lastChar) && (txt.length() == 1 || isspace(txt[txt.length() - 2])))\n    return true;\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if(txt.empty() || txt.back() == ' ') {\n    return false;\n  }\n  return isalpha(txt.back());\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if(txt.empty() || txt.back() == ' ') {\n    return false;\n  }\n  return isalpha(txt.back());\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty()) {\n    return false;\n  }\n  \n  char lastChar = txt[txt.length() - 1];\n  \n  if (!isalpha(lastChar)) {\n    return false;\n  }\n  \n  if (txt.length() == 1 || txt[txt.length() - 2] == ' ') {\n    return true;\n  }\n  \n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty() || txt.back() == ' ') {\n    return false;\n  }\n  return isalpha(txt.back());\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty()) {\n    return false;\n  }\n  char lastChar = txt[txt.length() - 1];\n  if (lastChar == ' ') {\n    return false;\n  }\n  if (isalpha(lastChar) && (txt.length() == 1 || txt[txt.length() - 2] == ' ')) {\n    return true;\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty()) {\n    return false;\n  }\n\n  char lastChar = txt[txt.length() - 1];\n  if (!isalpha(lastChar)) {\n    return false;\n  }\n\n  if (txt.length() == 1 || txt[txt.length() - 2] == ' ') {\n    return true;\n  }\n\n  return false;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n  if (date.size() != 10 || date[2] != '-' || date[5] != '-')\n    return false;\n\n  int month = stoi(date.substr(0, 2));\n  int day = stoi(date.substr(3, 2));\n  int year = stoi(date.substr(6, 4));\n\n  if (month < 1 || month > 12 || day < 1 || day > 31)\n    return false;\n\n  if (month == 2) {\n    if (day > 29)\n      return false;\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day > 30)\n      return false;\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n  if (date.length() != 10 || date[2] != '-' || date[5] != '-')\n    return false;\n\n  int month = stoi(date.substr(0, 2));\n  int day = stoi(date.substr(3, 2));\n  int year = stoi(date.substr(6, 4));\n\n  if (month < 1 || month > 12 || day < 1 || year < 1)\n    return false;\n\n  if (month == 2) {\n    if (day > 29)\n      return false;\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day > 30)\n      return false;\n  } else {\n    if (day > 31)\n      return false;\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n  if(date.size() != 10 || date[2] != '-' || date[5] != '-')\n    return false;\n  \n  int month = std::stoi(date.substr(0,2));\n  int day = std::stoi(date.substr(3,2));\n  int year = std::stoi(date.substr(6,4));\n\n  if(month < 1 || month > 12 || day < 1 || year < 1)\n    return false;\n\n  if(month == 2) {\n    if(day > 29)\n      return false;\n  } else if(month == 4 || month == 6 || month == 9 || month == 11) {\n    if(day > 30)\n      return false;\n  } else {\n    if(day > 31)\n      return false;\n  }\n  \n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n  if (date.size() != 10 || date[2] != '-' || date[5] != '-')\n    return false;\n\n  int month = std::stoi(date.substr(0, 2));\n  int day = std::stoi(date.substr(3, 2));\n  int year = std::stoi(date.substr(6, 4));\n\n  if (month < 1 || month > 12 || day < 1 || year < 1)\n    return false;\n\n  if (month == 2) {\n    if (day > 29)\n      return false;\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day > 30)\n      return false;\n  } else {\n    if (day > 31)\n      return false;\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n  if (date.size() != 10 || date[2] != '-' || date[5] != '-') {\n    return false;\n  }\n\n  int month = std::stoi(date.substr(0, 2));\n  int day = std::stoi(date.substr(3, 2));\n  int year = std::stoi(date.substr(6, 4));\n\n  if (month < 1 || month > 12 || day < 1 || year < 1) {\n    return false;\n  }\n\n  if (month == 2) {\n    if (day > 29) {\n      return false;\n    }\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day > 30) {\n      return false;\n    }\n  } else {\n    if (day > 31) {\n      return false;\n    }\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n  if(date.size() != 10 || date[2] != '-' || date[5] != '-')\n    return false;\n\n  int month = std::stoi(date.substr(0, 2));\n  int day = std::stoi(date.substr(3, 2));\n  int year = std::stoi(date.substr(6, 4));\n\n  if(month < 1 || month > 12 || day < 1)\n    return false;\n\n  if(month == 2) {\n    if(day > 29)\n      return false;\n  } else if(month == 4 || month == 6 || month == 9 || month == 11) {\n    if(day > 30)\n      return false;\n  } else {\n    if(day > 31)\n      return false;\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n  if (date.size() != 10 || date[2] != '-' || date[5] != '-')\n    return false;\n\n  int month = std::stoi(date.substr(0, 2));\n  int day = std::stoi(date.substr(3, 2));\n  int year = std::stoi(date.substr(6, 4));\n\n  if (month < 1 || month > 12)\n    return false;\n\n  if (day < 1)\n    return false;\n\n  if (month == 2) {\n    if (day > 29)\n      return false;\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day > 30)\n      return false;\n  } else {\n    if (day > 31)\n      return false;\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n  if (date.size() != 10 || date[2] != '-' || date[5] != '-') {\n    return false;\n  }\n\n  int month = std::stoi(date.substr(0, 2));\n  int day = std::stoi(date.substr(3, 2));\n  int year = std::stoi(date.substr(6, 4));\n\n  if (month < 1 || month > 12 || day < 1 || year < 1) {\n    return false;\n  }\n\n  if (month == 2) {\n    if (day > 29) {\n      return false;\n    }\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day > 30) {\n      return false;\n    }\n  } else {\n    if (day > 31) {\n      return false;\n    }\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n  if (date.size() != 10 || date[2] != '-' || date[5] != '-') {\n    return false;\n  }\n  \n  int month = stoi(date.substr(0, 2));\n  int day = stoi(date.substr(3, 2));\n  int year = stoi(date.substr(6, 4));\n\n  if (month < 1 || month > 12 || day < 1 || year < 0) {\n    return false;\n  }\n\n  if (month == 2) {\n    if (day > 29) {\n      return false;\n    }\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day > 30) {\n      return false;\n    }\n  } else {\n    if (day > 31) {\n      return false;\n    }\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n  if (date.size() != 10 || date[2] != '-' || date[5] != '-')\n    return false;\n\n  int month = stoi(date.substr(0, 2));\n  int day = stoi(date.substr(3, 2));\n  int year = stoi(date.substr(6, 4));\n\n  if (month < 1 || month > 12 || day < 1 || year < 1)\n    return false;\n\n  if (month == 2) {\n    if (day > 29)\n      return false;\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day > 30)\n      return false;\n  } else {\n    if (day > 31)\n      return false;\n  }\n\n  return true;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (long num : arr) {\n    long sum = 0;\n    while (num != 0) {\n      sum += num % 10;\n      num /= 10;\n    }\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (auto num : arr) {\n    long sum = 0;\n    while (num != 0) {\n      sum += num % 10;\n      num /= 10;\n    }\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (long num : arr) {\n    long sum = 0;\n    while (num != 0) {\n      sum += num % 10;\n      num /= 10;\n    }\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (auto num : arr) {\n    long sum = 0;\n    while (num != 0) {\n      sum += num % 10;\n      num /= 10;\n    }\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (auto num : arr) {\n    long sum = 0;\n    while (num != 0) {\n      sum += num % 10;\n      num /= 10;\n    }\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (long num : arr) {\n    long sum = 0;\n    while (num != 0) {\n      sum += num % 10;\n      num /= 10;\n    }\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (auto num : arr) {\n    long sum = 0;\n    while (num != 0) {\n      sum += num % 10;\n      num /= 10;\n    }\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (long num : arr) {\n    long sum = 0;\n    while (num != 0) {\n      sum += num % 10;\n      num /= 10;\n    }\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (long num : arr) {\n    long sum = 0;\n    while (num != 0) {\n      sum += num % 10;\n      num /= 10;\n    }\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (long num : arr) {\n    long sum = 0;\n    while (num != 0) {\n      sum += num % 10;\n      num /= 10;\n    }\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n  std::stringstream ss(s);\n  std::string word, result = \"\";\n\n  while (ss >> word) {\n    std::sort(word.begin(), word.end());\n    result += word + \" \";\n  }\n\n  // Remove the trailing space\n  result.pop_back();\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n  std::stringstream ss(s);\n  std::string word, result = \"\";\n\n  while (ss >> word) {\n    std::sort(word.begin(), word.end());\n    result += word + \" \";\n  }\n\n  result.erase(result.end() - 1); // remove the last space\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n  std::stringstream ss(s);\n  std::string word, result = \"\";\n  \n  while (ss >> word) {\n    std::sort(word.begin(), word.end());\n    result += word + \" \";\n  }\n  \n  result.pop_back(); // remove the last space\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n  std::stringstream ss(s);\n  std::string word, result = \"\";\n\n  while (ss >> word) {\n    std::sort(word.begin(), word.end());\n    result += word + \" \";\n  }\n\n  // Remove the trailing space\n  if (!result.empty()) {\n    result.pop_back();\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n  std::stringstream ss(s);\n  std::string word, result = \"\";\n  \n  while (ss >> word) {\n    std::sort(word.begin(), word.end());\n    result += word + \" \";\n  }\n  \n  result.pop_back(); // remove last space\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n  std::stringstream ss(s);\n  std::string word, result = \"\";\n\n  while (ss >> word) {\n    std::sort(word.begin(), word.end());\n    result += word + \" \";\n  }\n\n  result.erase(result.length() - 1); // Remove the trailing space\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n  std::stringstream ss(s);\n  std::string word, result = \"\";\n  \n  while (ss >> word) {\n    std::sort(word.begin(), word.end());\n    result += word + \" \";\n  }\n\n  // remove the trailing space\n  result.erase(result.length() - 1);\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n  std::stringstream ss(s);\n  std::string word, result = \"\";\n\n  while (ss >> word) {\n    std::sort(word.begin(), word.end());\n    result += word + \" \";\n  }\n\n  result.erase(result.length() - 1); // remove the last space\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n  std::istringstream iss(s);\n  std::string word, result = \"\";\n  \n  while (iss >> word) {\n    std::sort(word.begin(), word.end());\n    result += word + \" \";\n  }\n\n  // Remove the trailing space\n  result.erase(result.length() - 1);\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n  std::stringstream ss(s);\n  std::string word, result = \"\";\n  \n  while (ss >> word) {\n    std::sort(word.begin(), word.end());\n    result += word + \" \";\n  }\n  \n  result.pop_back(); // remove the trailing space\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int start = 0;\n  int end = text.length() - 1;\n  while (start < end) {\n    if (text[start] != text[end]) {\n      return false;\n    }\n    start++;\n    end--;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int start = 0;\n  int end = text.length() - 1;\n  while (start < end) {\n    if (text[start] != text[end]) {\n      return false;\n    }\n    start++;\n    end--;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int start = 0;\n  int end = text.length() - 1;\n  while (start < end) {\n    if (text[start] != text[end]) {\n      return false;\n    }\n    start++;\n    end--;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int start = 0;\n  int end = text.length() - 1;\n  \n  while (start < end) {\n    if (text[start] != text[end]) {\n      return false;\n    }\n    start++;\n    end--;\n  }\n  \n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int start = 0;\n  int end = text.length() - 1;\n  while (start < end) {\n    if (text[start] != text[end]) {\n      return false;\n    }\n    start++;\n    end--;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int start = 0;\n  int end = text.length() - 1;\n  while (start < end) {\n    if (text[start] != text[end]) {\n      return false;\n    }\n    start++;\n    end--;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int start = 0;\n  int end = text.length() - 1;\n\n  while (start < end) {\n    if (text[start] != text[end]) {\n      return false;\n    }\n    start++;\n    end--;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int start = 0;\n  int end = text.length() - 1;\n  \n  while (start < end) {\n    if (text[start] != text[end]) {\n      return false;\n    }\n    start++;\n    end--;\n  }\n  \n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n    int start = 0;\n    int end = text.length() - 1;\n    while (start < end) {\n        if (text[start] != text[end]) {\n            return false;\n        }\n        start++;\n        end--;\n    }\n    return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int start = 0;\n  int end = text.length() - 1;\n  while (start < end) {\n    if (text[start] != text[end]) {\n      return false;\n    }\n    start++;\n    end--;\n  }\n  return true;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    for (int i = word.length() - 2; i > 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos && \n            vowels.find(word[i-1]) == std::string::npos && \n            vowels.find(word[i+1]) == std::string::npos) {\n            return std::string(1, word[i]);\n        }\n    }\n    return \"\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n  std::string vowels = \"aeiouAEIOU\";\n  for (int i = word.length() - 2; i > 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos && \n        vowels.find(word[i-1]) == std::string::npos && \n        vowels.find(word[i+1]) == std::string::npos) {\n      return std::string(1, word[i]);\n    }\n  }\n  return \"\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n  std::string vowels = \"aeiouAEIOU\";\n  for (int i = word.length() - 2; i > 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos && \n        vowels.find(word[i-1]) == std::string::npos && \n        vowels.find(word[i+1]) == std::string::npos) {\n      return std::string(1, word[i]);\n    }\n  }\n  return \"\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n  std::string vowels = \"aeiouAEIOU\";\n  for (int i = word.length() - 2; i > 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos && \n        vowels.find(word[i - 1]) == std::string::npos &&\n        vowels.find(word[i + 1]) == std::string::npos) {\n      return std::string(1, word[i]);\n    }\n  }\n  return \"\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n  std::string vowels = \"aeiouAEIOU\";\n  for (int i = word.length() - 2; i > 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos && \n        vowels.find(word[i - 1]) == std::string::npos && \n        vowels.find(word[i + 1]) == std::string::npos) {\n      return std::string(1, word[i]);\n    }\n  }\n  return \"\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n  std::string vowels = \"aeiouAEIOU\";\n  for (int i = word.size() - 2; i > 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos && \n        vowels.find(word[i - 1]) == std::string::npos && \n        vowels.find(word[i + 1]) == std::string::npos) {\n      return std::string(1, word[i]);\n    }\n  }\n  return \"\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n  std::string vowels = \"aeiouAEIOU\";\n  for (int i = word.length() - 2; i > 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos && \n        vowels.find(word[i-1]) == std::string::npos && \n        vowels.find(word[i+1]) == std::string::npos) {\n      return std::string(1, word[i]);\n    }\n  }\n  return \"\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n  std::string vowels = \"aeiouAEIOU\";\n  for (int i = word.length() - 2; i > 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos && \n        vowels.find(word[i - 1]) == std::string::npos && \n        vowels.find(word[i + 1]) == std::string::npos) {\n      return std::string(1, word[i]);\n    }\n  }\n  return \"\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n  std::string vowels = \"aeiouAEIOU\";\n  for (int i = word.length() - 2; i > 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos && !isalpha(word[i-1]) && !isalpha(word[i+1])) {\n      return std::string(1, word[i]);\n    }\n  }\n  return \"\";\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n  std::string vowels = \"aeiouAEIOU\";\n  for (int i = word.length() - 2; i > 0; i--) {\n    if (vowels.find(word[i]) != std::string::npos && \n        vowels.find(word[i - 1]) == std::string::npos && \n        vowels.find(word[i + 1]) == std::string::npos) {\n      return std::string(1, word[i]);\n    }\n  }\n  return \"\";\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n  if(n <= 1) return false;\n  if(n <= 3) return true;\n\n  if(n % 2 == 0 || n % 3 == 0) return false;\n\n  for(long i = 5; i * i <= n; i += 6) {\n    if(n % i == 0 || n % (i + 2) == 0) return false;\n  }\n\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n  if (n <= 1) {\n    return false;\n  }\n  if (n == 2) {\n    return true;\n  }\n  if (n % 2 == 0) {\n    return false;\n  }\n  for (long i = 3; i * i <= n; i += 2) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n  if (n <= 1) \n    return false; \n  if (n <= 3) \n    return true; \n  \n  if (n % 2 == 0 || n % 3 == 0) \n    return false; \n  \n  for (long i = 5; i * i <= n; i = i + 6) \n    if (n % i == 0 || n % (i + 2) == 0) \n      return false; \n  \n  return true; \n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 3) {\n    return true;\n  }\n  if (n % 2 == 0 || n % 3 == 0) {\n    return false;\n  }\n  for (long i = 5; i * i <= n; i = i + 6) {\n    if (n % i == 0 || n % (i + 2) == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 3) {\n    return true;\n  }\n  if (n % 2 == 0 || n % 3 == 0) {\n    return false;\n  }\n  for (long i = 5; i * i <= n; i += 6) {\n    if (n % i == 0 || n % (i + 2) == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n  if (n <= 1) {\n    return false;\n  }\n  if (n == 2) {\n    return true;\n  }\n  if (n % 2 == 0) {\n    return false;\n  }\n  for (long i = 3; i * i <= n; i += 2) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n  if (n <= 1) \n    return false; \n  if (n <= 3) \n    return true; \n  if (n % 2 == 0 || n % 3 == 0) \n    return false; \n  for (int i = 5; i * i <= n; i = i + 6) \n    if (n % i == 0 || n % (i + 2) == 0) \n      return false; \n  return true; \n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (long i = 5; i * i <= n; i += 6) {\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 3) {\n    return true;\n  }\n  if (n % 2 == 0 || n % 3 == 0) {\n    return false;\n  }\n  for (long i = 5; i * i <= n; i = i + 6) {\n    if (n % i == 0 || n % (i + 2) == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 3) {\n    return true;\n  }\n  if (n % 2 == 0 || n % 3 == 0) {\n    return false;\n  }\n  for (long i = 5; i * i <= n; i = i + 6) {\n    if (n % i == 0 || n % (i + 2) == 0) {\n      return false;\n    }\n  }\n  return true;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n  int num1, den1, num2, den2;\n  sscanf(x.c_str(), \"%d/%d\", &num1, &den1);\n  sscanf(n.c_str(), \"%d/%d\", &num2, &den2);\n\n  int num = num1 * num2;\n  int den = den1 * den2;\n\n  return num % den == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n  std::stringstream ssx(x), ssn(n);\n  long long numx, denx, numn, denn;\n  char ch;\n  ssx >> numx >> ch >> denx;\n  ssn >> numn >> ch >> denn;\n  long long num = numx * numn;\n  long long den = denx * denn;\n  return num % den == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n  int num1, den1, num2, den2;\n  sscanf(x.c_str(), \"%d/%d\", &num1, &den1);\n  sscanf(n.c_str(), \"%d/%d\", &num2, &den2);\n  \n  int result_num = num1 * num2;\n  int result_den = den1 * den2;\n  \n  return result_num % result_den == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    // Splitting the fractions into numerator and denominator\n    std::string x_num = x.substr(0, x.find(\"/\"));\n    std::string x_den = x.substr(x.find(\"/\") + 1);\n    std::string n_num = n.substr(0, n.find(\"/\"));\n    std::string n_den = n.substr(n.find(\"/\") + 1);\n\n    // Converting string to integer\n    int x_numerator = std::stoi(x_num);\n    int x_denominator = std::stoi(x_den);\n    int n_numerator = std::stoi(n_num);\n    int n_denominator = std::stoi(n_den);\n\n    // Simplifying the expression\n    int numerator = x_numerator * n_numerator;\n    int denominator = x_denominator * n_denominator;\n\n    // Checking if the result is a whole number\n    if (numerator % denominator == 0) {\n        return true;\n    } else {\n        return false;\n    }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n  std::string::size_type sz;\n  long long num1 = std::stoll(x, &sz);\n  long long den1 = std::stoll(x.substr(sz + 1));\n  long long num2 = std::stoll(n, &sz);\n  long long den2 = std::stoll(n.substr(sz + 1));\n  \n  long long numerator = num1 * num2;\n  long long denominator = den1 * den2;\n  \n  return numerator % denominator == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n  int num1, den1, num2, den2;\n  sscanf(x.c_str(), \"%d/%d\", &num1, &den1);\n  sscanf(n.c_str(), \"%d/%d\", &num2, &den2);\n\n  int num = num1 * num2;\n  int den = den1 * den2;\n\n  return num % den == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n  std::string x_num, x_den, n_num, n_den;\n  std::stringstream x_stream(x), n_stream(n);\n  \n  std::getline(x_stream, x_num, '/');\n  std::getline(x_stream, x_den, '/');\n  std::getline(n_stream, n_num, '/');\n  std::getline(n_stream, n_den, '/');\n  \n  long long int x_numerator = std::stoll(x_num);\n  long long int x_denominator = std::stoll(x_den);\n  long long int n_numerator = std::stoll(n_num);\n  long long int n_denominator = std::stoll(n_den);\n  \n  long long int numerator = x_numerator * n_numerator;\n  long long int denominator = x_denominator * n_denominator;\n  \n  return numerator % denominator == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n  std::string x_num_str = x.substr(0, x.find(\"/\"));\n  std::string x_den_str = x.substr(x.find(\"/\") + 1);\n  std::string n_num_str = n.substr(0, n.find(\"/\"));\n  std::string n_den_str = n.substr(n.find(\"/\") + 1);\n\n  int x_num = std::stoi(x_num_str);\n  int x_den = std::stoi(x_den_str);\n  int n_num = std::stoi(n_num_str);\n  int n_den = std::stoi(n_den_str);\n\n  int num = x_num * n_num;\n  int den = x_den * n_den;\n\n  return num % den == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n  std::string x_num = x.substr(0, x.find(\"/\"));\n  std::string x_den = x.substr(x.find(\"/\") + 1);\n  std::string n_num = n.substr(0, n.find(\"/\"));\n  std::string n_den = n.substr(n.find(\"/\") + 1);\n\n  int num = std::stoi(x_num) * std::stoi(n_num);\n  int den = std::stoi(x_den) * std::stoi(n_den);\n\n  return num % den == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n  int num1, den1, num2, den2;\n  sscanf(x.c_str(), \"%d/%d\", &num1, &den1);\n  sscanf(n.c_str(), \"%d/%d\", &num2, &den2);\n\n  int num = num1 * num2;\n  int den = den1 * den2;\n\n  return num % den == 0;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n  long count = 0;\n  for (char c : num) {\n    if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n  long count = 0;\n  for (char c : num) {\n    if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n  long count = 0;\n  for (char c : num) {\n    if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n  long count = 0;\n  for (char c : num) {\n    if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n  long count = 0;\n  for (char c : num) {\n    if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n  long count = 0;\n  for (char c : num) {\n    if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n  long count = 0;\n  for (char c : num) {\n    if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n  long count = 0;\n  for (char c : num) {\n    if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n  long count = 0;\n  for (char c : num) {\n    if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n  long count = 0;\n  for (char c : num) {\n    if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n      count++;\n    }\n  }\n  return count;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n    std::stringstream ss(sentence);\n    std::string word;\n\n    auto is_prime = [](int n) {\n        if (n <= 1) return false;\n        if (n == 2) return true;\n        if (n % 2 == 0) return false;\n        for (int i = 3; i * i <= n; i += 2)\n            if (n % i == 0) return false;\n        return true;\n    };\n\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n    std::stringstream ss(sentence);\n    std::string word;\n\n    auto is_prime = [](int n) {\n        if (n <= 1) return false;\n        if (n == 2) return true;\n        if (n % 2 == 0) return false;\n        for(int i = 3; i * i <= n; i += 2) {\n            if(n % i == 0) return false;\n        }\n        return true;\n    };\n\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n    std::istringstream ss(sentence);\n    std::string word;\n\n    auto is_prime = [](int n) {\n        if (n <= 1) return false;\n        if (n == 2) return true;\n        if (n % 2 == 0) return false;\n        for(int i = 3; i * i <= n; i += 2) {\n            if(n % i == 0) return false;\n        }\n        return true;\n    };\n\n    while (ss >> word) {\n        if (is_prime(word.size())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n    std::istringstream iss(sentence);\n    std::vector<std::string> words((std::istream_iterator<std::string>(iss)),\n                                     std::istream_iterator<std::string>());\n\n    auto is_prime = [](int n) {\n        if (n <= 1) return false;\n        if (n == 2) return true;\n        if (n % 2 == 0) return false;\n        for (int i = 3; i * i <= n; i += 2) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    };\n\n    for (const auto &word : words) {\n        if (is_prime(word.size())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::istringstream iss(sentence);\n    std::string word, result = \"\";\n    auto is_prime = [](int n) {\n        if (n <= 1) return false;\n        if (n == 2) return true;\n        if (n % 2 == 0) return false;\n        for (int i = 3; i * i <= n; i += 2)\n            if (n % i == 0) return false;\n        return true;\n    };\n    while (iss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n    std::string word, result;\n    auto is_prime = [](int n) {\n        if (n <= 1) return false;\n        if (n == 2) return true;\n        if (n % 2 == 0) return false;\n        for (int i = 3; i * i <= n; i += 2)\n            if (n % i == 0) return false;\n        return true;\n    };\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n    std::istringstream iss(sentence);\n    std::vector<std::string> words((std::istream_iterator<std::string>(iss)), std::istream_iterator<std::string>());\n\n    auto is_prime = [](int n) {\n        if (n <= 1) return false;\n        if (n == 2) return true;\n        if (n % 2 == 0) return false;\n        for (int i = 3; i * i <= n; i += 2)\n            if (n % i == 0) return false;\n        return true;\n    };\n\n    for (const auto& word : words) {\n        if (is_prime(word.size())) {\n            result += word + \" \";\n        }\n    }\n\n    if (!result.empty()) {\n        result.pop_back(); // remove trailing space\n    }\n\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n    std::stringstream ss(sentence);\n    std::string word;\n\n    while (ss >> word) {\n        int len = word.length();\n        bool prime = true;\n\n        if (len < 2) prime = false;\n        for (int i = 2; i * i <= len; i++) {\n            if (len % i == 0) {\n                prime = false;\n                break;\n            }\n        }\n\n        if (prime) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n    std::string word;\n    std::string result = \"\";\n    auto is_prime = [](int n) {\n        if(n < 2) return false;\n        for(int i = 2; i * i <= n; i++) {\n            if(n % i == 0) return false;\n        }\n        return true;\n    };\n    while(ss >> word) {\n        if(is_prime(word.size())) {\n            if(!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n    std::string word, result = \"\";\n    \n    auto is_prime = [](int n) {\n        if (n <= 1) return false;\n        if (n == 2) return true;\n        if (n % 2 == 0) return false;\n        for(int i = 3; i * i <= n; i += 2) {\n            if(n % i == 0) return false;\n        }\n        return true;\n    };\n\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n    return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string,long> freq;\n  std::istringstream iss(test);\n  std::string word;\n  long maxCount = 0;\n\n  while (iss >> word) {\n    freq[word]++;\n    if (freq[word] > maxCount) {\n      maxCount = freq[word];\n    }\n  }\n\n  std::map<std::string,long> result;\n  for (auto &pair : freq) {\n    if (pair.second == maxCount) {\n      result.insert(pair);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string, long> count;\n  std::map<std::string, long> result;\n  std::stringstream ss(test);\n  std::string word;\n  long maxCount = 0;\n\n  while (ss >> word) {\n    count[word]++;\n    maxCount = std::max(maxCount, count[word]);\n  }\n\n  for (auto const &entry : count) {\n    if (entry.second == maxCount) {\n      result[entry.first] = maxCount;\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string,long> freq;\n  std::istringstream iss(test);\n  std::string word;\n  long max_freq = 0;\n\n  while (iss >> word) {\n    freq[word]++;\n    if (freq[word] > max_freq) {\n      max_freq = freq[word];\n    }\n  }\n\n  for (auto it = freq.begin(); it != freq.end(); ) {\n    if (it->second != max_freq) {\n      it = freq.erase(it);\n    } else {\n      ++it;\n    }\n  }\n\n  return freq;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string,long> freq;\n  std::stringstream ss(test);\n  std::string word;\n  long max_freq = 0;\n\n  while (ss >> word) {\n    freq[word]++;\n    if (freq[word] > max_freq)\n      max_freq = freq[word];\n  }\n\n  for (auto it = freq.begin(); it != freq.end(); ) {\n    if (it->second != max_freq)\n      it = freq.erase(it);\n    else\n      ++it;\n  }\n\n  return freq;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string,long> counts;\n  std::istringstream iss(test);\n  std::string word;\n\n  while (iss >> word) {\n    counts[word]++;\n  }\n\n  long max_count = 0;\n  for (auto const& pair: counts) {\n    if (pair.second > max_count) {\n      max_count = pair.second;\n    }\n  }\n\n  std::map<std::string,long> result;\n  for (auto const& pair: counts) {\n    if (pair.second == max_count) {\n      result.insert(pair);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string, long> freq;\n  std::stringstream ss(test);\n  std::string word;\n  long max_freq = 0;\n\n  while (ss >> word) {\n    freq[word]++;\n    max_freq = std::max(max_freq, freq[word]);\n  }\n\n  std::map<std::string, long> result;\n  for (auto &pair : freq) {\n    if (pair.second == max_freq) {\n      result.insert(pair);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string,long> count;\n  std::stringstream ss(test);\n  std::string word;\n  long maxCount = 0;\n\n  while (ss >> word) {\n    count[word]++;\n    if (count[word] > maxCount) {\n      maxCount = count[word];\n    }\n  }\n\n  std::map<std::string,long> result;\n  for (auto &pair : count) {\n    if (pair.second == maxCount) {\n      result.insert(pair);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string, long> map;\n  std::stringstream ss(test);\n  std::string word;\n  long max_count = 0;\n\n  while (ss >> word) {\n    map[word]++;\n    if (map[word] > max_count) {\n      max_count = map[word];\n    }\n  }\n\n  for (auto it = map.begin(); it != map.end();) {\n    if (it->second != max_count) {\n      it = map.erase(it);\n    } else {\n      ++it;\n    }\n  }\n\n  return map;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string,long> hist;\n  std::stringstream ss(test);\n  std::string word;\n  long max_count = 0;\n\n  while (ss >> word) {\n    hist[word]++;\n    if (hist[word] > max_count) {\n      max_count = hist[word];\n    }\n  }\n\n  for (auto it = hist.begin(); it != hist.end();) {\n    if (it->second < max_count) {\n      it = hist.erase(it);\n    } else {\n      ++it;\n    }\n  }\n\n  return hist;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> count;\n    std::istringstream iss(test);\n    std::string word;\n    long maxCount = 0;\n\n    while (iss >> word) {\n        count[word]++;\n        if (count[word] > maxCount) {\n            maxCount = count[word];\n        }\n    }\n\n    std::map<std::string,long> result;\n    for (auto &pair : count) {\n        if (pair.second == maxCount) {\n            result.insert(pair);\n        }\n    }\n\n    return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> result;\n  for (long i = 0; i < lst.size(); i++) {\n    std::vector<long> row = lst[i];\n    for (long j = 0; j < row.size(); j++) {\n      if (row[j] == x) {\n        result.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n  \n  // Sort by row in ascending order and column in descending order\n  std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n    if (std::get<0>(a) != std::get<0>(b)) {\n      return std::get<0>(a) < std::get<0>(b);\n    } else {\n      return std::get<1>(a) > std::get<1>(b);\n    }\n  });\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> result;\n  for (long i = 0; i < lst.size(); ++i) {\n    for (long j = 0; j < lst[i].size(); ++j) {\n      if (lst[i][j] == x) {\n        result.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n\n  std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n    if (std::get<0>(a) == std::get<0>(b)) {\n      return std::get<1>(a) > std::get<1>(b);\n    }\n    return std::get<0>(a) < std::get<0>(b);\n  });\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> result;\n  for(long i = 0; i < lst.size(); i++) {\n    for(long j = 0; j < lst[i].size(); j++) {\n      if(lst[i][j] == x) {\n        result.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n    if(std::get<0>(a) == std::get<0>(b)) {\n      return std::get<1>(a) > std::get<1>(b);\n    }\n    return std::get<0>(a) < std::get<0>(b);\n  });\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> res;\n  for (long i = 0; i < lst.size(); ++i) {\n    for (long j = 0; j < lst[i].size(); ++j) {\n      if (lst[i][j] == x) {\n        res.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n  \n  std::sort(res.begin(), res.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n    if (std::get<0>(a) == std::get<0>(b)) {\n      return std::get<1>(a) > std::get<1>(b);\n    }\n    return std::get<0>(a) < std::get<0>(b);\n  });\n  \n  return res;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> result;\n  for (long i = 0; i < lst.size(); i++) {\n    for (long j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == x) {\n        result.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n    if (std::get<0>(a) == std::get<0>(b)) {\n      return std::get<1>(a) > std::get<1>(b);\n    }\n    return std::get<0>(a) < std::get<0>(b);\n  });\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> result;\n  for (long i = 0; i < lst.size(); i++) {\n    std::vector<long> row = lst[i];\n    for (long j = 0; j < row.size(); j++) {\n      if (row[j] == x) {\n        result.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n\n  std::sort(result.begin(), result.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n    if (std::get<0>(a) == std::get<0>(b)) {\n      return std::get<1>(a) > std::get<1>(b);\n    }\n    return std::get<0>(a) < std::get<0>(b);\n  });\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> result;\n  for (long i = 0; i < lst.size(); i++) {\n    std::vector<long> row = lst[i];\n    for (long j = 0; j < row.size(); j++) {\n      if (row[j] == x) {\n        result.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n    if (std::get<0>(a) == std::get<0>(b)) {\n      return std::get<1>(a) > std::get<1>(b);\n    }\n    return std::get<0>(a) < std::get<0>(b);\n  });\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> result;\n\n  for (long i = 0; i < lst.size(); i++) {\n    for (long j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == x) {\n        result.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n\n  std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n    if (std::get<0>(a) == std::get<0>(b)) {\n      return std::get<1>(a) > std::get<1>(b);\n    }\n    return std::get<0>(a) < std::get<0>(b);\n  });\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> result;\n  for (long i = 0; i < lst.size(); i++) {\n    std::vector<long> row = lst[i];\n    for (long j = 0; j < row.size(); j++) {\n      if (row[j] == x) {\n        result.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n  \n  // Sort the result\n  std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n    if (std::get<0>(a) == std::get<0>(b)) {\n      return std::get<1>(a) > std::get<1>(b);\n    }\n    return std::get<0>(a) < std::get<0>(b);\n  });\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> coordinates;\n  for (long i = 0; i < lst.size(); i++) {\n    for (long j = 0; j < lst[i].size(); j++) {\n      if (lst[i][j] == x) {\n        coordinates.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n  \n  std::sort(coordinates.begin(), coordinates.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n    if (std::get<0>(a) == std::get<0>(b)) {\n      return std::get<1>(a) > std::get<1>(b);\n    }\n    return std::get<0>(a) < std::get<0>(b);\n  });\n  \n  return coordinates;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> result;\n  while(n != 1){\n    if(n % 2 != 0){\n      result.push_back(n);\n    }\n    n = n % 2 == 0 ? n/2 : 3*n + 1;\n  }\n  result.push_back(1);\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> collatz;\n  while (n != 1) {\n    if (n % 2 != 0) {\n      collatz.push_back(n);\n    }\n    n = (n % 2 == 0) ? n / 2 : 3 * n + 1;\n  }\n  collatz.push_back(1); // The sequence always ends with 1\n  std::sort(collatz.begin(), collatz.end());\n  return collatz;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> collatz;\n  while (n != 1) {\n    if (n % 2 != 0) {\n      collatz.push_back(n);\n    }\n    n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n  }\n  collatz.push_back(1);\n  std::sort(collatz.begin(), collatz.end());\n  return collatz;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> collatz;\n  while (n != 1) {\n    if (n % 2 != 0) {\n      collatz.push_back(n);\n    }\n    n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n  }\n  collatz.push_back(1);\n  std::sort(collatz.begin(), collatz.end());\n  return collatz;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> collatz;\n  while(n != 1) {\n    if(n % 2 != 0) {\n      collatz.push_back(n);\n    }\n    n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n  }\n  collatz.push_back(1);\n  std::sort(collatz.begin(), collatz.end());\n  return collatz;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> collatz;\n  while (n != 1) {\n    if (n % 2 != 0) {\n      collatz.push_back(n);\n    }\n    n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n  }\n  collatz.push_back(1);\n  std::sort(collatz.begin(), collatz.end());\n  return collatz;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> collatz;\n  while (n != 1) {\n    if (n % 2 != 0) {\n      collatz.push_back(n);\n    }\n    n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n  }\n  collatz.push_back(1);\n  std::sort(collatz.begin(), collatz.end());\n  return collatz;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> collatz;\n  while (n != 1) {\n    if (n % 2 != 0) {\n      collatz.push_back(n);\n    }\n    n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n  }\n  collatz.push_back(1);\n  std::sort(collatz.begin(), collatz.end());\n  return collatz;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> collatz;\n  while(n != 1) {\n    if(n % 2 != 0) {\n      collatz.push_back(n);\n    }\n    n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n  }\n  collatz.push_back(1);\n  std::sort(collatz.begin(), collatz.end());\n  return collatz;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> collatz;\n  while (n != 1) {\n    if (n % 2 != 0) {\n      collatz.push_back(n);\n    }\n    n = (n % 2 == 0) ? n / 2 : 3 * n + 1;\n  }\n  collatz.push_back(1); // the sequence will always reach 1\n  std::sort(collatz.begin(), collatz.end());\n  return collatz;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n  for (int i = arr.size() - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n  for (int i = arr.size() - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n  for (int i = arr.size() - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n  for (int i = arr.size() - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n  for (int i = arr.size() - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n  for (int i = arr.size() - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n  for (int i = arr.size() - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n  for (int i = arr.size() - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n  for (int i = arr.size() - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n  for (long i = arr.size() - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n  std::map<std::string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n  std::vector<std::pair<int, std::string>> num_vec;\n  std::istringstream iss(numbers);\n  std::string word;\n  while (iss >> word) {\n    num_vec.push_back(std::make_pair(num_map[word], word));\n  }\n  std::sort(num_vec.begin(), num_vec.end());\n  std::string sorted_numbers = \"\";\n  for (auto &pair : num_vec) {\n    sorted_numbers += pair.second + \" \";\n  }\n  sorted_numbers.pop_back();  // remove the last space\n  return sorted_numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::map<std::string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n    std::vector<std::pair<int, std::string>> num_vec;\n    std::stringstream ss(numbers);\n    std::string word;\n    while (ss >> word) {\n        num_vec.push_back({num_map[word], word});\n    }\n    std::sort(num_vec.begin(), num_vec.end());\n    std::string sorted_numbers;\n    for (auto& num : num_vec) {\n        sorted_numbers += num.second + \" \";\n    }\n    sorted_numbers.pop_back();  // remove the last space\n    return sorted_numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n  std::map<std::string, int> num_map = {\n    {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, \n    {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n  };\n  std::stringstream ss(numbers);\n  std::string word;\n  std::vector<std::pair<int, std::string>> num_vec;\n  while (ss >> word) {\n    num_vec.push_back({num_map[word], word});\n  }\n  sort(num_vec.begin(), num_vec.end());\n  std::string result = \"\";\n  for (auto &num : num_vec) {\n    result += num.second + \" \";\n  }\n  result.pop_back();  // remove the last space\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n  std::map<std::string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n  std::vector<std::pair<int, std::string>> num_vec;\n  std::istringstream iss(numbers);\n  std::string word;\n  while(iss >> word) {\n    num_vec.push_back({num_map[word], word});\n  }\n  sort(num_vec.begin(), num_vec.end());\n  std::string sorted_numbers;\n  for(auto& pair : num_vec) {\n    sorted_numbers += pair.second + \" \";\n  }\n  sorted_numbers.pop_back(); // remove the trailing space\n  return sorted_numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n  std::map<std::string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, \n                                        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n  std::vector<std::pair<int, std::string>> num_vec;\n  std::string word;\n  std::stringstream ss(numbers);\n\n  while (ss >> word) {\n    num_vec.push_back({num_map[word], word});\n  }\n\n  std::sort(num_vec.begin(), num_vec.end());\n\n  std::string result = \"\";\n  for (auto pair : num_vec) {\n    if (result != \"\") {\n      result += \" \";\n    }\n    result += pair.second;\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::map<std::string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n    std::vector<std::pair<int, std::string>> num_vec;\n    std::stringstream ss(numbers);\n    std::string word;\n    while (ss >> word) {\n        num_vec.push_back({num_map[word], word});\n    }\n    sort(num_vec.begin(), num_vec.end());\n    std::string result = \"\";\n    for (auto &pair : num_vec) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += pair.second;\n    }\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n  std::map<std::string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n  std::vector<std::pair<std::string, int>> num_vec;\n  std::stringstream ss(numbers);\n  std::string word;\n\n  while (ss >> word) {\n    num_vec.push_back({word, num_map[word]});\n  }\n\n  std::sort(num_vec.begin(), num_vec.end(), [](const std::pair<std::string, int>& a, const std::pair<std::string, int>& b) {\n    return a.second < b.second;\n  });\n\n  std::string sorted_numbers;\n  for (const auto& num : num_vec) {\n    sorted_numbers += num.first + \" \";\n  }\n\n  sorted_numbers.pop_back();  // remove the trailing space\n  return sorted_numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n  std::map<std::string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n                                        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n  std::istringstream iss(numbers);\n  std::vector<std::pair<int, std::string>> num_vec;\n  std::string word;\n  while (iss >> word) {\n    num_vec.push_back({num_map[word], word});\n  }\n  std::sort(num_vec.begin(), num_vec.end());\n  std::string sorted_numbers;\n  for (auto &pair : num_vec) {\n    if (!sorted_numbers.empty()) {\n      sorted_numbers += \" \";\n    }\n    sorted_numbers += pair.second;\n  }\n  return sorted_numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n  std::map<std::string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n  std::vector<std::pair<int, std::string>> num_vec;\n  std::stringstream ss(numbers);\n  std::string word;\n  \n  while (ss >> word) {\n    num_vec.push_back({num_map[word], word});\n  }\n  \n  std::sort(num_vec.begin(), num_vec.end());\n  \n  std::string sorted_numbers;\n  for (auto &num : num_vec) {\n    sorted_numbers += num.second + \" \";\n  }\n\n  sorted_numbers.pop_back(); // remove the trailing space\n  return sorted_numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n  std::map<std::string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n  std::vector<std::pair<int, std::string>> num_vec;\n  std::istringstream iss(numbers);\n  std::string word;\n  while (iss >> word) {\n    num_vec.push_back({num_map[word], word});\n  }\n  std::sort(num_vec.begin(), num_vec.end());\n  std::string result = \"\";\n  for (auto &num : num_vec) {\n    result += num.second + \" \";\n  }\n  result.pop_back(); // remove the last space\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n  std::string str = std::to_string(x);\n  int len = str.length();\n\n  if (shift > len) {\n    std::reverse(str.begin(), str.end());\n  } else {\n    std::rotate(str.rbegin(), str.rbegin() + shift, str.rend());\n  }\n\n  return str;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string str = std::to_string(x);\n    if (shift >= str.length()) {\n        std::reverse(str.begin(), str.end());\n    } else {\n        std::rotate(str.rbegin(), str.rbegin() + shift, str.rend());\n    }\n    return str;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n  std::string str = std::to_string(x);\n  long size = str.size();\n  if (shift > size) {\n    std::reverse(str.begin(), str.end());\n  } else {\n    std::rotate(str.rbegin(), str.rbegin() + shift, str.rend());\n  }\n  return str;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n  std::string s = std::to_string(x);\n  long len = s.length();\n  if (shift > len)\n    std::reverse(s.begin(), s.end());\n  else\n    std::rotate(s.rbegin(), s.rbegin() + shift, s.rend());\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n  std::string s = std::to_string(x);\n  long n = s.length();\n  if (shift > n) {\n    std::reverse(s.begin(), s.end());\n  } else {\n    std::rotate(s.rbegin(), s.rbegin() + shift, s.rend());\n  }\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n  std::string str = std::to_string(x);\n  long size = str.size();\n\n  if (shift > size) {\n    std::reverse(str.begin(), str.end());\n    return str;\n  }\n\n  std::rotate(str.begin(), str.begin() + size - shift, str.end());\n  return str;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n  std::string s = std::to_string(x);\n  long n = s.length();\n  if (shift > n) {\n    std::reverse(s.begin(), s.end());\n  } else {\n    std::rotate(s.rbegin(), s.rbegin() + shift, s.rend());\n  }\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string str = std::to_string(x);\n    int n = str.length();\n    if (shift > n) {\n        std::reverse(str.begin(), str.end());\n    } else {\n        std::rotate(str.rbegin(), str.rbegin() + shift, str.rend());\n    }\n    return str;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n  std::string s = std::to_string(x);\n  long n = s.size();\n  if (shift > n) {\n    std::reverse(s.begin(), s.end());\n  } else {\n    std::rotate(s.begin(), s.begin() + n - shift, s.end());\n  }\n  return s;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n  std::string str = std::to_string(x);\n  int n = str.size();\n  \n  if (shift > n) {\n    std::reverse(str.begin(), str.end());\n  } else {\n    std::rotate(str.rbegin(), str.rbegin() + shift, str.rend());\n  }\n  \n  return str;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (i % 3 == 0 && i % 4 != 0) {\n      sum += pow(lst[i], 2);\n    } else if (i % 4 == 0) {\n      sum += pow(lst[i], 3);\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (i % 3 == 0 && i % 4 != 0) {\n      sum += lst[i] * lst[i];\n    }\n    else if (i % 4 == 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n    else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (i % 3 == 0 && i % 4 != 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 == 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (i % 3 == 0 && i % 4 != 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 == 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (i % 3 == 0 && i % 4 != 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 == 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (i % 3 == 0 && i % 4 != 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 == 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (i % 3 == 0 && i % 4 != 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 == 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (i % 3 == 0 && i % 4 != 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 == 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (i % 3 == 0 && i % 4 != 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 == 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (i % 3 == 0 && i % 4 != 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4 == 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n  bool isPrime(long n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (long i = 3; i * i <= n; i += 2)\n      if (n % i == 0) return false;\n    return true;\n  }\n\n  long largestPrime = -1;\n  for (long num : lst) {\n    if (isPrime(num) && num > largestPrime) {\n      largestPrime = num;\n    }\n  }\n\n  long sum = 0;\n  while (largestPrime != 0) {\n    sum += largestPrime % 10;\n    largestPrime /= 10;\n  }\n\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n  auto is_prime = [](long n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (long i = 3; i * i <= n; i += 2) {\n      if (n % i == 0) return false;\n    }\n    return true;\n  };\n\n  long largest_prime = *std::max_element(lst.begin(), lst.end(), \n    [is_prime](long a, long b) { return is_prime(a) ? a < b : false; });\n\n  long sum_of_digits = 0;\n  while (largest_prime != 0) {\n    sum_of_digits += largest_prime % 10;\n    largest_prime /= 10;\n  }\n\n  return sum_of_digits;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n  auto is_prime = [](long n) {\n    if (n <= 1)\n      return false;\n    if (n == 2)\n      return true;\n    if (n % 2 == 0)\n      return false;\n    for (long i = 3; i * i <= n; i += 2)\n      if (n % i == 0)\n        return false;\n    return true;\n  };\n\n  long max_prime = 0;\n  for (long num : lst) {\n    if (is_prime(num) && num > max_prime) {\n      max_prime = num;\n    }\n  }\n\n  long sum = 0;\n  while (max_prime != 0) {\n    sum += max_prime % 10;\n    max_prime /= 10;\n  }\n\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n  long maxPrime = 0;\n  for (long num : lst) {\n    bool isPrime = true;\n    if (num <= 1) {\n      isPrime = false;\n    } else {\n      for (long i = 2; i * i <= num; i++) {\n        if (num % i == 0) {\n          isPrime = false;\n          break;\n        }\n      }\n    }\n    if (isPrime && num > maxPrime) {\n      maxPrime = num;\n    }\n  }\n  long sum = 0;\n  while (maxPrime != 0) {\n    sum += maxPrime % 10;\n    maxPrime /= 10;\n  }\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n  auto isPrime = [](long n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (long i = 3; i * i <= n; i += 2)\n      if (n % i == 0) return false;\n    return true;\n  };\n\n  long largestPrime = *std::max_element(lst.begin(), lst.end(), [&](long a, long b) {\n    return (!isPrime(a) || (isPrime(b) && a < b));\n  });\n\n  long sum = 0;\n  while (largestPrime != 0) {\n    sum += largestPrime % 10;\n    largestPrime /= 10;\n  }\n\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n  auto is_prime = [](long n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (long i = 3; i * i <= n; i += 2)\n      if (n % i == 0) return false;\n    return true;\n  };\n\n  long max_prime = *std::max_element(lst.begin(), lst.end(), [is_prime](long a, long b) {\n    if (is_prime(a) && is_prime(b)) return a < b;\n    if (is_prime(a)) return false;\n    return true;\n  });\n\n  long sum = 0;\n  while (max_prime != 0) {\n    sum += max_prime % 10;\n    max_prime /= 10;\n  }\n\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\nbool isPrime(long n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (long i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nlong sumOfDigits(long n) {\n    long sum = 0;\n    while (n != 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nlong maxPrime = -1;\nfor (long num : lst) {\n    if (isPrime(num) && num > maxPrime) {\n        maxPrime = num;\n    }\n}\nif (maxPrime == -1) {\n    return -1; // no prime number found\n} else {\n    return sumOfDigits(maxPrime);\n}\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\nbool isPrime(long n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (long i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nlong sumDigits(long n) {\n    long sum = 0;\n    while (n != 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nlong maxPrime = -1;\nfor (long num : lst) {\n    if (isPrime(num) && num > maxPrime) {\n        maxPrime = num;\n    }\n}\nif (maxPrime == -1) return -1; // No prime number found\nreturn sumDigits(maxPrime);",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n  auto is_prime = [](long n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (long i = 3; i * i <= n; i += 2)\n      if (n % i == 0) return false;\n    return true;\n  };\n\n  long largest_prime = *std::max_element(lst.begin(), lst.end(), \n    [is_prime](int a, int b) { return is_prime(a) ? a < b : false; });\n\n  long sum = 0;\n  while (largest_prime != 0) {\n    sum += largest_prime % 10;\n    largest_prime /= 10;\n  }\n\n  return sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n  long maxPrime = 0;\n  for (auto num : lst) {\n    if (isPrime(num) && num > maxPrime) {\n      maxPrime = num;\n    }\n  }\n  return sumOfDigits(maxPrime);\n}\n\nbool isPrime(long n) {\n  if (n <= 1) return false;\n  if (n == 2) return true;\n  if (n % 2 == 0) return false;\n  for (long i = 3; i * i <= n; i += 2) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nlong sumOfDigits(long n) {\n  long sum = 0;\n  while (n != 0) {\n    sum += n % 10;\n    n /= 10;\n  }\n  return sum;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n  long sum = 0;\n  long product = 1;\n  \n  for(auto num : numbers) {\n    sum += num;\n    product *= num;\n  }\n  \n  return std::make_tuple(sum, product);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n  long sum = 0;\n  long product = 1;\n  for (long number : numbers) {\n    sum += number;\n    product *= number;\n  }\n  return std::make_tuple(sum, product);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n  long sum = 0;\n  long product = 1;\n  \n  for(int i = 0; i < numbers.size(); i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  \n  return std::make_tuple(sum, product);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n  long sum = 0;\n  long product = 1;\n\n  for (long number : numbers) {\n    sum += number;\n    product *= number;\n  }\n\n  return std::make_tuple(sum, product);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n  long sum = 0;\n  long product = 1;\n\n  for(auto& num : numbers) {\n    sum += num;\n    product *= num;\n  }\n\n  return std::make_tuple(sum, product);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n  long sum = 0;\n  long product = 1;\n\n  for (auto& num : numbers) {\n    sum += num;\n    product *= num;\n  }\n\n  return std::make_tuple(sum, product);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n  long sum = 0;\n  long product = 1;\n  \n  for (long number : numbers) {\n    sum += number;\n    product *= number;\n  }\n  \n  return std::make_tuple(sum, product);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n  long sum = 0;\n  long product = 1;\n  \n  for(auto num : numbers) {\n    sum += num;\n    product *= num;\n  }\n  \n  return std::make_tuple(sum, product);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n  long sum = 0;\n  long product = 1;\n\n  for(auto num : numbers) {\n    sum += num;\n    product *= num;\n  }\n\n  return std::make_tuple(sum, product);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n  long sum = 0;\n  long product = 1;\n  for (int i = 0; i < numbers.size(); i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return std::make_tuple(sum, product);\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n  if (x > y) return -1;\n  if (y % 2 == 0) return y;\n  else if (y - 1 >= x) return y - 1;\n  return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n  if (x > y) return -1;\n  if (y % 2 == 0) return y;\n  if ((y - 1) >= x && (y - 1) % 2 == 0) return y - 1;\n  return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n  if (x > y) \n    return -1;\n  if (y % 2 == 0) \n    return y;\n  else if ((y - 1) >= x) \n    return y - 1;\n  else \n    return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n  for (long i = y; i >= x; i--) {\n    if (i % 2 == 0) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n  if (x > y) {\n    return -1;\n  }\n\n  if (y % 2 == 0) {\n    return y;\n  } else if (y - 1 >= x) {\n    return y - 1;\n  } else {\n    return -1;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n  if (x > y) return -1;\n  if (y % 2 == 0) return y;\n  if ((y - 1) >= x && (y - 1) % 2 == 0) return y - 1;\n  return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n  if (x > y) {\n    return -1;\n  }\n  if (y % 2 == 0) {\n    return y;\n  }\n  if ((y - 1) >= x && (y - 1) % 2 == 0) {\n    return y - 1;\n  }\n  return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n  if (x > y) return -1;\n  if (y % 2 == 0) return y;\n  if ((y - 1) >= x && (y - 1) % 2 == 0) return y - 1;\n  return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n  if (x > y) return -1;\n  if (y % 2 == 0) return y;\n  else if ((y - 1) >= x) return y - 1;\n  else return -1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n  if (x > y) return -1;\n  if (y % 2 == 0) return y;\n  else if (y - 1 >= x) return y - 1;\n  else return -1;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n  std::optional<long> max_negative = std::nullopt;\n  std::optional<long> min_positive = std::nullopt;\n\n  for (long num : lst) {\n    if (num < 0 && (!max_negative.has_value() || num > max_negative.value())) {\n      max_negative = num;\n    }\n    if (num > 0 && (!min_positive.has_value() || num < min_positive.value())) {\n      min_positive = num;\n    }\n  }\n\n  return std::make_tuple(max_negative, min_positive);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n  std::optional<long> largest_negative = std::nullopt;\n  std::optional<long> smallest_positive = std::nullopt;\n\n  for (const auto& num : lst) {\n    if (num < 0 && (!largest_negative || num > *largest_negative)) {\n      largest_negative = num;\n    }\n    if (num > 0 && (!smallest_positive || num < *smallest_positive)) {\n      smallest_positive = num;\n    }\n  }\n\n  return std::make_tuple(largest_negative, smallest_positive);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n  std::optional<long> largest_negative = std::nullopt;\n  std::optional<long> smallest_positive = std::nullopt;\n\n  for (const auto& num : lst) {\n    if (num < 0 && (!largest_negative || num > *largest_negative)) {\n      largest_negative = num;\n    }\n    if (num > 0 && (!smallest_positive || num < *smallest_positive)) {\n      smallest_positive = num;\n    }\n  }\n\n  return std::make_tuple(largest_negative, smallest_positive);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n  std::optional<long> largest_negative = std::nullopt;\n  std::optional<long> smallest_positive = std::nullopt;\n\n  for (long num : lst) {\n    if (num < 0 && (!largest_negative.has_value() || num > largest_negative.value())) {\n      largest_negative = num;\n    }\n    if (num > 0 && (!smallest_positive.has_value() || num < smallest_positive.value())) {\n      smallest_positive = num;\n    }\n  }\n\n  return std::make_tuple(largest_negative, smallest_positive);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n  std::optional<long> largest_negative = std::nullopt;\n  std::optional<long> smallest_positive = std::nullopt;\n\n  for (long num : lst) {\n    if (num < 0 && (!largest_negative.has_value() || num > largest_negative.value())) {\n      largest_negative = num;\n    } else if (num > 0 && (!smallest_positive.has_value() || num < smallest_positive.value())) {\n      smallest_positive = num;\n    }\n  }\n\n  return std::make_tuple(largest_negative, smallest_positive);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n  std::optional<long> largestNegative = std::nullopt;\n  std::optional<long> smallestPositive = std::nullopt;\n\n  for (const auto& num : lst) {\n    if (num < 0 && (!largestNegative || num > *largestNegative)) {\n      largestNegative = num;\n    } else if (num > 0 && (!smallestPositive || num < *smallestPositive)) {\n      smallestPositive = num;\n    }\n  }\n\n  return std::make_tuple(largestNegative, smallestPositive);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n  std::optional<long> largest_negative = std::nullopt;\n  std::optional<long> smallest_positive = std::nullopt;\n\n  for (const auto& num : lst) {\n    if (num < 0 && (!largest_negative || num > *largest_negative)) {\n      largest_negative = num;\n    }\n    if (num > 0 && (!smallest_positive || num < *smallest_positive)) {\n      smallest_positive = num;\n    }\n  }\n\n  return std::make_tuple(largest_negative, smallest_positive);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n  std::optional<long> largest_negative = std::nullopt;\n  std::optional<long> smallest_positive = std::nullopt;\n\n  for (long num : lst) {\n    if (num < 0 && (!largest_negative.has_value() || num > largest_negative.value())) {\n      largest_negative = num;\n    }\n    if (num > 0 && (!smallest_positive.has_value() || num < smallest_positive.value())) {\n      smallest_positive = num;\n    }\n  }\n\n  return std::make_tuple(largest_negative, smallest_positive);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n  std::optional<long> largest_negative = std::nullopt;\n  std::optional<long> smallest_positive = std::nullopt;\n\n  for (long num : lst) {\n    if (num < 0 && (!largest_negative.has_value() || num > largest_negative.value())) {\n      largest_negative = num;\n    }\n    if (num > 0 && (!smallest_positive.has_value() || num < smallest_positive.value())) {\n      smallest_positive = num;\n    }\n  }\n\n  return std::make_tuple(largest_negative, smallest_positive);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n  std::optional<long> smallest_positive = std::nullopt;\n  std::optional<long> largest_negative = std::nullopt;\n\n  for (long num : lst) {\n    if (num > 0) {\n      if (!smallest_positive.has_value() || num < smallest_positive.value()) {\n        smallest_positive = num;\n      }\n    } else if (num < 0) {\n      if (!largest_negative.has_value() || num > largest_negative.value()) {\n        largest_negative = num;\n      }\n    }\n  }\n\n  return std::make_tuple(largest_negative, smallest_positive);\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n  std::transform(string.begin(), string.end(), string.begin(), ::tolower);\n  std::set<char> distinct_characters(string.begin(), string.end());\n  return distinct_characters.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n  std::transform(string.begin(), string.end(), string.begin(), ::tolower);\n  std::set<char> distinct_chars(string.begin(), string.end());\n  return distinct_chars.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n  std::transform(string.begin(), string.end(), string.begin(), ::tolower);\n  std::unordered_set<char> distinct_chars(string.begin(), string.end());\n  return distinct_chars.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n  std::transform(string.begin(), string.end(), string.begin(), ::tolower);\n  std::set<char> distinct_chars(string.begin(), string.end());\n  return distinct_chars.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n  std::transform(string.begin(), string.end(), string.begin(), ::tolower);\n  std::unordered_set<char> distinct_chars(string.begin(), string.end());\n  return distinct_chars.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n  std::transform(string.begin(), string.end(), string.begin(), ::tolower);\n  std::set<char> distinct_characters(string.begin(), string.end());\n  return distinct_characters.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n  std::transform(string.begin(), string.end(), string.begin(), ::tolower);\n  std::set<char> distinct_chars(string.begin(), string.end());\n  return distinct_chars.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n  std::transform(string.begin(), string.end(), string.begin(), ::tolower);\n  std::set<char> distinct_chars(string.begin(), string.end());\n  return distinct_chars.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n  std::transform(string.begin(), string.end(), string.begin(), ::tolower);\n  std::set<char> distinct_characters(string.begin(), string.end());\n  return distinct_characters.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n  std::transform(string.begin(), string.end(), string.begin(), ::tolower);\n  std::set<char> distinct_characters(string.begin(), string.end());\n  return distinct_characters.size();\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  long stones = n;\n  for (long i = 0; i < n; i++) {\n    pile.push_back(stones);\n    if (stones % 2 == 0) {\n      stones += 2;\n    } else {\n      stones += 2;\n    }\n  }\n  return pile;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  long stones = n;\n  for (long i = 0; i < n; i++) {\n    pile.push_back(stones);\n    if (stones % 2 == 0) {\n      stones += 2;\n    } else {\n      stones += 2;\n    }\n  }\n  return pile;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  for (long i = 0; i < n; i++) {\n    pile.push_back(n + 2 * i);\n  }\n  return pile;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  for (long i = 0; i < n; i++) {\n    pile.push_back(n + 2*i);\n  }\n  return pile;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  long stones = n;\n  for (long i = 0; i < n; i++) {\n    pile.push_back(stones);\n    stones += (n % 2 == 0) ? 2 : 1;\n  }\n  return pile;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  long stones = n;\n  for (long i = 0; i < n; i++) {\n    pile.push_back(stones);\n    if (stones % 2 == 0) {\n      stones += 2;\n    } else {\n      stones += 2;\n    }\n  }\n  return pile;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  long stones = n;\n  for (long i = 0; i < n; i++) {\n    pile.push_back(stones);\n    if (stones % 2 == 0) {\n      stones += 2;\n    } else {\n      stones += 2;\n    }\n  }\n  return pile;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  long stones = n;\n  for (long i = 0; i < n; i++) {\n    pile.push_back(stones);\n    if (stones % 2 == 0) {\n      stones += 2;\n    } else {\n      stones += 2;\n    }\n  }\n  return pile;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  long stones = n;\n  for(int i = 0; i < n; i++) {\n    pile.push_back(stones);\n    if(n % 2 == 0) {\n      stones += 2;\n    } else {\n      stones += 2;\n    }\n  }\n  return pile;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  long stones = n;\n  for (long i = 0; i < n; i++) {\n    pile.push_back(stones);\n    if (stones % 2 == 0) {\n      stones += 2;\n    } else {\n      stones += 2;\n    }\n  }\n  return pile;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n  \n  long sum = 0;\n  int sign_product = 1;\n  \n  for (auto num : arr) {\n    sum += abs(num);\n    if (num < 0) {\n      sign_product *= -1;\n    } else if (num > 0) {\n      sign_product *= 1;\n    } else {\n      sign_product = 0;\n      break;\n    }\n  }\n  \n  return sum * sign_product;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n\n  long sum = 0;\n  int product = 1;\n  \n  for (auto &num : arr) {\n    sum += std::abs(num);\n    if (num < 0) {\n      product *= -1;\n    } else if (num > 0) {\n      product *= 1;\n    } else {\n      product *= 0;\n    }\n  }\n\n  return product * sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if(arr.empty()) {\n    return std::nullopt;\n  }\n  \n  long sum = 0;\n  long prod_signs = 1;\n  \n  for(auto num : arr) {\n    sum += abs(num);\n    if(num < 0) {\n      prod_signs *= -1;\n    } else if(num > 0) {\n      prod_signs *= 1;\n    } else {\n      prod_signs *= 0;\n    }\n  }\n  \n  return sum * prod_signs;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n\n  long sum = 0;\n  int sign_product = 1;\n\n  for (auto num : arr) {\n    sum += std::abs(num);\n\n    if (num > 0) {\n      sign_product *= 1;\n    } else if (num < 0) {\n      sign_product *= -1;\n    } else {\n      sign_product *= 0;\n    }\n  }\n\n  return sum * sign_product;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n\n  long sum = 0;\n  int product = 1;\n  for (auto num : arr) {\n    sum += abs(num);\n    if (num < 0) {\n      product *= -1;\n    } else if (num > 0) {\n      product *= 1;\n    } else {\n      product *= 0;\n    }\n  }\n  return sum * product;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n  \n  long sum = 0;\n  int sign_product = 1;\n  \n  for (auto num : arr) {\n    sum += abs(num);\n    if (num < 0) {\n      sign_product *= -1;\n    } else if (num > 0) {\n      sign_product *= 1;\n    } else {\n      sign_product = 0;\n      break;\n    }\n  }\n  \n  return sum * sign_product;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n\n  long sum = 0;\n  int sign = 1;\n\n  for (auto num : arr) {\n    if (num < 0) {\n      sign *= -1;\n      sum += abs(num);\n    } else if (num > 0) {\n      sum += num;\n    } else {\n      sign = 0;\n      break;\n    }\n  }\n\n  return sum * sign;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n  \n  long sum = 0;\n  long sign_product = 1;\n  \n  for (auto num : arr) {\n    sum += abs(num);\n    if (num < 0) {\n      sign_product *= -1;\n    } else if (num > 0) {\n      sign_product *= 1;\n    } else {\n      sign_product = 0;\n      break;\n    }\n  }\n  \n  return sum * sign_product;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n\n  long sum = 0;\n  int sign_product = 1;\n\n  for (auto num : arr) {\n    sum += abs(num);\n    if (num < 0) {\n      sign_product *= -1;\n    } else if (num > 0) {\n      sign_product *= 1;\n    } else {\n      sign_product = 0;\n      break;\n    }\n  }\n\n  return sum * sign_product;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if(arr.empty())\n    return std::nullopt;\n\n  long sum = 0;\n  int sign_product = 1;\n\n  for(auto& num : arr) {\n    sum += abs(num);\n    if(num < 0)\n      sign_product *= -1;\n    else if(num > 0)\n      sign_product *= 1;\n    else\n      sign_product *= 0;\n  }\n\n  return sum * sign_product;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n  long minSum = nums[0];\n  long currentSum = nums[0];\n\n  for (int i = 1; i < nums.size(); i++) {\n    currentSum = std::min(nums[i], currentSum + nums[i]);\n    minSum = std::min(minSum, currentSum);\n  }\n\n  return minSum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n  long min_so_far = nums[0];\n  long curr_min = nums[0];\n\n  for (int i = 1; i < nums.size(); i++) {\n    curr_min = std::min(nums[i], curr_min + nums[i]);\n    min_so_far = std::min(min_so_far, curr_min);\n  }\n\n  return min_so_far;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n  long minSum = nums[0];\n  long currSum = nums[0];\n\n  for (int i = 1; i < nums.size(); i++) {\n    currSum = std::min(nums[i], currSum + nums[i]);\n    minSum = std::min(minSum, currSum);\n  }\n\n  return minSum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n  long min_so_far = nums[0];\n  long curr_min = nums[0];\n\n  for (int i = 1; i < nums.size(); i++) {\n    curr_min = std::min(nums[i], curr_min + nums[i]);\n    min_so_far = std::min(min_so_far, curr_min);\n  }\n\n  return min_so_far;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n  long minSum = nums[0];\n  long currentSum = nums[0];\n\n  for (int i = 1; i < nums.size(); i++) {\n    currentSum = std::min(nums[i], currentSum + nums[i]);\n    minSum = std::min(minSum, currentSum);\n  }\n\n  return minSum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n  long min_sum = nums[0];\n  long curr_sum = nums[0];\n\n  for (int i = 1; i < nums.size(); i++) {\n    curr_sum = std::min(nums[i], curr_sum + nums[i]);\n    min_sum = std::min(min_sum, curr_sum);\n  }\n\n  return min_sum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n  long minSum = nums[0];\n  long currSum = nums[0];\n  \n  for (int i = 1; i < nums.size(); i++) {\n    currSum = std::min(nums[i], currSum + nums[i]);\n    minSum = std::min(minSum, currSum);\n  }\n  \n  return minSum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n  long minSum = nums[0];\n  long currentSum = nums[0];\n\n  for (int i = 1; i < nums.size(); i++) {\n    currentSum = std::min(nums[i], currentSum + nums[i]);\n    minSum = std::min(minSum, currentSum);\n  }\n\n  return minSum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n  long minSum = nums[0];\n  long currentSum = nums[0];\n  \n  for (int i = 1; i < nums.size(); i++) {\n    currentSum = std::min(nums[i], currentSum + nums[i]);\n    minSum = std::min(minSum, currentSum);\n  }\n  \n  return minSum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n  long min_so_far = nums[0];\n  long curr_min = nums[0];\n\n  for (int i = 1; i < nums.size(); i++) {\n    curr_min = std::min(nums[i], curr_min + nums[i]);\n    min_so_far = std::min(min_so_far, curr_min);\n  }\n\n  return min_so_far;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n  std::string result = \"\";\n  for (long i = 0; i <= n; i++) {\n    result += std::to_string(i);\n    if (i != n) {\n      result += \" \";\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n  std::string result = \"\";\n  for (long i = 0; i <= n; i++) {\n    result += std::to_string(i) + \" \";\n  }\n  result.pop_back(); // to remove the last space\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n  std::string result = \"\";\n  for (long i = 0; i <= n; i++) {\n    result += std::to_string(i) + \" \";\n  }\n  result.pop_back(); // remove the last space\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n  std::string result = \"\";\n  for (long i = 0; i <= n; i++) {\n    result += std::to_string(i) + \" \";\n  }\n  result.pop_back(); // remove the last space\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n  std::string result = \"\";\n  for (long i = 0; i <= n; i++) {\n    result += std::to_string(i) + \" \";\n  }\n  result.pop_back(); // remove the trailing space\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n  std::string result = \"\";\n  for(long i = 0; i <= n; i++) {\n    result += std::to_string(i) + \" \";\n  }\n  result.pop_back(); // remove the trailing space\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n  std::string result = \"\";\n  for (long i = 0; i <= n; i++) {\n    result += std::to_string(i) + \" \";\n  }\n  result.pop_back(); // remove the trailing space\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n  std::string result = \"\";\n  for (long i = 0; i <= n; i++) {\n    result += std::to_string(i) + \" \";\n  }\n  result.pop_back(); // remove the trailing space\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n  std::string result = \"\";\n  for (long i = 0; i <= n; i++) {\n    result += std::to_string(i) + \" \";\n  }\n  result.pop_back(); // remove the trailing space\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n  std::string result = \"\";\n  for(long i = 0; i <= n; i++) {\n    result += std::to_string(i) + \" \";\n  }\n  result.pop_back(); // remove the last space\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n  for (int i = 0; i < b.size(); i++) {\n    std::rotate(b.begin(), b.begin() + 1, b.end());\n    if (a.find(b) != std::string::npos) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n  int len_a = a.length();\n  int len_b = b.length();\n  if(len_a < len_b) return false;\n\n  a = a + a; // Concatenate the string to itself\n  for(int i = 0; i < len_b; i++) {\n    std::string temp = b.substr(i, len_b-i) + b.substr(0, i);\n    if(a.find(temp) != std::string::npos) return true;\n  }\n\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n  std::string temp = b + b;\n  return (temp.find(a) != std::string::npos);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n  std::string temp = b + b;\n  return temp.find(a) != std::string::npos;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n  std::string temp = b + b;\n  return (temp.find(a) != std::string::npos);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n  int n = b.length();\n  std::string temp = b + b;\n  for (int i = 0; i < n; i++) {\n    std::string rotation = temp.substr(i, n);\n    if (a.find(rotation) != std::string::npos) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n  std::string temp = b + b;\n  if (temp.find(a) != std::string::npos) {\n    return true;\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n  std::string temp = b + b;\n  return (temp.find(a) != std::string::npos);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    std::string temp = b + b;\n    if (temp.find(a) != std::string::npos) {\n        return true;\n    }\n    return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n  if (a.size() < b.size()) return false;\n  b += b; // concatenate b with itself to handle rotations\n  return (b.find(a) != std::string::npos);\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n  bool increasing = true;\n  bool decreasing = true;\n\n  for(int i = 0; i < l.size() - 1; ++i) {\n    if(l[i] > l[i+1]) {\n      increasing = false;\n    }\n    if(l[i] < l[i+1]) {\n      decreasing = false;\n    }\n  }\n\n  return increasing || decreasing;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n  if(l.size() <= 2) return true;\n  \n  bool isIncreasing = l[1] > l[0];\n  \n  for(int i = 2; i < l.size(); i++) {\n    if(isIncreasing) {\n      if(l[i] < l[i-1]) return false;\n    } else {\n      if(l[i] > l[i-1]) return false;\n    }\n  }\n  \n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n  if(l.size() <= 2) return true;\n\n  bool is_increasing = l[1] > l[0];\n  for(int i = 2; i < l.size(); i++) {\n    if(is_increasing) {\n      if(l[i] < l[i-1]) return false;\n    } else {\n      if(l[i] > l[i-1]) return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n  if (l.size() <= 2) return true;\n\n  bool isIncreasing = l[1] > l[0];\n  for (int i = 2; i < l.size(); i++) {\n    if (isIncreasing) {\n      if (l[i] < l[i-1]) return false;\n    } else {\n      if (l[i] > l[i-1]) return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n  if(l.size() <= 2) return true;\n\n  bool isIncreasing = l[1] > l[0];\n  for(int i = 2; i < l.size(); i++) {\n    if(isIncreasing) {\n      if(l[i] < l[i-1]) return false;\n    } else {\n      if(l[i] > l[i-1]) return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n  bool increasing = true;\n  bool decreasing = true;\n\n  for (int i = 0; i < l.size() - 1; ++i) {\n    if (l[i] > l[i+1]) {\n      increasing = false;\n    }\n    if (l[i] < l[i+1]) {\n      decreasing = false;\n    }\n  }\n\n  return increasing || decreasing;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n  bool increasing = true;\n  bool decreasing = true;\n\n  for (int i = 0; i < l.size() - 1; ++i) {\n    if (l[i] > l[i + 1])\n      increasing = false;\n    if (l[i] < l[i + 1])\n      decreasing = false;\n  }\n\n  return increasing || decreasing;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n  bool increasing = true;\n  bool decreasing = true;\n\n  for (int i = 0; i < l.size() - 1; i++) {\n    if (l[i] > l[i+1]) {\n      increasing = false;\n    }\n    if (l[i] < l[i+1]) {\n      decreasing = false;\n    }\n  }\n\n  return increasing || decreasing;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n  if(l.size() <= 2) return true;\n  \n  bool isIncreasing = l[1] > l[0];\n  \n  for(int i = 2; i < l.size(); i++) {\n    if(isIncreasing) {\n      if(l[i] < l[i-1]) return false;\n    } else {\n      if(l[i] > l[i-1]) return false;\n    }\n  }\n  \n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n  if(l.size() <= 2)\n    return true;\n\n  bool isIncreasing = l[1] > l[0];\n\n  for(int i = 2; i < l.size(); i++) {\n    if(isIncreasing) {\n      if(l[i] < l[i-1])\n        return false;\n    } else {\n      if(l[i] > l[i-1])\n        return false;\n    }\n  }\n\n  return true;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n\n  std::string longest_string = strings[0];\n\n  for (const auto& str : strings) {\n    if (str.length() > longest_string.length()) {\n      longest_string = str;\n    }\n  }\n\n  return longest_string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n\n  std::string longest_string = strings[0];\n\n  for (const auto& str : strings) {\n    if (str.length() > longest_string.length()) {\n      longest_string = str;\n    }\n  }\n\n  return longest_string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n\n  std::string longestString = strings[0];\n  for (const auto& str : strings) {\n    if (str.length() > longestString.length()) {\n      longestString = str;\n    }\n  }\n\n  return longestString;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if(strings.empty()) {\n    return std::nullopt;\n  }\n\n  std::string longest_string = strings[0];\n\n  for(const auto& str : strings) {\n    if(str.length() > longest_string.length()) {\n      longest_string = str;\n    }\n  }\n\n  return longest_string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if(strings.empty()) {\n    return std::nullopt;\n  }\n\n  std::string longest_string = strings[0];\n  for(const auto& str : strings) {\n    if(str.length() > longest_string.length()) {\n      longest_string = str;\n    }\n  }\n\n  return longest_string;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n\n  std::string longestString = strings[0];\n  for (const auto& str : strings) {\n    if (str.length() > longestString.length()) {\n      longestString = str;\n    }\n  }\n\n  return longestString;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n\n  std::string longest_str = strings[0];\n  for (const auto& str : strings) {\n    if (str.length() > longest_str.length()) {\n      longest_str = str;\n    }\n  }\n\n  return longest_str;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longestString = strings[0];\n  for (const auto& str : strings) {\n    if (str.length() > longestString.length()) {\n      longestString = str;\n    }\n  }\n  return longestString;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n  \n  std::string longest = strings[0];\n  for (const auto& str : strings) {\n    if (str.length() > longest.length()) {\n      longest = str;\n    }\n  }\n  \n  return longest;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n\n  std::string longestStr = strings[0];\n\n  for (const auto& str : strings) {\n    if (str.length() > longestStr.length()) {\n      longestStr = str;\n    }\n  }\n\n  return longestStr;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n  for (long num : l) {\n    if (num >= t) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n  for (long num : l) {\n    if (num >= t) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n  for (long i : l) {\n    if (i >= t) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n  for (long num : l) {\n    if (num >= t) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n  for (long num : l) {\n    if (num >= t) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n  for (long num : l) {\n    if (num >= t) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n  for (int i = 0; i < l.size(); i++) {\n    if (l[i] >= t) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n  for (int i = 0; i < l.size(); i++) {\n    if (l[i] >= t) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n  for (long num : l) {\n    if (num >= t) {\n      return false;\n    }\n  }\n  return true;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n  for (int i = 0; i < l.size(); i++) {\n    if (l[i] >= t) {\n      return false;\n    }\n  }\n  return true;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    std::vector<int> prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int count = 0;\n    for (int i = 0; i < prime.size(); i++) {\n        while (a % prime[i] == 0) {\n            a /= prime[i];\n            count++;\n        }\n    }\n    if (count == 3 && a == 1) {\n        return true;\n    }\n    return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int count = 0;\n    for (int i = 0; i < primes.size(); i++) {\n        while (a % primes[i] == 0) {\n            a /= primes[i];\n            count++;\n        }\n    }\n    if (count == 3 && a == 1) {\n        return true;\n    }\n    return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    std::vector<int> prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int count = 0;\n    for (int i = 0; i < prime.size(); i++) {\n        while (a % prime[i] == 0) {\n            a /= prime[i];\n            count++;\n        }\n    }\n    return (count == 3 && a == 1);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n  std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n  int count = 0;\n  for (int i = 0; i < primes.size(); i++) {\n    while (a % primes[i] == 0) {\n      a /= primes[i];\n      count++;\n    }\n  }\n  if (count == 3 && a == 1) {\n    return true;\n  } else {\n    return false;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int count = 0;\n    for (int i = 0; i < primes.size(); i++) {\n        while (a % primes[i] == 0) {\n            a = a / primes[i];\n            count++;\n        }\n    }\n    if (count == 3 && a == 1) {\n        return true;\n    } else {\n        return false;\n    }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int count = 0;\n    for (int i = 0; i < primes.size(); i++) {\n        while (a % primes[i] == 0) {\n            a /= primes[i];\n            count++;\n        }\n    }\n    if (count == 3 && a == 1) {\n        return true;\n    } else {\n        return false;\n    }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int count = 0;\n\n    for (int i = 0; i < primes.size(); i++) {\n        while (a % primes[i] == 0) {\n            a /= primes[i];\n            count++;\n        }\n    }\n\n    if (count == 3 && a == 1) {\n        return true;\n    } else {\n        return false;\n    }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int count = 0;\n    for (int prime : primes) {\n        while (a % prime == 0) {\n            a /= prime;\n            count++;\n        }\n    }\n    return count == 3 && a == 1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    std::vector<int> prime_factors;\n    for (int i = 2; a > 1 && i < 100; i++) {\n        while (a % i == 0) {\n            prime_factors.push_back(i);\n            a /= i;\n        }\n    }\n    return prime_factors.size() == 3;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int count = 0;\n    for (int i = 0; i < primes.size(); i++) {\n        while (a % primes[i] == 0) {\n            a = a / primes[i];\n            count++;\n        }\n    }\n    if (count == 3 && a == 1) {\n        return true;\n    } else {\n        return false;\n    }\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n  std::vector<long> positive_numbers;\n  for (int i = 0; i < l.size(); i++) {\n    if (l[i] > 0) {\n      positive_numbers.push_back(l[i]);\n    }\n  }\n  return positive_numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n  std::vector<long> positive_numbers;\n  for (long i : l) {\n    if (i > 0) {\n      positive_numbers.push_back(i);\n    }\n  }\n  return positive_numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n  std::vector<long> positive_numbers;\n  for (long i : l) {\n    if (i > 0) {\n      positive_numbers.push_back(i);\n    }\n  }\n  return positive_numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n  std::vector<long> positive_numbers;\n  for (long num : l) {\n    if (num > 0) {\n      positive_numbers.push_back(num);\n    }\n  }\n  return positive_numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n  std::vector<long> positive;\n  for (long i : l) {\n    if (i > 0) {\n      positive.push_back(i);\n    }\n  }\n  return positive;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n  std::vector<long> positive_nums;\n  for (long num : l) {\n    if (num > 0) {\n      positive_nums.push_back(num);\n    }\n  }\n  return positive_nums;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n  std::vector<long> positive;\n  for (long i : l) {\n    if (i > 0) {\n      positive.push_back(i);\n    }\n  }\n  return positive;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n  std::vector<long> positive;\n  for (long i : l) {\n    if (i > 0) {\n      positive.push_back(i);\n    }\n  }\n  return positive;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n  std::vector<long> result;\n  for(long i : l) {\n    if(i > 0) {\n      result.push_back(i);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n  std::vector<long> result;\n  for (long i : l) {\n    if (i > 0) {\n      result.push_back(i);\n    }\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n  std::vector<long> divisible;\n  for (int i = 0; i < l.size(); i++) {\n    if (i % 3 == 0) {\n      divisible.push_back(l[i]);\n    }\n  }\n  \n  std::sort(divisible.begin(), divisible.end());\n  \n  int j = 0;\n  for (int i = 0; i < l.size(); i++) {\n    if (i % 3 == 0) {\n      l[i] = divisible[j++];\n    }\n  }\n  \n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n  std::vector<long> thirdIndices;\n  for (int i = 0; i < l.size(); i += 3) {\n    thirdIndices.push_back(l[i]);\n  }\n  std::sort(thirdIndices.begin(), thirdIndices.end());\n  \n  int j = 0;\n  for (int i = 0; i < l.size(); i += 3) {\n    l[i] = thirdIndices[j];\n    j++;\n  }\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n  std::vector<long> thirds;\n  for (int i = 0; i < l.size(); i += 3) {\n    thirds.push_back(l[i]);\n  }\n  std::sort(thirds.begin(), thirds.end());\n\n  int j = 0;\n  for (int i = 0; i < l.size(); i += 3) {\n    l[i] = thirds[j++];\n  }\n\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n  std::vector<long> divisible_by_three;\n  for (int i = 0; i < l.size(); i += 3) {\n    divisible_by_three.push_back(l[i]);\n  }\n  std::sort(divisible_by_three.begin(), divisible_by_three.end());\n  int j = 0;\n  for (int i = 0; i < l.size(); i += 3) {\n    l[i] = divisible_by_three[j++];\n  }\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n  std::vector<long> divisible_by_three;\n  for (int i = 0; i < l.size(); i += 3) {\n    divisible_by_three.push_back(l[i]);\n  }\n  \n  std::sort(divisible_by_three.begin(), divisible_by_three.end());\n  \n  int j = 0;\n  for (int i = 0; i < l.size(); i += 3) {\n    l[i] = divisible_by_three[j++];\n  }\n  \n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n  std::vector<long> divisible_by_three;\n  for (int i = 0; i < l.size(); i += 3) {\n    divisible_by_three.push_back(l[i]);\n  }\n\n  std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n  int j = 0;\n  for (int i = 0; i < l.size(); i += 3) {\n    l[i] = divisible_by_three[j++];\n  }\n\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n  std::vector<long> divisible_by_three;\n  for (int i = 0; i < l.size(); i += 3) {\n    divisible_by_three.push_back(l[i]);\n  }\n  \n  std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n  int j = 0;\n  for (int i = 0; i < l.size(); i += 3) {\n    l[i] = divisible_by_three[j++];\n  }\n\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n  std::vector<long> third;\n  for (int i = 0; i < l.size(); i += 3) {\n    third.push_back(l[i]);\n  }\n  std::sort(third.begin(), third.end());\n  int j = 0;\n  for (int i = 0; i < l.size(); i += 3) {\n    l[i] = third[j++];\n  }\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n  std::vector<long> divisible_by_three;\n  for (int i = 0; i < l.size(); i += 3) {\n    divisible_by_three.push_back(l[i]);\n  }\n  \n  std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n  int j = 0;\n  for (int i = 0; i < l.size(); i += 3) {\n    l[i] = divisible_by_three[j++];\n  }\n\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n  std::vector<long> third_values;\n  for (int i = 0; i < l.size(); i += 3) {\n    third_values.push_back(l[i]);\n  }\n  \n  std::sort(third_values.begin(), third_values.end());\n\n  for (int i = 0, j = 0; i < l.size(); i += 3, ++j) {\n    l[i] = third_values[j];\n  }\n  \n  return l;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n  std::stringstream ss(paren_string);\n  std::string group;\n\n  while(std::getline(ss, group, ' ')) {\n    long max_depth = 0;\n    long current_depth = 0;\n    for(char ch : group) {\n      if(ch == '(') {\n        current_depth++;\n        if(current_depth > max_depth) {\n          max_depth = current_depth;\n        }\n      } else if(ch == ')') {\n        if(current_depth > 0) {\n          current_depth--;\n        }\n      }\n    }\n    result.push_back(max_depth);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n  std::stringstream ss(paren_string);\n  std::string temp;\n  \n  while (ss >> temp) {\n    long maxDepth = 0, currentDepth = 0;\n    for (char c : temp) {\n      if (c == '(') {\n        currentDepth++;\n        maxDepth = std::max(maxDepth, currentDepth);\n      } else if (c == ')') {\n        if (currentDepth > 0) {\n          currentDepth--;\n        }\n      }\n    }\n    result.push_back(maxDepth);\n  }\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n  std::stringstream ss(paren_string);\n  std::string group;\n\n  while (ss >> group) {\n    long maxDepth = 0, currentDepth = 0;\n    for (char c : group) {\n      if (c == '(') {\n        currentDepth++;\n        if (currentDepth > maxDepth) {\n          maxDepth = currentDepth;\n        }\n      } else if (c == ')') {\n        if (currentDepth > 0) {\n          currentDepth--;\n        }\n      }\n    }\n    result.push_back(maxDepth);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n    std::string group;\n    \n    while (ss >> group) {\n        long max_depth = 0, current_depth = 0;\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = std::max(max_depth, current_depth);\n            } else if (c == ')') {\n                if (current_depth > 0) {\n                    current_depth--;\n                }\n            }\n        }\n        result.push_back(max_depth);\n    }\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n    std::string group;\n\n    while (ss >> group) {\n        long max_depth = 0;\n        long current_depth = 0;\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = std::max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        result.push_back(max_depth);\n    }\n\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n  std::stringstream ss(paren_string);\n  std::string group;\n\n  while (std::getline(ss, group, ' ')) {\n    long max_depth = 0, current_depth = 0;\n    for (char c : group) {\n      if (c == '(') {\n        current_depth++;\n        if (current_depth > max_depth) {\n          max_depth = current_depth;\n        }\n      } else if (c == ')') {\n        current_depth--;\n      }\n    }\n    result.push_back(max_depth);\n  }\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n    std::string group;\n    while (ss >> group) {\n        long max_depth = 0, current_depth = 0;\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                if (current_depth > max_depth)\n                    max_depth = current_depth;\n            } else if (c == ')') {\n                if (current_depth > 0)\n                    current_depth--;\n            }\n        }\n        result.push_back(max_depth);\n    }\n    return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n  std::stringstream ss(paren_string);\n  std::string group;\n\n  while (ss >> group) {\n    long max_depth = 0;\n    long current_depth = 0;\n    for (char c : group) {\n      if (c == '(') {\n        current_depth++;\n        max_depth = std::max(max_depth, current_depth);\n      } else if (c == ')') {\n        current_depth--;\n      }\n    }\n    result.push_back(max_depth);\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n  std::stringstream ss(paren_string);\n  std::string group;\n  \n  while (ss >> group) {\n    long maxDepth = 0, currentDepth = 0;\n    for (char c : group) {\n      if (c == '(') {\n        currentDepth++;\n        if (currentDepth > maxDepth) {\n          maxDepth = currentDepth;\n        }\n      } else if (c == ')') {\n        if (currentDepth > 0) {\n          currentDepth--;\n        }\n      }\n    }\n    result.push_back(maxDepth);\n  }\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n  std::stringstream ss(paren_string);\n  std::string token;\n\n  while (getline(ss, token, ' ')) {\n    long max_depth = 0;\n    long current_depth = 0;\n    for (char c : token) {\n      if (c == '(') {\n        current_depth++;\n        if (current_depth > max_depth) {\n          max_depth = current_depth;\n        }\n      } else if (c == ')') {\n        current_depth--;\n      }\n    }\n    result.push_back(max_depth);\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n  return 0.5f * a * h;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n  return 0.5f * a * h;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n  return 0.5 * a * h;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n  return 0.5 * a * h;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n  return 0.5 * a * h;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n  return 0.5f * a * h;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n  return 0.5f * a * h;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n  return 0.5 * a * h;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n  return 0.5f * a * h;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n  return 0.5 * a * h;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n  long unitA = abs(a) % 10;\n  long unitB = abs(b) % 10;\n  return unitA * unitB;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n  long unit_a = abs(a) % 10;\n  long unit_b = abs(b) % 10;\n  return unit_a * unit_b;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n  long unitDigitA = abs(a) % 10;\n  long unitDigitB = abs(b) % 10;\n  \n  return unitDigitA * unitDigitB;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n  long unitDigitA = abs(a % 10);\n  long unitDigitB = abs(b % 10);\n  return unitDigitA * unitDigitB;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n  long unit_digit_a = abs(a % 10);\n  long unit_digit_b = abs(b % 10);\n  return unit_digit_a * unit_digit_b;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n  long unit_a = abs(a % 10);\n  long unit_b = abs(b % 10);\n  return unit_a * unit_b;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n  long unit_digit_a = std::abs(a % 10);\n  long unit_digit_b = std::abs(b % 10);\n  return unit_digit_a * unit_digit_b;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n  long lastDigitA = abs(a % 10);\n  long lastDigitB = abs(b % 10);\n  return lastDigitA * lastDigitB;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n  long unitDigitA = abs(a) % 10;\n  long unitDigitB = abs(b) % 10;\n  return unitDigitA * unitDigitB;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n  long lastDigitA = abs(a % 10);\n  long lastDigitB = abs(b % 10);\n  return lastDigitA * lastDigitB;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0.0f;\n  for (auto& num : numbers) {\n    sum += num;\n  }\n  float mean = sum / numbers.size();\n\n  float mad = 0.0f;\n  for (auto& num : numbers) {\n    mad += std::abs(num - mean);\n  }\n  return mad / numbers.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0.0f;\n  for (auto &num : numbers) {\n    sum += num;\n  }\n\n  float mean = sum / numbers.size();\n\n  float mad = 0.0f;\n  for (auto &num : numbers) {\n    mad += std::abs(num - mean);\n  }\n\n  return mad / numbers.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0.0f;\n  float mean = 0.0f;\n  float mad = 0.0f;\n\n  for (auto& num : numbers) {\n    sum += num;\n  }\n\n  mean = sum / numbers.size();\n\n  for (auto& num : numbers) {\n    mad += std::abs(num - mean);\n  }\n\n  return mad / numbers.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0;\n  for (int i = 0; i < numbers.size(); i++) {\n    sum += numbers[i];\n  }\n  float mean = sum / numbers.size();\n\n  float mad = 0;\n  for (int i = 0; i < numbers.size(); i++) {\n    mad += abs(numbers[i] - mean);\n  }\n\n  return mad / numbers.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0;\n  for (int i = 0; i < numbers.size(); i++) {\n    sum += numbers[i];\n  }\n  float mean = sum / numbers.size();\n\n  float mad = 0;\n  for (int i = 0; i < numbers.size(); i++) {\n    mad += std::abs(numbers[i] - mean);\n  }\n  return mad / numbers.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0.0f;\n  for (int i = 0; i < numbers.size(); i++) {\n    sum += numbers[i];\n  }\n  float mean = sum / numbers.size();\n\n  float mad = 0.0f;\n  for (int i = 0; i < numbers.size(); i++) {\n    mad += abs(numbers[i] - mean);\n  }\n  return mad / numbers.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0.0f;\n  float mean;\n  float mad = 0.0f;\n\n  for (int i = 0; i < numbers.size(); i++) {\n    sum += numbers[i];\n  }\n  \n  mean = sum / numbers.size();\n\n  for (int i = 0; i < numbers.size(); i++) {\n    mad += abs(numbers[i] - mean);\n  }\n\n  return mad / numbers.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0.0f;\n  float mean = 0.0f;\n  float mad = 0.0f;\n\n  for (auto &num : numbers) {\n    sum += num;\n  }\n\n  mean = sum / numbers.size();\n\n  for (auto &num : numbers) {\n    mad += std::abs(num - mean);\n  }\n\n  return mad / numbers.size();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0.0f;\n  float mean = 0.0f;\n  float mad = 0.0f;\n\n  // Calculate mean\n  for (int i = 0; i < numbers.size(); i++) {\n    sum += numbers[i];\n  }\n  mean = sum / numbers.size();\n\n  // Calculate MAD\n  sum = 0.0f;\n  for (int i = 0; i < numbers.size(); i++) {\n    sum += abs(numbers[i] - mean);\n  }\n  mad = sum / numbers.size();\n\n  return mad;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0.0f;\n  float mean = 0.0f;\n  float mad = 0.0f;\n\n  for (int i = 0; i < numbers.size(); i++) {\n    sum += numbers[i];\n  }\n\n  mean = sum / numbers.size();\n\n  for (int i = 0; i < numbers.size(); i++) {\n    mad += abs(numbers[i] - mean);\n  }\n\n  return mad / numbers.size();\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n  std::vector<long> common_elements;\n  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n\n  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(common_elements));\n\n  common_elements.erase(std::unique(common_elements.begin(), common_elements.end()), common_elements.end());\n\n  return common_elements;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n  std::vector<long> result;\n  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n  \n  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n  \n  result.erase(std::unique(result.begin(), result.end()), result.end());\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n  std::vector<long> result;\n  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n  \n  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n  \n  result.erase(std::unique(result.begin(), result.end()), result.end());\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n  std::vector<long> result;\n  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n  \n  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n  \n  result.erase(std::unique(result.begin(), result.end()), result.end());\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n  std::vector<long> commonElements;\n  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(commonElements));\n  commonElements.erase(std::unique(commonElements.begin(), commonElements.end()), commonElements.end());\n  return commonElements;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n  std::vector<long> result;\n  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n  result.erase(std::unique(result.begin(), result.end()), result.end());\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n  std::vector<long> result;\n  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n\n  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n\n  result.erase(std::unique(result.begin(), result.end()), result.end());\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n\n  std::vector<long> result;\n  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n\n  result.erase(std::unique(result.begin(), result.end()), result.end());\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n  std::vector<long> common_elements;\n  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n  \n  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(common_elements));\n  \n  common_elements.erase(std::unique(common_elements.begin(), common_elements.end()), common_elements.end());\n  \n  return common_elements;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n  std::vector<long> common_elements;\n  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n  \n  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(common_elements));\n  \n  common_elements.erase(std::unique(common_elements.begin(), common_elements.end()), common_elements.end());\n  \n  return common_elements;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n  std::vector<std::pair<int, char>> values = {\n    {1000, 'm'}, {900, 'c'}, {500, 'd'}, {400, 'c'},\n    {100, 'c'}, {90, 'x'}, {50, 'l'}, {40, 'x'},\n    {10, 'x'}, {9, 'i'}, {5, 'v'}, {4, 'i'},\n    {1, 'i'}\n  };\n\n  for (auto &value : values) {\n    while (number >= value.first) {\n      roman += value.second;\n      number -= value.first;\n    }\n  }\n\n  for (int i = 0; i < roman.length(); i++) {\n    if (roman[i] == roman[i + 1] && roman[i + 1] == roman[i + 2] && roman[i + 2] == roman[i + 3]) {\n      char temp = roman[i];\n      roman.erase(i, 4);\n      if (temp == 'i') roman.insert(i, \"iv\");\n      else if (temp == 'x') roman.insert(i, \"xl\");\n      else if (temp == 'c') roman.insert(i, \"cd\");\n    }\n    else if (roman[i] == roman[i + 1] && roman[i + 1] == roman[i + 2]) {\n      char temp = roman[i];\n      roman.erase(i, 3);\n      if (temp == 'i') roman.insert(i, \"iii\");\n      else if (temp == 'x') roman.insert(i, \"xxx\");\n      else if (temp == 'c') roman.insert(i, \"ccc\");\n    }\n  }\n\n  return roman;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n  std::vector<std::pair<int, char>> value_map = {\n      {1000, 'm'}, {900, 'c'}, {500, 'd'}, {400, 'c'},\n      {100, 'c'}, {90, 'x'}, {50, 'l'}, {40, 'x'},\n      {10, 'x'}, {9, 'i'}, {5, 'v'}, {4, 'i'},\n      {1, 'i'}};\n\n  for (auto &pair : value_map) {\n    while (number >= pair.first) {\n      roman += pair.second;\n      number -= pair.first;\n    }\n  }\n\n  for (int i = 0; i < roman.size(); i++) {\n    if (roman[i] == roman[i + 1] && roman[i + 1] == roman[i + 2] && roman[i + 2] == roman[i + 3]) {\n      char temp = roman[i];\n      roman.erase(i, 4);\n      if (temp == 'i') {\n        roman.insert(i, \"iv\");\n      } else if (temp == 'x') {\n        roman.insert(i, \"xl\");\n      } else if (temp == 'c') {\n        roman.insert(i, \"cd\");\n      }\n    } else if (roman[i] == roman[i + 1] && roman[i + 1] == roman[i + 2]) {\n      char temp = roman[i];\n      roman.erase(i, 3);\n      if (temp == 'i') {\n        roman.insert(i, \"iii\");\n      } else if (temp == 'x') {\n        roman.insert(i, \"xxx\");\n      } else if (temp == 'c') {\n        roman.insert(i, \"ccc\");\n      }\n    }\n  }\n\n  return roman;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n  std::vector<std::pair<int, char>> value_map = {\n    {1000, 'm'}, {900, 'c'}, {500, 'd'}, {400, 'c'},\n    {100, 'c'}, {90, 'x'}, {50, 'l'}, {40, 'x'},\n    {10, 'x'}, {9, 'i'}, {5, 'v'}, {4, 'i'}, {1, 'i'}\n  };\n\n  for (auto &value : value_map) {\n    while (number >= value.first) {\n      roman += value.second;\n      number -= value.first;\n    }\n  }\n\n  return roman;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n  std::vector<std::pair<int, char>> romanNumerals = {\n    {1000, 'm'}, {900, 'c'}, {500, 'd'}, {400, 'c'}, {100, 'c'}, {90, 'x'},\n    {50, 'l'}, {40, 'x'}, {10, 'x'}, {9, 'i'}, {5, 'v'}, {4, 'i'}, {1, 'i'}\n  };\n\n  for (auto &value : romanNumerals) {\n    while (number >= value.first) {\n      roman += value.second;\n      number -= value.first;\n    }\n  }\n  \n  return roman;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n  std::vector<std::pair<int, char>> value_map = {\n    {1000, 'm'}, {900, 'c'}, {500, 'd'}, {400, 'c'},\n    {100, 'c'}, {90, 'x'}, {50, 'l'}, {40, 'x'},\n    {10, 'x'}, {9, 'i'}, {5, 'v'}, {4, 'i'}, {1, 'i'}\n  };\n\n  for (auto &pair : value_map) {\n    while (number >= pair.first) {\n      roman += pair.second;\n      number -= pair.first;\n    }\n  }\n\n  for (auto &c : roman) {\n    c = tolower(c);\n  }\n\n  return roman;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string result = \"\";\n  std::vector<std::pair<int, char>> roman = {{1000, 'm'}, {900, 'c'}, {500, 'd'}, {400, 'c'}, {100, 'c'}, {90, 'x'}, {50, 'l'}, {40, 'x'}, {10, 'x'}, {9, 'i'}, {5, 'v'}, {4, 'i'}, {1, 'i'}};\n\n  for (auto &pair : roman) {\n    while (number >= pair.first) {\n      result += pair.second;\n      number -= pair.first;\n    }\n  }\n\n  for (int i = 0; i < result.size(); i++) {\n    if (result[i] == 'c' && result[i+1] == 'd') {\n      result[i] = 'c';\n      result[i+1] = 'd';\n    }\n    else if (result[i] == 'c' && result[i+1] == 'm') {\n      result[i] = 'c';\n      result[i+1] = 'm';\n    }\n    else if (result[i] == 'x' && result[i+1] == 'l') {\n      result[i] = 'x';\n      result[i+1] = 'l';\n    }\n    else if (result[i] == 'x' && result[i+1] == 'c') {\n      result[i] = 'x';\n      result[i+1] = 'c';\n    }\n    else if (result[i] == 'i' && result[i+1] == 'v') {\n      result[i] = 'i';\n      result[i+1] = 'v';\n    }\n    else if (result[i] == 'i' && result[i+1] == 'x') {\n      result[i] = 'i';\n      result[i+1] = 'x';\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n  std::vector<std::pair<int, char>> value_map = {\n    {1000, 'm'}, {900, 'c'}, {500, 'd'}, {400, 'c'},\n    {100, 'c'}, {90, 'x'}, {50, 'l'}, {40, 'x'},\n    {10, 'x'}, {9, 'i'}, {5, 'v'}, {4, 'i'}, {1, 'i'}\n  };\n\n  for (auto &pair : value_map) {\n    while (number >= pair.first) {\n      roman += pair.second;\n      number -= pair.first;\n    }\n  }\n\n  for (size_t i = 0; i < roman.size(); i++) {\n    if (roman[i] == roman[i+1] && roman[i+1] == roman[i+2] && roman[i+2] == roman[i+3]) {\n      char replace_char = 'i';\n      switch (roman[i]) {\n        case 'i': replace_char = 'v'; break;\n        case 'x': replace_char = 'l'; break;\n        case 'c': replace_char = 'd'; break;\n      }\n      roman = roman.substr(0, i) + replace_char + roman.substr(i+4);\n    }\n    else if (roman[i] == roman[i+1] && roman[i+1] == roman[i+2]) {\n      char replace_char = 'i';\n      switch (roman[i]) {\n        case 'i': replace_char = 'x'; break;\n        case 'x': replace_char = 'c'; break;\n        case 'c': replace_char = 'm'; break;\n      }\n      roman = roman.substr(0, i) + replace_char + roman.substr(i+3);\n    }\n  }\n\n  return roman;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman_numerals[13] = {\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n  int integer_values[13] = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\n\n  std::string result = \"\";\n  for (int i = 0; i < 13; i++) {\n    while (number >= integer_values[i]) {\n      number -= integer_values[i];\n      result += roman_numerals[i];\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n  std::vector<std::pair<int, char>> value_map = {\n    {1000, 'm'}, {900, 'c'}, {500, 'd'}, {400, 'c'},\n    {100, 'c'}, {90, 'x'}, {50, 'l'}, {40, 'x'},\n    {10, 'x'}, {9, 'i'}, {5, 'v'}, {4, 'i'}, {1, 'i'}\n  };\n\n  for (auto &pair : value_map) {\n    while (number >= pair.first) {\n      roman += pair.second;\n      number -= pair.first;\n    }\n  }\n\n  for (size_t i = 0; i < roman.size(); i++) {\n    if (roman[i] == roman[i + 1] && roman[i + 1] == roman[i + 2] && roman[i + 2] == roman[i + 3]) {\n      char replace;\n      switch (roman[i]) {\n        case 'i':\n          replace = 'v';\n          break;\n        case 'x':\n          replace = 'l';\n          break;\n        case 'c':\n          replace = 'd';\n          break;\n        default:\n          replace = 'm';\n      }\n      roman.replace(i, 4, 1, replace);\n    }\n    else if (roman[i] == roman[i + 1] && roman[i + 1] == roman[i + 2]) {\n      char replace;\n      switch (roman[i]) {\n        case 'i':\n          replace = 'x';\n          break;\n        case 'x':\n          replace = 'c';\n          break;\n        case 'c':\n          replace = 'm';\n          break;\n        default:\n          replace = 'm';\n      }\n      roman.replace(i, 3, 1, replace);\n    }\n  }\n\n  return roman;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n  std::vector<std::pair<int, char>> values = {\n    {1000, 'm'}, {900, 'cm'}, {500, 'd'}, {400, 'cd'},\n    {100, 'c'}, {90, 'xc'}, {50, 'l'}, {40, 'xl'},\n    {10, 'x'}, {9, 'ix'}, {5, 'v'}, {4, 'iv'}, {1, 'i'}\n  };\n\n  for (auto &value : values) {\n    while (number >= value.first) {\n      roman += value.second;\n      number -= value.first;\n    }\n  }\n\n  return roman;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n  std::stringstream ss(s);\n  long apples, oranges;\n  std::string temp;\n  \n  ss >> apples >> temp >> temp >> oranges;\n  \n  return n - (apples + oranges);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n  std::stringstream ss(s);\n  long apples, oranges;\n  std::string temp;\n  ss >> apples >> temp >> temp >> oranges;\n  long mangoes = n - (apples + oranges);\n  return mangoes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n  std::stringstream ss(s);\n  long apples, oranges;\n  std::string temp;\n  ss >> apples >> temp >> temp >> oranges;\n  long mangoes = n - (apples + oranges);\n  return mangoes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n  std::stringstream ss(s);\n  long apples, oranges;\n  std::string temp;\n  ss >> apples >> temp >> temp >> oranges;\n  long mangoes = n - (apples + oranges);\n  return mangoes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n  long apples = 0, oranges = 0;\n  std::stringstream ss(s);\n  std::string temp;\n  while (ss >> temp) {\n    if (std::isdigit(temp[0])) {\n      if (apples == 0) {\n        apples = std::stol(temp);\n      } else {\n        oranges = std::stol(temp);\n      }\n    }\n  }\n  return n - (apples + oranges);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n  long total_apples_and_oranges = 0;\n  std::stringstream ss(s);\n  std::string temp;\n  while (ss >> temp) {\n    if (std::isdigit(temp[0])) {\n      total_apples_and_oranges += std::stol(temp);\n    }\n  }\n  return n - total_apples_and_oranges;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n  long apples = 0, oranges = 0;\n  std::stringstream ss(s);\n  std::string temp;\n  \n  while (ss >> temp) {\n    if (std::isdigit(temp[0])) {\n      if (apples == 0) {\n        apples = std::stoi(temp);\n      } else {\n        oranges = std::stoi(temp);\n      }\n    }\n  }\n  \n  return n - (apples + oranges);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n  std::stringstream ss(s);\n  long apples, oranges;\n  std::string temp;\n  \n  ss >> apples >> temp >> temp >> oranges;\n  \n  long mangoes = n - (apples + oranges);\n  return mangoes;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n  std::stringstream ss(s);\n  long apples, oranges;\n  std::string tmp;\n  ss >> apples >> tmp >> tmp >> oranges;\n  return n - (apples + oranges);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n  std::stringstream ss(s);\n  long apples, oranges;\n  std::string temp;\n\n  ss >> apples >> temp >> temp >> oranges;\n\n  long mangos = n - (apples + oranges);\n  return mangos;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result = \"\";\n  for (char ch : s) {\n    if (c.find(ch) == std::string::npos) {\n      result += ch;\n    }\n  }\n  \n  std::string reversed = result;\n  std::reverse(reversed.begin(), reversed.end());\n  \n  return std::make_tuple(result, result == reversed);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result = \"\";\n  for (char ch : s) {\n    if (c.find(ch) == std::string::npos) {\n      result += ch;\n    }\n  }\n\n  std::string reversed = result;\n  std::reverse(reversed.begin(), reversed.end());\n\n  return std::make_tuple(result, result == reversed);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result = \"\";\n  for (char ch : s) {\n    if (c.find(ch) == std::string::npos) {\n      result += ch;\n    }\n  }\n\n  std::string reversed = result;\n  std::reverse(reversed.begin(), reversed.end());\n\n  return std::make_tuple(result, result == reversed);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string res = \"\";\n  for (char ch : s) {\n    if (c.find(ch) == std::string::npos) {\n      res += ch;\n    }\n  }\n  \n  std::string rev = res;\n  std::reverse(rev.begin(), rev.end());\n  \n  return std::make_tuple(res, res == rev);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result = \"\";\n  for(char& ch : s) {\n    if(c.find(ch) == std::string::npos) {\n      result += ch;\n    }\n  }\n  std::string reversed = result;\n  std::reverse(reversed.begin(), reversed.end());\n  return std::make_tuple(result, result == reversed);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result = \"\";\n  for (char ch : s) {\n    if (c.find(ch) == std::string::npos) {\n      result += ch;\n    }\n  }\n\n  std::string reversed = result;\n  std::reverse(reversed.begin(), reversed.end());\n\n  return std::make_tuple(result, result == reversed);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result = \"\";\n  for (char ch : s) {\n    if (c.find(ch) == std::string::npos) {\n      result += ch;\n    }\n  }\n  std::string reversed = result;\n  std::reverse(reversed.begin(), reversed.end());\n  return std::make_tuple(result, result == reversed);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result = \"\";\n  for (char ch : s) {\n    if (c.find(ch) == std::string::npos) {\n      result += ch;\n    }\n  }\n  std::string reversed = result;\n  std::reverse(reversed.begin(), reversed.end());\n  return std::make_tuple(result, result == reversed);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  for (char ch : c) {\n    s.erase(std::remove(s.begin(), s.end(), ch), s.end());\n  }\n  \n  std::string reversed_s = s;\n  std::reverse(reversed_s.begin(), reversed_s.end());\n  \n  bool is_palindrome = (s == reversed_s);\n  \n  return std::make_tuple(s, is_palindrome);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result = \"\";\n  for (char ch : s) {\n    if (c.find(ch) == std::string::npos) {\n      result += ch;\n    }\n  }\n  \n  std::string reversed = result;\n  std::reverse(reversed.begin(), reversed.end());\n  \n  return std::make_tuple(result, result == reversed);\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n  while (b != 0) {\n    long temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n  while (b != 0) {\n    long t = b;\n    b = a % b;\n    a = t;\n  }\n  return a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n  while (b != 0) {\n    long temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n  while (b != 0) {\n    long temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n  while (b != 0) {\n    long temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n  while (b != 0) {\n    long temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n  while(b != 0) {\n    long temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n  while(b != 0) {\n    long temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n  while (b != 0) {\n    long temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n  while (b != 0) {\n    long temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n  std::vector<std::string> words;\n  std::istringstream iss(txt);\n  std::string token;\n  \n  if(txt.find(' ') != std::string::npos) {\n    while(std::getline(iss, token, ' ')) {\n      words.push_back(token);\n    }\n    return Union_std_vector_std_string__long(words);\n  }\n  \n  if(txt.find(',') != std::string::npos) {\n    while(std::getline(iss, token, ',')) {\n      words.push_back(token);\n    }\n    return Union_std_vector_std_string__long(words);\n  }\n  \n  long count = 0;\n  for(char c : txt) {\n    if(islower(c) && (c - 'a') % 2 == 0) {\n      count++;\n    }\n  }\n  \n  return Union_std_vector_std_string__long(count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n  std::vector<std::string> words;\n  std::istringstream iss(txt);\n  std::string token;\n\n  if(txt.find(' ') != std::string::npos) {\n    while(std::getline(iss, token, ' ')) {\n      words.push_back(token);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else if(txt.find(',') != std::string::npos) {\n    while(std::getline(iss, token, ',')) {\n      words.push_back(token);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else {\n    long count = 0;\n    for(char c : txt) {\n      if(islower(c) && (c - 'a') % 2 == 0) {\n        count++;\n      }\n    }\n    return Union_std_vector_std_string__long(count);\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n  std::vector<std::string> words;\n  std::stringstream ss(txt);\n  std::string word;\n\n  if(txt.find(' ') != std::string::npos) {\n    while (getline(ss, word, ' ')) {\n      words.push_back(word);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else if(txt.find(',') != std::string::npos) {\n    while (getline(ss, word, ',')) {\n      words.push_back(word);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else {\n    long count = 0;\n    for(char c : txt) {\n      if(islower(c) && (c - 'a') % 2 == 0) {\n        count++;\n      }\n    }\n    return Union_std_vector_std_string__long(count);\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n  std::vector<std::string> words;\n  std::istringstream iss(txt);\n  std::string token;\n\n  if(txt.find(' ') != std::string::npos) {\n    while(std::getline(iss, token, ' ')) {\n      words.push_back(token);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else if(txt.find(',') != std::string::npos) {\n    while(std::getline(iss, token, ',')) {\n      words.push_back(token);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else {\n    long oddCount = 0;\n    for(char c : txt) {\n      if(islower(c) && (c - 'a') % 2 != 0) {\n        oddCount++;\n      }\n    }\n    return Union_std_vector_std_string__long(oddCount);\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> result;\n    std::istringstream iss(txt);\n    std::string word;\n    if(txt.find(' ') != std::string::npos){\n        while (std::getline(iss, word, ' ')) {\n            result.push_back(word);\n        }\n        return Union_std_vector_std_string__long(result);\n    }\n    else if(txt.find(',') != std::string::npos){\n        while (std::getline(iss, word, ',')) {\n            result.push_back(word);\n        }\n        return Union_std_vector_std_string__long(result);\n    }\n    else{\n        long count = 0;\n        for (char c : txt) {\n            if (islower(c) && ((c - 'a') % 2 == 1)) {\n                count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> words;\n    std::string word;\n    std::stringstream ss(txt);\n\n    if (txt.find(' ') != std::string::npos) {\n        while (std::getline(ss, word, ' ')) {\n            words.push_back(word);\n        }\n    } else if (txt.find(',') != std::string::npos) {\n        while (std::getline(ss, word, ',')) {\n            words.push_back(word);\n        }\n    } else {\n        long count = 0;\n        for (char c : txt) {\n            if (islower(c) && ((c - 'a') % 2 != 0)) {\n                count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n\n    return Union_std_vector_std_string__long(words);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n  std::vector<std::string> words;\n  std::string delimiter = \" \";\n  size_t pos = 0;\n  std::string token;\n  \n  if(txt.find(delimiter) != std::string::npos) {\n    while ((pos = txt.find(delimiter)) != std::string::npos) {\n      token = txt.substr(0, pos);\n      words.push_back(token);\n      txt.erase(0, pos + delimiter.length());\n    }\n    words.push_back(txt);\n    return Union_std_vector_std_string__long(words);\n  }\n\n  delimiter = \",\";\n  if(txt.find(delimiter) != std::string::npos) {\n    while ((pos = txt.find(delimiter)) != std::string::npos) {\n      token = txt.substr(0, pos);\n      words.push_back(token);\n      txt.erase(0, pos + delimiter.length());\n    }\n    words.push_back(txt);\n    return Union_std_vector_std_string__long(words);\n  }\n\n  long count = 0;\n  for(char& c : txt) {\n    if(islower(c) && (c - 'a') % 2 == 1) {\n      count++;\n    }\n  }\n  return Union_std_vector_std_string__long(count);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n  std::vector<std::string> words;\n  std::stringstream ss(txt);\n  std::string word;\n  \n  if(txt.find(' ') != std::string::npos) {\n    while(getline(ss, word, ' ')) {\n      words.push_back(word);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else if(txt.find(',') != std::string::npos) {\n    while(getline(ss, word, ',')) {\n      words.push_back(word);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else {\n    long count = 0;\n    for(char c : txt) {\n      if(islower(c) && (c - 'a') % 2 == 1) {\n        count++;\n      }\n    }\n    return Union_std_vector_std_string__long(count);\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n  std::vector<std::string> words;\n  std::istringstream ss(txt);\n  std::string word;\n  \n  if(txt.find(' ') != std::string::npos) {\n    while(std::getline(ss, word, ' ')) {\n      words.push_back(word);\n    }\n    return Union_std_vector_std_string__long(words);\n  }\n  \n  if(txt.find(',') != std::string::npos) {\n    while(std::getline(ss, word, ',')) {\n      words.push_back(word);\n    }\n    return Union_std_vector_std_string__long(words);\n  }\n  \n  long oddCount = 0;\n  for(char c : txt) {\n    if(islower(c) && (c - 'a') % 2 != 0) {\n      oddCount++;\n    }\n  }\n  \n  return Union_std_vector_std_string__long(oddCount);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n  std::vector<std::string> words;\n  std::istringstream ss(txt);\n  std::string word;\n\n  if(txt.find(' ') != std::string::npos) {\n    while(std::getline(ss, word, ' ')) {\n      words.push_back(word);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else if(txt.find(',') != std::string::npos) {\n    while(std::getline(ss, word, ',')) {\n      words.push_back(word);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else {\n    long count = 0;\n    for(char c : txt) {\n      if(islower(c) && (c - 'a') % 2 != 0)\n        count++;\n    }\n    return Union_std_vector_std_string__long(count);\n  }\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n  auto count_bits = [](long n) {\n    int count = 0;\n    while (n) {\n      count += n & 1;\n      n >>= 1;\n    }\n    return count;\n  };\n\n  std::sort(arr.begin(), arr.end(), [&](long a, long b) {\n    int count_a = count_bits(a);\n    int count_b = count_bits(b);\n\n    if (count_a == count_b) {\n      return a < b;\n    }\n    return count_a < count_b;\n  });\n\n  return arr;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n  auto count_ones = [](long n) {\n    int count = 0;\n    while (n) {\n      count += n & 1;\n      n >>= 1;\n    }\n    return count;\n  };\n\n  std::sort(arr.begin(), arr.end(), [&](long a, long b) {\n    int countA = count_ones(a);\n    int countB = count_ones(b);\n    return countA < countB || (countA == countB && a < b);\n  });\n\n  return arr;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n  auto count_ones = [](long n) {\n    int count = 0;\n    while (n) {\n      count += n & 1;\n      n >>= 1;\n    }\n    return count;\n  };\n\n  std::sort(arr.begin(), arr.end(), [&](long a, long b) {\n    int count_a = count_ones(a);\n    int count_b = count_ones(b);\n    if (count_a == count_b) {\n      return a < b;\n    }\n    return count_a < count_b;\n  });\n\n  return arr;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n  auto count_bits = [](int n) {\n    int count = 0;\n    while (n) {\n      count += n & 1;\n      n >>= 1;\n    }\n    return count;\n  };\n\n  std::sort(arr.begin(), arr.end(), [&](int a, int b) {\n    int count_a = count_bits(a);\n    int count_b = count_bits(b);\n    return count_a == count_b ? a < b : count_a < count_b;\n  });\n\n  return arr;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n  auto count_bits = [](long n) {\n    int count = 0;\n    while (n) {\n      count += n & 1;\n      n >>= 1;\n    }\n    return count;\n  };\n\n  std::sort(arr.begin(), arr.end(), [&](long a, long b) {\n    int count_a = count_bits(a);\n    int count_b = count_bits(b);\n    return count_a == count_b ? a < b : count_a < count_b;\n  });\n\n  return arr;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n  auto count_ones = [](long n) {\n    int count = 0;\n    while (n) {\n      count += n & 1;\n      n >>= 1;\n    }\n    return count;\n  };\n\n  std::sort(arr.begin(), arr.end(), [&](long a, long b) {\n    int count_a = count_ones(a);\n    int count_b = count_ones(b);\n    return (count_a < count_b) || (count_a == count_b && a < b);\n  });\n\n  return arr;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n  auto count_bits = [](long n) {\n    int count = 0;\n    while (n) {\n      count += n & 1;\n      n >>= 1;\n    }\n    return count;\n  };\n\n  std::sort(arr.begin(), arr.end(), [&](long a, long b) {\n    int count_a = count_bits(a);\n    int count_b = count_bits(b);\n    if (count_a == count_b) {\n      return a < b;\n    }\n    return count_a < count_b;\n  });\n\n  return arr;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n  auto count_ones = [](int n) {\n    int count = 0;\n    while (n) {\n      count += n & 1;\n      n >>= 1;\n    }\n    return count;\n  };\n\n  std::sort(arr.begin(), arr.end(), [&](long a, long b) {\n    int count_a = count_ones(a);\n    int count_b = count_ones(b);\n    if (count_a == count_b) {\n      return a < b;\n    }\n    return count_a < count_b;\n  });\n\n  return arr;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n  auto count_bits = [](long n) {\n    int count = 0;\n    while (n) {\n      count += n & 1;\n      n >>= 1;\n    }\n    return count;\n  };\n\n  std::sort(arr.begin(), arr.end(), [&](long a, long b) {\n    int count_a = count_bits(a);\n    int count_b = count_bits(b);\n\n    if (count_a == count_b) {\n      return a < b;\n    }\n\n    return count_a < count_b;\n  });\n\n  return arr;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n  auto count_bits = [](long n) {\n    int count = 0;\n    while (n) {\n      count += n & 1;\n      n >>= 1;\n    }\n    return count;\n  };\n\n  std::sort(arr.begin(), arr.end(), [&](long a, long b) {\n    int count_a = count_bits(a);\n    int count_b = count_bits(b);\n    if (count_a == count_b) {\n      return a < b;\n    }\n    return count_a < count_b;\n  });\n\n  return arr;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result = \"\";\n  for (const auto& str : strings) {\n    result += str;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result = \"\";\n  for (const auto& str : strings) {\n    result += str;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result = \"\";\n  for (const auto& str : strings) {\n    result += str;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result = \"\";\n  for (const auto& str : strings) {\n    result += str;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result = \"\";\n  for (auto &str : strings) {\n    result += str;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result = \"\";\n  for (const auto& str : strings) {\n    result += str;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result = \"\";\n  for (const auto& str : strings) {\n    result += str;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result = \"\";\n  for (const auto& str : strings) {\n    result += str;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result = \"\";\n  for(auto &str : strings) {\n    result += str;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result = \"\";\n  for (const auto& str : strings) {\n    result += str;\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  std::vector<std::string> evenLengthStrings;\n\n  // Remove strings with odd lengths\n  for (const auto& str : lst) {\n    if (str.length() % 2 == 0) {\n      evenLengthStrings.push_back(str);\n    }\n  }\n\n  // Sort the strings by length and then alphabetically\n  std::sort(evenLengthStrings.begin(), evenLengthStrings.end(), \n            [](const std::string& a, const std::string& b) {\n              if (a.length() == b.length()) {\n                return a < b;\n              }\n              return a.length() < b.length();\n            });\n\n  return evenLengthStrings;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (const auto& str : lst) {\n    if (str.length() % 2 == 0) {\n      result.push_back(str);\n    }\n  }\n\n  std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n    if (a.size() == b.size()) {\n      return a < b;\n    }\n    return a.size() < b.size();\n  });\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (auto &str : lst) {\n    if (str.length() % 2 == 0) {\n      result.push_back(str);\n    }\n  }\n\n  std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n    if (a.length() == b.length()) return a < b;\n    return a.length() < b.length();\n  });\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (auto &str : lst) {\n    if (str.length() % 2 == 0) {\n      result.push_back(str);\n    }\n  }\n  \n  std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n    if (a.length() == b.length()) {\n      return a < b;\n    }\n    return a.length() < b.length();\n  });\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for(auto& s : lst) {\n    if(s.length() % 2 == 0) {\n      result.push_back(s);\n    }\n  }\n  std::sort(result.begin(), result.end(), [](const std::string& a, const std::string& b) {\n    if(a.length() == b.length()) {\n      return a < b;\n    }\n    return a.length() < b.length();\n  });\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  \n  // Remove strings with odd lengths\n  for (const auto& str : lst) {\n    if (str.length() % 2 == 0) {\n      result.push_back(str);\n    }\n  }\n  \n  // Sort the vector\n  std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n    if (a.length() == b.length()) {\n      return a < b;\n    }\n    return a.length() < b.length();\n  });\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  \n  // Remove strings with odd lengths\n  for (const auto& str : lst) {\n    if (str.size() % 2 == 0) {\n      result.push_back(str);\n    }\n  }\n  \n  // Sort the vector\n  std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b){\n    if(a.size() == b.size())\n      return a < b;\n    return a.size() < b.size();\n  });\n  \n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  // Remove strings with odd lengths\n  lst.erase(std::remove_if(lst.begin(), lst.end(), [](const std::string& str) {\n    return str.size() % 2 != 0;\n  }), lst.end());\n\n  // Sort by length and then alphabetically\n  std::sort(lst.begin(), lst.end(), [](const std::string& a, const std::string& b) {\n    if (a.size() == b.size()) {\n      return a < b;\n    }\n    return a.size() < b.size();\n  });\n\n  return lst;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  \n  // Remove strings with odd lengths\n  for (const auto& str : lst) {\n    if (str.length() % 2 == 0) {\n      result.push_back(str);\n    }\n  }\n\n  // Sort the vector by length and then alphabetically\n  std::sort(result.begin(), result.end(), [](const std::string& a, const std::string& b) {\n    if (a.length() == b.length()) {\n      return a < b;\n    }\n    return a.length() < b.length();\n  });\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (auto &str : lst) {\n    if (str.length() % 2 == 0) {\n      result.push_back(str);\n    }\n  }\n\n  std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n    if (a.length() == b.length()) {\n      return a < b;\n    }\n    return a.length() < b.length();\n  });\n\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n  std::vector<std::string> result;\n  for(const auto& str : strings) {\n    if(str.find(substring) != std::string::npos) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n  std::vector<std::string> result;\n  for (auto &str : strings) {\n    if (str.find(substring) != std::string::npos) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n  std::vector<std::string> result;\n  for (auto &str : strings) {\n    if (str.find(substring) != std::string::npos) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n  std::vector<std::string> result;\n  for (auto &str : strings) {\n    if (str.find(substring) != std::string::npos) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n  std::vector<std::string> result;\n  for (auto &str : strings) {\n    if (str.find(substring) != std::string::npos) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n  std::vector<std::string> result;\n  for (auto &str : strings) {\n    if (str.find(substring) != std::string::npos) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n  std::vector<std::string> result;\n  for (const auto& str : strings) {\n    if (str.find(substring) != std::string::npos) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n  std::vector<std::string> result;\n  for (const auto& str : strings) {\n    if (str.find(substring) != std::string::npos) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n  std::vector<std::string> filteredStrings;\n  for (auto &str : strings) {\n    if (str.find(substring) != std::string::npos) {\n      filteredStrings.push_back(str);\n    }\n  }\n  return filteredStrings;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n  std::vector<std::string> result;\n  for (std::string str : strings) {\n    if (str.find(substring) != std::string::npos) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  double number = std::stod(value);\n  long result = (number > 0.0) ? (long)(number + 0.5) : (long)(number - 0.5);\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  long lower = std::floor(num);\n  long upper = std::ceil(num);\n\n  if (num >= 0) {\n    return (num - lower >= 0.5) ? upper : lower;\n  } else {\n    return (upper - num >= 0.5) ? lower : upper;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  long lower = std::floor(num);\n  long upper = std::ceil(num);\n\n  if (num - lower >= 0.5) {\n    return upper;\n  } else {\n    return lower;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  long lower = (long)num;\n  double diff = num - lower;\n\n  if(diff < 0.5){\n    return lower;\n  } else if(diff > 0.5){\n    return lower + 1;\n  } else {\n    return num > 0 ? lower + 1 : lower - 1;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  if(num > 0) {\n    return (long)(num + 0.5);\n  } else {\n    return (long)(num - 0.5);\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  long result = (num > 0.0) ? (long)(num + 0.5) : (long)(num - 0.5);\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  long intPart = (long)num;\n  double fracPart = num - intPart;\n\n  if (fracPart >= 0.5) {\n    return num < 0 ? intPart - 1 : intPart + 1;\n  } else {\n    return intPart;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  long lower = (long)num;\n  long upper = lower < num ? lower + 1 : lower - 1;\n\n  return std::abs(num - lower) < std::abs(num - upper) ? lower : upper;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  double number = std::stod(value);\n  long lower = std::floor(number);\n  long upper = std::ceil(number);\n\n  if (std::abs(number - lower) < std::abs(number - upper)) {\n    return lower;\n  } else if (std::abs(number - lower) > std::abs(number - upper)) {\n    return upper;\n  } else {\n    return number < 0 ? lower : upper;\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  long lower = std::floor(num);\n  long upper = std::ceil(num);\n\n  if (num >= 0) {\n    return (num - lower >= 0.5) ? upper : lower;\n  } else {\n    return (num - lower <= -0.5) ? upper : lower;\n  }\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.length(); i++) {\n    char c = tolower(s[i]);\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || (c == 'y' && i == s.length() - 1)) {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.length(); i++) {\n    char c = tolower(s[i]);\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || (c == 'y' && i == s.length() - 1)) {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n  long count = 0;\n  std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n  for (int i = 0; i < s.length(); i++) {\n    if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n      count++;\n    }\n  }\n  if (s[s.length()-1] == 'y') {\n    count++;\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n  long count = 0;\n  std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n  for (char c : s) {\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n      count++;\n    }\n  }\n  if (s.back() == 'y') {\n    count++;\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n  long count = 0;\n  std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n  for (char c : s) {\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n      count++;\n    }\n  }\n  if (s.back() == 'y') {\n    count++;\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.length(); i++) {\n    char c = tolower(s[i]);\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || (c == 'y' && i == s.length() - 1)) {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n  long count = 0;\n  std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n  for (char c : s) {\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n      count++;\n    }\n  }\n  if (s.back() == 'y') {\n    count++;\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.length(); i++) {\n    char c = tolower(s[i]);\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || (c == 'y' && i == s.length() - 1)) {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n  long count = 0;\n  for(int i = 0; i < s.length(); i++) {\n    char c = tolower(s[i]);\n    if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || (c == 'y' && i == s.length() - 1)) {\n      count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n  long count = 0;\n  std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n  for (char c : s) {\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n      count++;\n    }\n  }\n  if (s[s.length() - 1] == 'y') {\n    count++;\n  }\n  return count;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n  int max_unique_chars = 0;\n\n  for (auto word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_word = word;\n      max_unique_chars = unique_chars.size();\n    } else if (unique_chars.size() == max_unique_chars && word < max_word) {\n      max_word = word;\n    }\n  }\n\n  return max_word;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n  int max_unique_chars = 0;\n\n  std::sort(words.begin(), words.end());\n\n  for (const auto& word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_unique_chars = unique_chars.size();\n      max_word = word;\n    }\n  }\n\n  return max_word;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = words[0];\n  int max_unique_chars = std::set<char>(words[0].begin(), words[0].end()).size();\n\n  for (int i = 1; i < words.size(); i++) {\n    int unique_chars = std::set<char>(words[i].begin(), words[i].end()).size();\n    if (unique_chars > max_unique_chars || (unique_chars == max_unique_chars && words[i] < max_word)) {\n      max_word = words[i];\n      max_unique_chars = unique_chars;\n    }\n  }\n\n  return max_word;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = words[0];\n  int max_unique_chars = std::set<char>(words[0].begin(), words[0].end()).size();\n\n  for (int i = 1; i < words.size(); i++) {\n    int unique_chars = std::set<char>(words[i].begin(), words[i].end()).size();\n    if (unique_chars > max_unique_chars || (unique_chars == max_unique_chars && words[i] < max_word)) {\n      max_word = words[i];\n      max_unique_chars = unique_chars;\n    }\n  }\n\n  return max_word;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = words[0];\n  int max_unique_chars = std::set<char>(words[0].begin(), words[0].end()).size();\n\n  for (int i = 1; i < words.size(); i++) {\n    int unique_chars = std::set<char>(words[i].begin(), words[i].end()).size();\n    if (unique_chars > max_unique_chars || (unique_chars == max_unique_chars && words[i] < max_word)) {\n      max_word = words[i];\n      max_unique_chars = unique_chars;\n    }\n  }\n\n  return max_word;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n  int max_unique_chars = 0;\n\n  sort(words.begin(), words.end());\n\n  for (std::string word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_unique_chars = unique_chars.size();\n      max_word = word;\n    }\n  }\n\n  return max_word;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n  int max_unique_chars = 0;\n  \n  std::sort(words.begin(), words.end());\n  \n  for (const auto& word : words) {\n    std::unordered_set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_unique_chars = unique_chars.size();\n      max_word = word;\n    }\n  }\n  \n  return max_word;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = words[0];\n  int max_unique_chars = std::set<char>(words[0].begin(), words[0].end()).size();\n\n  for (int i = 1; i < words.size(); i++) {\n    int unique_chars = std::set<char>(words[i].begin(), words[i].end()).size();\n    if (unique_chars > max_unique_chars || (unique_chars == max_unique_chars && words[i] < max_word)) {\n      max_word = words[i];\n      max_unique_chars = unique_chars;\n    }\n  }\n\n  return max_word;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = words[0];\n  int max_unique_chars = std::set<char>(words[0].begin(), words[0].end()).size();\n\n  for (int i = 1; i < words.size(); i++) {\n    int unique_chars = std::set<char>(words[i].begin(), words[i].end()).size();\n    if (unique_chars > max_unique_chars || (unique_chars == max_unique_chars && words[i] < max_word)) {\n      max_word = words[i];\n      max_unique_chars = unique_chars;\n    }\n  }\n\n  return max_word;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = words[0];\n  int max_unique_chars = std::set<char>(words[0].begin(), words[0].end()).size();\n\n  for (int i = 1; i < words.size(); ++i) {\n    int unique_chars = std::set<char>(words[i].begin(), words[i].end()).size();\n    if (unique_chars > max_unique_chars || (unique_chars == max_unique_chars && words[i] < max_word)) {\n      max_word = words[i];\n      max_unique_chars = unique_chars;\n    }\n  }\n\n  return max_word;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n  if (text.empty()) {\n    return std::nullopt;\n  }\n  else {\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.size(), (unsigned char*)&digest);    \n\n    char mdString[33];\n    for(int i = 0; i < 16; i++)\n         sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return std::string(mdString);\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n  if (text.empty()) {\n    return std::nullopt;\n  }\n  \n  // Compute MD5 hash\n  MD5 md5 = MD5(text);\n  std::string hash = md5.hexdigest();\n\n  return hash;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n  if (text.empty()) {\n    return std::nullopt;\n  }\n\n  unsigned char digest[MD5_DIGEST_LENGTH];\n  MD5((unsigned char*)text.c_str(), text.size(), (unsigned char*)&digest);    \n\n  char mdString[33];\n  for(int i = 0; i < 16; i++)\n         sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n  return std::optional<std::string>(mdString);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n  if (text.empty()) {\n    return std::nullopt;\n  }\n\n  MD5 md5;\n  std::string md5_hash = md5(text);\n\n  return md5_hash;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n  if (text.empty()) {\n    return std::nullopt;\n  }\n\n  MD5 md5;\n  std::string md5_hash = md5(text);\n\n  return md5_hash;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n  if (text.empty()) {\n    return std::nullopt;\n  }\n  unsigned char digest[MD5_DIGEST_LENGTH];\n  MD5((unsigned char*)text.c_str(), text.size(), (unsigned char*)&digest);    \n\n  char mdString[33];\n  for(int i = 0; i < 16; i++)\n         sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n  return std::string(mdString);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n  if (text.empty()) {\n    return std::nullopt;\n  }\n\n  MD5 md5;\n  std::string md5_hash = md5(text);\n\n  return md5_hash;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n  if (text.empty()) {\n    return std::nullopt;\n  }\n  \n  unsigned char result[MD5_DIGEST_LENGTH];\n  MD5((unsigned char*)text.c_str(), text.size(), result);\n\n  std::ostringstream sout;\n  sout<<std::hex<<std::setfill('0');\n  for(long long c: result)\n  {\n    sout<<std::setw(2)<<(long long)c;\n  }\n\n  return sout.str();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n  if (text.empty()) {\n    return std::nullopt;\n  }\n  \n  MD5 md5 = MD5(text);\n  return md5.hexdigest();\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n  if (text.empty()) {\n    return std::nullopt;\n  }\n  \n  // Create a md5 object\n  MD5 md5 = MD5(text);\n  \n  // Return the md5 hash\n  return md5.hexdigest();\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n  std::string result = \"\";\n  while(x > 0) {\n    result = std::to_string(x % base) + result;\n    x /= base;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n  std::string result = \"\";\n  while(x > 0) {\n    result = std::to_string(x % base) + result;\n    x /= base;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n  std::string result = \"\";\n  while(x > 0) {\n    result = std::to_string(x % base) + result;\n    x /= base;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n  std::string result = \"\";\n  while(x > 0) {\n    result = std::to_string(x % base) + result;\n    x /= base;\n  }\n  return result.empty() ? \"0\" : result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n  std::string result = \"\";\n  while(x > 0) {\n    result = std::to_string(x % base) + result;\n    x /= base;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n  std::string result = \"\";\n  while(x > 0) {\n    result = std::to_string(x % base) + result;\n    x /= base;\n  }\n  return result.empty() ? \"0\" : result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n  std::string result = \"\";\n  while(x > 0) {\n    result = std::to_string(x % base) + result;\n    x /= base;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n  std::string result = \"\";\n  while(x > 0) {\n    result = std::to_string(x % base) + result;\n    x /= base;\n  }\n  return result.empty() ? \"0\" : result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n  std::string result = \"\";\n  while(x > 0) {\n    result = std::to_string(x % base) + result;\n    x /= base;\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n  std::string result = \"\";\n  while(x > 0) {\n    result = std::to_string(x % base) + result;\n    x /= base;\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n  long max_val = std::max({a, b, c});\n  \n  if(max_val == a) {\n    return (b*b + c*c == a*a);\n  } else if(max_val == b) {\n    return (a*a + c*c == b*b);\n  } else {\n    return (a*a + b*b == c*c);\n  }\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n  // sort the sides in ascending order\n  std::vector<long> sides = {a, b, c};\n  std::sort(sides.begin(), sides.end());\n\n  // check the Pythagorean theorem\n  return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2];\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n  // Sort the sides in ascending order\n  std::vector<long> sides = {a, b, c};\n  std::sort(sides.begin(), sides.end());\n\n  // Check the Pythagorean theorem\n  return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2];\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n  // Sort the sides in ascending order\n  std::vector<long> sides = {a, b, c};\n  std::sort(sides.begin(), sides.end());\n\n  // Check if the Pythagorean theorem holds\n  return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2];\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n  // Sort the sides in ascending order\n  std::vector<long> sides = {a, b, c};\n  std::sort(sides.begin(), sides.end());\n\n  // Check the Pythagorean theorem\n  return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2];\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n  // sort the sides\n  long max_side = std::max({a, b, c});\n  long other_sides = a*a + b*b + c*c - max_side*max_side;\n\n  // check Pythagorean theorem\n  return max_side*max_side == other_sides;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n  // Sort the sides in ascending order\n  std::vector<long> sides = {a, b, c};\n  std::sort(sides.begin(), sides.end());\n\n  // Check for the Pythagorean theorem\n  return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2];\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n  // Sort the sides in ascending order\n  std::vector<long> sides = {a, b, c};\n  std::sort(sides.begin(), sides.end());\n\n  // Check if it's a right-angled triangle using Pythagoras' theorem\n  return pow(sides[0], 2) + pow(sides[1], 2) == pow(sides[2], 2);\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n  // Sort the sides in ascending order\n  std::vector<long> sides = {a, b, c};\n  std::sort(sides.begin(), sides.end());\n\n  // Check the Pythagorean theorem\n  return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2];\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n  // Sort the sides in ascending order\n  std::vector<long> sides = {a, b, c};\n  std::sort(sides.begin(), sides.end());\n\n  // The triangle is right-angled if the square of the longest side is equal to the sum of the squares of the other two sides\n  return sides[2] * sides[2] == sides[0] * sides[0] + sides[1] * sides[1];\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float grade : grades) {\n    if (grade == 4.0f) {\n      letter_grades.push_back(\"A+\");\n    } else if (grade > 3.7f) {\n      letter_grades.push_back(\"A\");\n    } else if (grade > 3.3f) {\n      letter_grades.push_back(\"A-\");\n    } else if (grade > 3.0f) {\n      letter_grades.push_back(\"B+\");\n    } else if (grade > 2.7f) {\n      letter_grades.push_back(\"B\");\n    } else if (grade > 2.3f) {\n      letter_grades.push_back(\"B-\");\n    } else if (grade > 2.0f) {\n      letter_grades.push_back(\"C+\");\n    } else if (grade > 1.7f) {\n      letter_grades.push_back(\"C\");\n    } else if (grade > 1.3f) {\n      letter_grades.push_back(\"C-\");\n    } else if (grade > 1.0f) {\n      letter_grades.push_back(\"D+\");\n    } else if (grade > 0.7f) {\n      letter_grades.push_back(\"D\");\n    } else if (grade > 0.0f) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float grade : grades) {\n    if (grade == 4.0f) {\n      letter_grades.push_back(\"A+\");\n    } else if (grade > 3.7f) {\n      letter_grades.push_back(\"A\");\n    } else if (grade > 3.3f) {\n      letter_grades.push_back(\"A-\");\n    } else if (grade > 3.0f) {\n      letter_grades.push_back(\"B+\");\n    } else if (grade > 2.7f) {\n      letter_grades.push_back(\"B\");\n    } else if (grade > 2.3f) {\n      letter_grades.push_back(\"B-\");\n    } else if (grade > 2.0f) {\n      letter_grades.push_back(\"C+\");\n    } else if (grade > 1.7f) {\n      letter_grades.push_back(\"C\");\n    } else if (grade > 1.3f) {\n      letter_grades.push_back(\"C-\");\n    } else if (grade > 1.0f) {\n      letter_grades.push_back(\"D+\");\n    } else if (grade > 0.7f) {\n      letter_grades.push_back(\"D\");\n    } else if (grade > 0.0f) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float grade : grades) {\n    if (grade == 4.0f) {\n      letter_grades.push_back(\"A+\");\n    } else if (grade > 3.7f) {\n      letter_grades.push_back(\"A\");\n    } else if (grade > 3.3f) {\n      letter_grades.push_back(\"A-\");\n    } else if (grade > 3.0f) {\n      letter_grades.push_back(\"B+\");\n    } else if (grade > 2.7f) {\n      letter_grades.push_back(\"B\");\n    } else if (grade > 2.3f) {\n      letter_grades.push_back(\"B-\");\n    } else if (grade > 2.0f) {\n      letter_grades.push_back(\"C+\");\n    } else if (grade > 1.7f) {\n      letter_grades.push_back(\"C\");\n    } else if (grade > 1.3f) {\n      letter_grades.push_back(\"C-\");\n    } else if (grade > 1.0f) {\n      letter_grades.push_back(\"D+\");\n    } else if (grade > 0.7f) {\n      letter_grades.push_back(\"D\");\n    } else if (grade > 0.0f) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float grade : grades) {\n    if (grade == 4.0f) {\n      letter_grades.push_back(\"A+\");\n    } else if (grade > 3.7f) {\n      letter_grades.push_back(\"A\");\n    } else if (grade > 3.3f) {\n      letter_grades.push_back(\"A-\");\n    } else if (grade > 3.0f) {\n      letter_grades.push_back(\"B+\");\n    } else if (grade > 2.7f) {\n      letter_grades.push_back(\"B\");\n    } else if (grade > 2.3f) {\n      letter_grades.push_back(\"B-\");\n    } else if (grade > 2.0f) {\n      letter_grades.push_back(\"C+\");\n    } else if (grade > 1.7f) {\n      letter_grades.push_back(\"C\");\n    } else if (grade > 1.3f) {\n      letter_grades.push_back(\"C-\");\n    } else if (grade > 1.0f) {\n      letter_grades.push_back(\"D+\");\n    } else if (grade > 0.7f) {\n      letter_grades.push_back(\"D\");\n    } else if (grade > 0.0f) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\nstd::vector<std::string> letter_grades;\nfor (auto grade : grades) {\n    if (grade == 4.0) {\n        letter_grades.push_back(\"A+\");\n    } else if (grade > 3.7) {\n        letter_grades.push_back(\"A\");\n    } else if (grade > 3.3) {\n        letter_grades.push_back(\"A-\");\n    } else if (grade > 3.0) {\n        letter_grades.push_back(\"B+\");\n    } else if (grade > 2.7) {\n        letter_grades.push_back(\"B\");\n    } else if (grade > 2.3) {\n        letter_grades.push_back(\"B-\");\n    } else if (grade > 2.0) {\n        letter_grades.push_back(\"C+\");\n    } else if (grade > 1.7) {\n        letter_grades.push_back(\"C\");\n    } else if (grade > 1.3) {\n        letter_grades.push_back(\"C-\");\n    } else if (grade > 1.0) {\n        letter_grades.push_back(\"D+\");\n    } else if (grade > 0.7) {\n        letter_grades.push_back(\"D\");\n    } else if (grade > 0.0) {\n        letter_grades.push_back(\"D-\");\n    } else {\n        letter_grades.push_back(\"E\");\n    }\n}\nreturn letter_grades;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float grade : grades) {\n    if (grade == 4.0) {\n      letter_grades.push_back(\"A+\");\n    } else if (grade > 3.7) {\n      letter_grades.push_back(\"A\");\n    } else if (grade > 3.3) {\n      letter_grades.push_back(\"A-\");\n    } else if (grade > 3.0) {\n      letter_grades.push_back(\"B+\");\n    } else if (grade > 2.7) {\n      letter_grades.push_back(\"B\");\n    } else if (grade > 2.3) {\n      letter_grades.push_back(\"B-\");\n    } else if (grade > 2.0) {\n      letter_grades.push_back(\"C+\");\n    } else if (grade > 1.7) {\n      letter_grades.push_back(\"C\");\n    } else if (grade > 1.3) {\n      letter_grades.push_back(\"C-\");\n    } else if (grade > 1.0) {\n      letter_grades.push_back(\"D+\");\n    } else if (grade > 0.7) {\n      letter_grades.push_back(\"D\");\n    } else if (grade > 0.0) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float grade : grades) {\n    if (grade == 4.0) {\n      letter_grades.push_back(\"A+\");\n    } else if (grade > 3.7) {\n      letter_grades.push_back(\"A\");\n    } else if (grade > 3.3) {\n      letter_grades.push_back(\"A-\");\n    } else if (grade > 3.0) {\n      letter_grades.push_back(\"B+\");\n    } else if (grade > 2.7) {\n      letter_grades.push_back(\"B\");\n    } else if (grade > 2.3) {\n      letter_grades.push_back(\"B-\");\n    } else if (grade > 2.0) {\n      letter_grades.push_back(\"C+\");\n    } else if (grade > 1.7) {\n      letter_grades.push_back(\"C\");\n    } else if (grade > 1.3) {\n      letter_grades.push_back(\"C-\");\n    } else if (grade > 1.0) {\n      letter_grades.push_back(\"D+\");\n    } else if (grade > 0.7) {\n      letter_grades.push_back(\"D\");\n    } else if (grade > 0.0) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float grade : grades) {\n    if (grade == 4.0f) letter_grades.push_back(\"A+\");\n    else if (grade > 3.7f) letter_grades.push_back(\"A\");\n    else if (grade > 3.3f) letter_grades.push_back(\"A-\");\n    else if (grade > 3.0f) letter_grades.push_back(\"B+\");\n    else if (grade > 2.7f) letter_grades.push_back(\"B\");\n    else if (grade > 2.3f) letter_grades.push_back(\"B-\");\n    else if (grade > 2.0f) letter_grades.push_back(\"C+\");\n    else if (grade > 1.7f) letter_grades.push_back(\"C\");\n    else if (grade > 1.3f) letter_grades.push_back(\"C-\");\n    else if (grade > 1.0f) letter_grades.push_back(\"D+\");\n    else if (grade > 0.7f) letter_grades.push_back(\"D\");\n    else if (grade > 0.0f) letter_grades.push_back(\"D-\");\n    else letter_grades.push_back(\"E\");\n  }\n  return letter_grades;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float grade : grades) {\n    if (grade == 4.0f) {\n      letter_grades.push_back(\"A+\");\n    } else if (grade > 3.7f) {\n      letter_grades.push_back(\"A\");\n    } else if (grade > 3.3f) {\n      letter_grades.push_back(\"A-\");\n    } else if (grade > 3.0f) {\n      letter_grades.push_back(\"B+\");\n    } else if (grade > 2.7f) {\n      letter_grades.push_back(\"B\");\n    } else if (grade > 2.3f) {\n      letter_grades.push_back(\"B-\");\n    } else if (grade > 2.0f) {\n      letter_grades.push_back(\"C+\");\n    } else if (grade > 1.7f) {\n      letter_grades.push_back(\"C\");\n    } else if (grade > 1.3f) {\n      letter_grades.push_back(\"C-\");\n    } else if (grade > 1.0f) {\n      letter_grades.push_back(\"D+\");\n    } else if (grade > 0.7f) {\n      letter_grades.push_back(\"D\");\n    } else if (grade > 0.0f) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float grade : grades) {\n    if (grade == 4.0) {\n      letter_grades.push_back(\"A+\");\n    } else if (grade > 3.7) {\n      letter_grades.push_back(\"A\");\n    } else if (grade > 3.3) {\n      letter_grades.push_back(\"A-\");\n    } else if (grade > 3.0) {\n      letter_grades.push_back(\"B+\");\n    } else if (grade > 2.7) {\n      letter_grades.push_back(\"B\");\n    } else if (grade > 2.3) {\n      letter_grades.push_back(\"B-\");\n    } else if (grade > 2.0) {\n      letter_grades.push_back(\"C+\");\n    } else if (grade > 1.7) {\n      letter_grades.push_back(\"C\");\n    } else if (grade > 1.3) {\n      letter_grades.push_back(\"C-\");\n    } else if (grade > 1.0) {\n      letter_grades.push_back(\"D+\");\n    } else if (grade > 0.7) {\n      letter_grades.push_back(\"D\");\n    } else if (grade > 0.0) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n  std::vector<long> result;\n  for (int i = 0; i < numbers.size(); i++) {\n    if (i != 0) {\n      result.push_back(delimeter);\n    }\n    result.push_back(numbers[i]);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n  std::vector<long> result;\n  for (int i = 0; i < numbers.size(); i++) {\n    if (i > 0) {\n      result.push_back(delimeter);\n    }\n    result.push_back(numbers[i]);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n  std::vector<long> result;\n  for (int i = 0; i < numbers.size(); i++) {\n    if (i != 0) {\n      result.push_back(delimeter);\n    }\n    result.push_back(numbers[i]);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n  std::vector<long> result;\n  for (int i = 0; i < numbers.size(); i++) {\n    if (i > 0) {\n      result.push_back(delimeter);\n    }\n    result.push_back(numbers[i]);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n  std::vector<long> result;\n  for (int i = 0; i < numbers.size(); i++) {\n    if (i > 0) {\n      result.push_back(delimeter);\n    }\n    result.push_back(numbers[i]);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n  std::vector<long> result;\n  for(int i = 0; i < numbers.size(); i++){\n    if(i != 0){\n      result.push_back(delimeter);\n    }\n    result.push_back(numbers[i]);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n  std::vector<long> result;\n  for (int i = 0; i < numbers.size(); i++) {\n    if (i != 0) {\n      result.push_back(delimeter);\n    }\n    result.push_back(numbers[i]);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n  std::vector<long> result;\n  for (int i = 0; i < numbers.size(); i++) {\n    if (i > 0) {\n      result.push_back(delimeter);\n    }\n    result.push_back(numbers[i]);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n  std::vector<long> result;\n  for (int i = 0; i < numbers.size(); i++) {\n    if (i > 0) {\n      result.push_back(delimeter);\n    }\n    result.push_back(numbers[i]);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n  std::vector<long> result;\n  for (int i = 0; i < numbers.size(); i++) {\n    if (i != 0) {\n      result.push_back(delimeter);\n    }\n    result.push_back(numbers[i]);\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n  long count = 0;\n  for (long num : nums) {\n    if (num > 10) {\n      long firstDigit = num;\n      while (firstDigit >= 10) {\n        firstDigit /= 10;\n      }\n      long lastDigit = num % 10;\n      if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n  long count = 0;\n  for (long num : nums) {\n    if (num > 10) {\n      long firstDigit = num;\n      while (firstDigit >= 10)\n        firstDigit /= 10;\n      long lastDigit = num % 10;\n      if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n  long count = 0;\n  for (long num : nums) {\n    if (num > 10) {\n      long firstDigit = std::abs(num);\n      while (firstDigit >= 10)\n        firstDigit /= 10;\n      long lastDigit = std::abs(num) % 10;\n      if (firstDigit % 2 != 0 && lastDigit % 2 != 0)\n        count++;\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n  long count = 0;\n  for (auto num : nums) {\n    if (num > 10) {\n      long first_digit, last_digit;\n      last_digit = abs(num) % 10;\n      while (num != 0) {\n        first_digit = num % 10;\n        num = num / 10;\n      }\n      if (first_digit % 2 != 0 && last_digit % 2 != 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n  long count = 0;\n  for (long num : nums) {\n    if (num > 10) {\n      long firstDigit = num;\n      while (firstDigit >= 10)\n        firstDigit /= 10;\n      long lastDigit = num % 10;\n      if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n  long count = 0;\n  for (auto num : nums) {\n    if (num > 10) {\n      long firstDigit = num;\n      while (firstDigit >= 10) {\n        firstDigit /= 10;\n      }\n      if (firstDigit % 2 != 0 && num % 10 % 2 != 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n  long count = 0;\n  for (auto num : nums) {\n    if (num > 10) {\n      long first = num;\n      while (first >= 10) {\n        first /= 10;\n      }\n      if (first % 2 != 0 && num % 2 != 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n  long count = 0;\n  for (auto num : nums) {\n    if (num > 10) {\n      long first_digit = num;\n      while (first_digit >= 10) {\n        first_digit /= 10;\n      }\n      long last_digit = num % 10;\n      if (first_digit % 2 != 0 && last_digit % 2 != 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n  long count = 0;\n  for (long num : nums) {\n    if (num > 10) {\n      long firstDigit = num;\n      while (firstDigit >= 10) {\n        firstDigit /= 10;\n      }\n      long lastDigit = num % 10;\n      if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n  long count = 0;\n  for (auto num : nums) {\n    if (num > 10) {\n      long firstDigit = num;\n      while (firstDigit >= 10) {\n        firstDigit /= 10;\n      }\n      if (firstDigit % 2 != 0 && num % 10 % 2 != 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n  return n * (n + 1) / 2;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n  return n * (n + 1) / 2;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n  return n * (n + 1) / 2;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n  return n * (n + 1) / 2;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n  return n * (n + 1) / 2;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n  return n * (n + 1) / 2;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n  return n * (n + 1) / 2;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n  return n * (n + 1) / 2;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n  return n * (n + 1) / 2;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n  return n * (n + 1) / 2;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::vector<long> result;\n  std::unordered_set<long> seen;\n\n  for (long number : numbers) {\n    if (seen.find(number) == seen.end()) {\n      seen.insert(number);\n      result.push_back(number);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::vector<long> result;\n  std::unordered_set<long> seen;\n\n  for (auto num : numbers) {\n    if (seen.find(num) == seen.end()) {\n      seen.insert(num);\n      result.push_back(num);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::vector<long> result;\n  std::unordered_set<long> seen;\n\n  for (auto num : numbers) {\n    if (seen.find(num) == seen.end()) {\n      seen.insert(num);\n      result.push_back(num);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::vector<long> result;\n  std::unordered_set<long> seen;\n\n  for (auto num : numbers) {\n    if (seen.find(num) == seen.end()) {\n      result.push_back(num);\n      seen.insert(num);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::vector<long> result;\n  std::unordered_set<long> seen;\n\n  for (auto num : numbers) {\n    if (seen.find(num) == seen.end()) {\n      seen.insert(num);\n      result.push_back(num);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::vector<long> result;\n  std::unordered_set<long> seen;\n\n  for (const auto &number : numbers) {\n    if (seen.find(number) == seen.end()) {\n      seen.insert(number);\n      result.push_back(number);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::vector<long> result;\n  std::unordered_set<long> seen;\n\n  for (auto num : numbers) {\n    if (seen.find(num) == seen.end()) {\n      seen.insert(num);\n      result.push_back(num);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::vector<long> result;\n  std::unordered_set<long> seen;\n\n  for (auto num : numbers) {\n    if (seen.find(num) == seen.end()) {\n      seen.insert(num);\n      result.push_back(num);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::vector<long> result;\n  std::unordered_set<long> seen;\n\n  for (auto num : numbers) {\n    if (seen.find(num) == seen.end()) {\n      seen.insert(num);\n      result.push_back(num);\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::vector<long> result;\n  std::unordered_set<long> seen;\n  \n  for (const auto& number : numbers) {\n    if (seen.find(number) == seen.end()) {\n      seen.insert(number);\n      result.push_back(number);\n    }\n  }\n  \n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  if (a > b) std::swap(a, b);\n  for (long i = a; i <= b; i++) {\n    if (i % 2 == 0) {\n      result.push_back(i);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  if (a > b) {\n    std::swap(a, b);\n  }\n  for (long i = a; i <= b; i++) {\n    if (i % 2 == 0) {\n      result.push_back(i);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  if(a > b) std::swap(a, b);\n  for(long i = a; i <= b; i++) {\n    if(i % 2 == 0) {\n      result.push_back(i);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  if (a > b) {\n    std::swap(a, b);\n  }\n  for (long i = a; i <= b; i++) {\n    if (i % 2 == 0) {\n      result.push_back(i);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  if (a > b) std::swap(a, b);\n  for (long i = a; i <= b; i++) {\n    if (i % 2 == 0) {\n      result.push_back(i);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  if (a > b) std::swap(a, b);\n  for (long i = a; i <= b; i++) {\n    if (i % 2 == 0) {\n      result.push_back(i);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  if (a > b) {\n    std::swap(a, b);\n  }\n  for (long i = a; i <= b; i++) {\n    if (i % 2 == 0) {\n      result.push_back(i);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  if (a > b) std::swap(a, b);\n  for (long i = a; i <= b; i++) {\n    if (i % 2 == 0) {\n      result.push_back(i);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  if(a > b) std::swap(a, b);\n  for(long i = a; i <= b; i++) {\n    if(i % 2 == 0) {\n      result.push_back(i);\n    }\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  if (a > b) {\n    std::swap(a, b);\n  }\n  for (long i = a; i <= b; i++) {\n    if (i % 2 == 0) {\n      result.push_back(i);\n    }\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n  std::vector<long> result;\n  long max = numbers[0];\n  for (long number : numbers) {\n    if (number > max) {\n      max = number;\n    }\n    result.push_back(max);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n  std::vector<long> result;\n  long max = numbers[0];\n  for (long number : numbers) {\n    if (number > max) {\n      max = number;\n    }\n    result.push_back(max);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n  std::vector<long> result;\n  long max = numbers[0];\n  for (auto num : numbers) {\n    if (num > max) {\n      max = num;\n    }\n    result.push_back(max);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n  std::vector<long> result;\n  long max = numbers[0];\n  for (long number : numbers) {\n    if (number > max) {\n      max = number;\n    }\n    result.push_back(max);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n  std::vector<long> result;\n  long max = numbers[0];\n  for (long number : numbers) {\n    if (number > max) {\n      max = number;\n    }\n    result.push_back(max);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n  std::vector<long> result;\n  long max = numbers[0];\n  for (long number : numbers) {\n    if (number > max) {\n      max = number;\n    }\n    result.push_back(max);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n  std::vector<long> result;\n  long max = numbers[0];\n  for (long number : numbers) {\n    if (number > max) {\n      max = number;\n    }\n    result.push_back(max);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n  std::vector<long> result;\n  long max = numbers[0];\n  for (long number : numbers) {\n    if (number > max) {\n      max = number;\n    }\n    result.push_back(max);\n  }\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n  std::vector<long> max_numbers;\n  long max_num = numbers[0];\n  for (long num : numbers) {\n    if (num > max_num) {\n      max_num = num;\n    }\n    max_numbers.push_back(max_num);\n  }\n  return max_numbers;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n  std::vector<long> result;\n  long max = numbers[0];\n  for (long number : numbers) {\n    if (number > max) {\n      max = number;\n    }\n    result.push_back(max);\n  }\n  return result;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long operation : operations) {\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long operation : operations) {\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long operation : operations) {\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long operation : operations) {\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long operation : operations) {\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long operation : operations) {\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long operation : operations) {\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long operation : operations) {\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long operation : operations) {\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long operation : operations) {\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n  std::map<long, long> freq;\n  for (auto &i : lst) {\n    freq[i]++;\n  }\n  \n  long max_val = -1;\n  for (auto &i : freq) {\n    if (i.first <= i.second) {\n      max_val = std::max(max_val, i.first);\n    }\n  }\n  \n  return max_val;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n  std::map<long, long> freq;\n  for(auto& num : lst) {\n    freq[num]++;\n  }\n  long maxNum = -1;\n  for(auto& pair : freq) {\n    if(pair.first <= pair.second && pair.first > maxNum) {\n      maxNum = pair.first;\n    }\n  }\n  return maxNum;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n  std::map<long, long> freq;\n  long max_val = -1;\n  for (auto& val : lst) {\n    freq[val]++;\n    if (freq[val] >= val) {\n      max_val = std::max(max_val, val);\n    }\n  }\n  return max_val;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n  std::map<long, long> count;\n  for (long i : lst) {\n    count[i]++;\n  }\n  long max_val = -1;\n  for (auto i : count) {\n    if (i.first <= i.second && i.first > max_val) {\n      max_val = i.first;\n    }\n  }\n  return max_val;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n  std::map<long, long> freq;\n  for (auto& i : lst) {\n    freq[i]++;\n  }\n\n  long max_val = -1;\n  for (auto& i : freq) {\n    if (i.first <= i.second) {\n      max_val = std::max(max_val, i.first);\n    }\n  }\n\n  return max_val;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n  std::map<long, long> freq;\n  for (long num : lst) {\n    freq[num]++;\n  }\n  \n  long res = -1;\n  for (auto it : freq) {\n    if (it.first <= it.second && it.first > res) {\n      res = it.first;\n    }\n  }\n  return res;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n  std::map<long, long> freq;\n  for (auto num : lst) {\n    freq[num]++;\n  }\n  \n  long max_value = -1;\n  for (auto it : freq) {\n    if (it.first <= it.second && it.first > max_value) {\n      max_value = it.first;\n    }\n  }\n  \n  return max_value;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n  std::map<long, long> frequency;\n\n  for (long num : lst) {\n    frequency[num]++;\n  }\n\n  long result = -1;\n  for (auto it : frequency) {\n    if (it.first <= it.second && it.first > result) {\n      result = it.first;\n    }\n  }\n\n  return result;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n  std::map<long, long> freq;\n  for (long num : lst) {\n    freq[num]++;\n  }\n  \n  long max_val = -1;\n  for (auto &pair : freq) {\n    if (pair.first <= pair.second && pair.first > max_val) {\n      max_val = pair.first;\n    }\n  }\n  \n  return max_val;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n  std::map<long, long> freq;\n  for (long num : lst) {\n    freq[num]++;\n  }\n  long max_val = -1;\n  for (auto it : freq) {\n    if (it.first <= it.second && it.first > max_val) {\n      max_val = it.first;\n    }\n  }\n  return max_val;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int balance = 0;\n  for (char c : brackets) {\n    if (c == '(') {\n      balance++;\n    } else if (c == ')') {\n      balance--;\n      if (balance < 0) {\n        return false;\n      }\n    }\n  }\n  return balance == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int balance = 0;\n  for (char c : brackets) {\n    if (c == '(') {\n      balance++;\n    } else if (c == ')') {\n      balance--;\n      if (balance < 0) {\n        return false;\n      }\n    }\n  }\n  return balance == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int counter = 0;\n  for (char& c : brackets) {\n    if (c == '(') {\n      counter++;\n    } else if (c == ')') {\n      counter--;\n    }\n    if (counter < 0) {\n      return false;\n    }\n  }\n  return counter == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int balance = 0;\n  for (char c : brackets) {\n    if (c == '(') {\n      balance++;\n    } else if (c == ')') {\n      balance--;\n      if (balance < 0) {\n        return false;\n      }\n    }\n  }\n  return balance == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int balance = 0;\n  for (char c : brackets) {\n    if (c == '(') {\n      balance++;\n    } else if (c == ')') {\n      balance--;\n      if (balance < 0) {\n        return false;\n      }\n    }\n  }\n  return balance == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int balance = 0;\n  for (char c : brackets) {\n    if (c == '(') {\n      balance++;\n    } else if (c == ')') {\n      balance--;\n    }\n    if (balance < 0) {\n      return false;\n    }\n  }\n  return balance == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int balance = 0;\n  for (char c : brackets) {\n    if (c == '(') {\n      balance++;\n    } else if (c == ')') {\n      balance--;\n    }\n    if (balance < 0) {\n      return false;\n    }\n  }\n  return balance == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int balance = 0;\n  for (char c : brackets) {\n    if (c == '(') {\n      balance++;\n    } else if (c == ')') {\n      balance--;\n      if (balance < 0) {\n        return false;\n      }\n    }\n  }\n  return balance == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int counter = 0;\n  for (char& c : brackets) {\n    if (c == '(') {\n      counter++;\n    } else if (c == ')') {\n      counter--;\n    }\n    if (counter < 0) {\n      return false;\n    }\n  }\n  return counter == 0;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n  std::vector<long> even_elements;\n  for(int i = 0; i < l.size(); i += 2) {\n    even_elements.push_back(l[i]);\n  }\n  std::sort(even_elements.begin(), even_elements.end());\n\n  for(int i = 0, j = 0; i < l.size(); i += 2, j++) {\n    l[i] = even_elements[j];\n  }\n  \n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n  std::vector<long> even_indices;\n  for (int i = 0; i < l.size(); i += 2) {\n    even_indices.push_back(l[i]);\n  }\n  std::sort(even_indices.begin(), even_indices.end());\n  for (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n    l[i] = even_indices[j];\n  }\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n  std::vector<long> even_elements;\n  for (int i = 0; i < l.size(); i += 2) {\n    even_elements.push_back(l[i]);\n  }\n  \n  std::sort(even_elements.begin(), even_elements.end());\n\n  for (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n    l[i] = even_elements[j];\n  }\n\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n  std::vector<long> even_values;\n  \n  for (int i = 0; i < l.size(); i += 2) {\n    even_values.push_back(l[i]);\n  }\n  \n  std::sort(even_values.begin(), even_values.end());\n  \n  for (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n    l[i] = even_values[j];\n  }\n  \n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\nstd::vector<long> even;\nfor (int i = 0; i < l.size(); i += 2) {\n    even.push_back(l[i]);\n}\nstd::sort(even.begin(), even.end());\nfor (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n    l[i] = even[j];\n}\nreturn l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n  std::vector<long> even_indices_values;\n  for (int i = 0; i < l.size(); i += 2) {\n    even_indices_values.push_back(l[i]);\n  }\n  \n  std::sort(even_indices_values.begin(), even_indices_values.end());\n\n  for (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n    l[i] = even_indices_values[j];\n  }\n\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n  std::vector<long> even_elements;\n  for (int i = 0; i < l.size(); i += 2) {\n    even_elements.push_back(l[i]);\n  }\n  std::sort(even_elements.begin(), even_elements.end());\n  \n  for (int i = 0, j = 0; i < l.size(); i += 2, ++j) {\n    l[i] = even_elements[j];\n  }\n  \n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n  std::vector<long> even_values;\n  for (int i = 0; i < l.size(); i += 2) {\n    even_values.push_back(l[i]);\n  }\n  std::sort(even_values.begin(), even_values.end());\n\n  int j = 0;\n  for (int i = 0; i < l.size(); i += 2) {\n    l[i] = even_values[j++];\n  }\n\n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n  std::vector<long> even_values;\n  for (int i = 0; i < l.size(); i += 2) {\n    even_values.push_back(l[i]);\n  }\n  std::sort(even_values.begin(), even_values.end());\n  \n  int j = 0;\n  for (int i = 0; i < l.size(); i += 2) {\n    l[i] = even_values[j++];\n  }\n  \n  return l;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n  std::vector<long> even_elems;\n  for (int i = 0; i < l.size(); i += 2) {\n    even_elems.push_back(l[i]);\n  }\n  std::sort(even_elems.begin(), even_elems.end());\n\n  for (int i = 0, j = 0; i < l.size(); i += 2, ++j) {\n    l[i] = even_elems[j];\n  }\n\n  return l;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(), s1.end());\n\n  return s0 == s1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(), s1.end());\n\n  return s0 == s1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(), s1.end());\n\n  return s0 == s1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(), s1.end());\n  \n  return s0 == s1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(), s1.end());\n\n  return s0 == s1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(), s1.end());\n  return s0 == s1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(), s1.end());\n\n  return s0 == s1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(), s1.end());\n  \n  return s0 == s1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(), s1.end());\n  \n  return s0 == s1;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(), s1.end());\n\n  return s0 == s1;\n}"
    ],
    [
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int balance = 0;\n  for (char c : brackets) {\n    if (c == '<') {\n      balance++;\n    } else if (c == '>') {\n      balance--;\n    }\n    if (balance < 0) {\n      return false;\n    }\n  }\n  return balance == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int balance = 0;\n  for (char c : brackets) {\n    if (c == '<') {\n      balance++;\n    } else if (c == '>') {\n      if (balance == 0) {\n        return false;\n      }\n      balance--;\n    }\n  }\n  return balance == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int counter = 0;\n  for (char& c : brackets) {\n    if (c == '<') {\n      counter++;\n    } else if (c == '>') {\n      counter--;\n    }\n    if (counter < 0) {\n      return false;\n    }\n  }\n  return counter == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int balance = 0;\n  for (char c : brackets) {\n    if (c == '<') {\n      balance++;\n    } else if (c == '>') {\n      if (balance == 0) {\n        return false;\n      }\n      balance--;\n    }\n  }\n  return balance == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int balance = 0;\n  for (char c : brackets) {\n    if (c == '<') {\n      balance++;\n    } else if (c == '>') {\n      if (balance == 0) {\n        return false;\n      }\n      balance--;\n    }\n  }\n  return balance == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int counter = 0;\n  for (char c : brackets) {\n    if (c == '<') {\n      counter++;\n    } else if (c == '>') {\n      counter--;\n    }\n    if (counter < 0) {\n      return false;\n    }\n  }\n  return counter == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int counter = 0;\n  for (char c : brackets) {\n    if (c == '<') {\n      counter++;\n    } else if (c == '>') {\n      counter--;\n    }\n    if (counter < 0) {\n      return false;\n    }\n  }\n  return counter == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int balance = 0;\n  for (char c : brackets) {\n    if (c == '<') {\n      balance++;\n    } else if (c == '>') {\n      if (balance == 0) {\n        return false;\n      }\n      balance--;\n    }\n  }\n  return balance == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int counter = 0;\n  for (char c : brackets) {\n    if (c == '<') {\n      counter++;\n    } else if (c == '>') {\n      if (counter == 0) {\n        return false;\n      }\n      counter--;\n    }\n  }\n  return counter == 0;\n}",
        "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  int counter = 0;\n  for (char c : brackets) {\n    if (c == '<') {\n      counter++;\n    } else if (c == '>') {\n      if (counter == 0) {\n        return false;\n      }\n      counter--;\n    }\n  }\n  return counter == 0;\n}"
    ]
]