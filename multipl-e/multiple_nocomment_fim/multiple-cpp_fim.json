[
  {
    "name": "HumanEval_23_strlen",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nlong string_length(std::string string) {\n",
    "canonical_solution": "return string.length();",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nlong string_length(std::string string) {\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_89_encrypt",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string encrypt(std::string s) {\n",
    "canonical_solution": "for (int i = 0; i < s.length(); i++) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string encrypt(std::string s) {\n  ",
    "suffix": "\n    char c = s[i];\n    if (isalpha(c)) {\n      char a = isupper(c) ? 'A' : 'a';\n      s[i] = a + (c - a + 4) % 26;\n    }\n  }\n  return s;\n}"
  },
  {
    "name": "HumanEval_95_check_dict_case",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool check_dict_case(std::map<std::string,std::string> dict) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_85_add",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\nlong add(std::vector<long> lst) {\n",
    "canonical_solution": "for (int i = 1; i < lst.size(); i += 2) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  ",
    "suffix": "\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}"
  },
  {
    "name": "HumanEval_140_fix_spaces",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nstd::string fix_spaces(std::string text) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_63_fibfib",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\nlong fibfib(long n) {\n",
    "canonical_solution": "b = c;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\nlong fibfib(long n) {\n  if (n == 0 || n == 1) \n    return 0;\n  if (n == 2) \n    return 1;\n\n  long a = 0, b = 0, c = 1, d;\n\n  for (long i = 3; i <= n; i++) {\n    d = a + b + c;\n    a = b;\n    ",
    "suffix": "\n    c = d;\n  }\n\n  return c;\n}"
  },
  {
    "name": "HumanEval_151_double_the_difference",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nlong double_the_difference(std::vector<float> lst) {\n",
    "canonical_solution": "long sum = 0;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nlong double_the_difference(std::vector<float> lst) {\n  ",
    "suffix": "\n  for (int i = 0; i < lst.size(); i++) {\n    if (lst[i] > 0 && lst[i] == (int)lst[i] && (int)lst[i] % 2 != 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n}"
  },
  {
    "name": "HumanEval_22_filter_integers",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_41_car_race_collision",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nlong car_race_collision(long n) {\n",
    "canonical_solution": "return n * n;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nlong car_race_collision(long n) {\n  \n  \n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_17_parse_music",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nstd::vector<long> parse_music(std::string music_string) {\n",
    "canonical_solution": "while (iss >> note) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nstd::vector<long> parse_music(std::string music_string) {\n  std::vector<long> beats;\n  std::istringstream iss(music_string);\n  std::string note;\n  \n  ",
    "suffix": "\n    if (note == \"o\") {\n      beats.push_back(4);\n    } else if (note == \"o|\") {\n      beats.push_back(2);\n    } else if (note == \".|\") {\n      beats.push_back(1);\n    }\n  }\n  \n  return beats;\n}"
  },
  {
    "name": "HumanEval_79_decimal_to_binary",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nstd::string decimal_to_binary(long decimal) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_14_all_prefixes",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\nstd::vector<std::string> all_prefixes(std::string string) {\n",
    "canonical_solution": "for (int i = 0; i < string.length(); i++) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\nstd::vector<std::string> all_prefixes(std::string string) {\n  std::vector<std::string> prefixes;\n  ",
    "suffix": "\n    prefixes.push_back(string.substr(0, i+1));\n  }\n  return prefixes;\n}"
  },
  {
    "name": "HumanEval_53_add",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nlong add(long x, long y) {\n",
    "canonical_solution": "return x + y;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nlong add(long x, long y) {\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_159_eat",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> eat(long number, long need, long remaining) {\n",
    "canonical_solution": "} else {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> eat(long number, long need, long remaining) {\n  long totalEaten = number;\n  if (remaining >= need) {\n    totalEaten += need;\n    remaining -= need;\n  ",
    "suffix": "\n    totalEaten += remaining;\n    remaining = 0;\n  }\n  return std::vector<long>({totalEaten, remaining});\n}"
  },
  {
    "name": "HumanEval_115_max_fill",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_160_do_algebra",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_27_flip_case",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\nstd::string flip_case(std::string string) {\n",
    "canonical_solution": "if (isupper(string[i])) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\nstd::string flip_case(std::string string) {\n  for (int i = 0; i < string.length(); i++) {\n    ",
    "suffix": "\n      string[i] = tolower(string[i]);\n    } else if (islower(string[i])) {\n      string[i] = toupper(string[i]);\n    }\n  }\n  return string;\n}"
  },
  {
    "name": "HumanEval_105_by_length",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<std::string> by_length(std::vector<long> arr) {\n",
    "canonical_solution": "std::vector<long> temp;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  ",
    "suffix": "\n  std::vector<std::string> result;\n  std::map<long, std::string> numToString = {{1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n\n  for (auto num : arr) {\n    if (num >= 1 && num <= 9) {\n      temp.push_back(num);\n    }\n  }\n\n  std::sort(temp.begin(), temp.end());\n  std::reverse(temp.begin(), temp.end());\n\n  for (auto num : temp) {\n    result.push_back(numToString[num]);\n  }\n\n  return result;\n}"
  },
  {
    "name": "HumanEval_25_factorize",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nstd::vector<long> factorize(long n) {\n",
    "canonical_solution": "factors.push_back(i);",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nstd::vector<long> factorize(long n) {\n  std::vector<long> factors;\n  for (long i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      ",
    "suffix": "\n      n /= i;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}"
  },
  {
    "name": "HumanEval_96_count_up_to",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> count_up_to(long n) {\n",
    "canonical_solution": "isPrime = false;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  for (long i = 2; i < n; i++) {\n    bool isPrime = true;\n    for (long j = 2; j * j <= i; j++) {\n      if (i % j == 0) {\n        ",
    "suffix": "\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push_back(i);\n    }\n  }\n  return primes;\n}"
  },
  {
    "name": "HumanEval_34_unique",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\nstd::vector<long> unique(std::vector<long> l) {\n",
    "canonical_solution": "l.erase(std::unique(l.begin(), l.end()), l.end());",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\nstd::vector<long> unique(std::vector<long> l) {\n  std::sort(l.begin(), l.end());\n  ",
    "suffix": "\n  return l;\n}"
  },
  {
    "name": "HumanEval_74_total_match",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n",
    "canonical_solution": "return len1 <= len2 ? lst1 : lst2;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  int len1 = 0, len2 = 0;\n  for (const auto& str : lst1) {\n    len1 += str.length();\n  }\n  for (const auto& str : lst2) {\n    len2 += str.length();\n  }\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_35_max_element",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nlong max_element(std::vector<long> l) {\n",
    "canonical_solution": "return max;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nlong max_element(std::vector<long> l) {\n  long max = l[0];\n  for(int i = 1; i < l.size(); i++) {\n    if(l[i] > max) {\n      max = l[i];\n    }\n  }\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_132_is_nested",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool is_nested(std::string string) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_103_rounded_avg",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnion_std_string_long rounded_avg(long n, long m) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_113_odd_count",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n",
    "canonical_solution": "return result;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (auto &str : lst) {\n    int oddCount = 0;\n    for (char c : str) {\n      if ((c - '0') % 2 != 0) {\n        oddCount++;\n      }\n    }\n    std::string res = \"the number of odd elements \" + std::to_string(oddCount) + \"n the str\" + std::to_string(oddCount) + \"ng \" + std::to_string(oddCount) + \" of the \" + std::to_string(oddCount) + \"nput.\";\n    result.push_back(res);\n  }\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_109_move_one_ball",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool move_one_ball(std::vector<long> arr) {\n",
    "canonical_solution": "count++;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool move_one_ball(std::vector<long> arr) {\n  if(arr.empty()) return true;\n  \n  int count = 0;\n  for(int i = 0; i < arr.size() - 1; i++) {\n    if(arr[i] > arr[i+1]) {\n      count++;\n    }\n  }\n  \n  if(arr.back() > arr.front()) {\n    ",
    "suffix": "\n  }\n  \n  return count <= 1;\n}"
  },
  {
    "name": "HumanEval_107_even_odd_palindrome",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::tuple<long, long> even_odd_palindrome(long n) {\n",
    "canonical_solution": "long odd_count = 0;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even_count = 0;\n    ",
    "suffix": "\n    for (long i = 1; i <= n; i++) {\n        std::string str = std::to_string(i);\n        std::string rev_str = str;\n        std::reverse(rev_str.begin(), rev_str.end());\n        if (str == rev_str) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    return std::make_tuple(even_count, odd_count);\n}"
  },
  {
    "name": "HumanEval_138_is_equal_to_sum_even",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nbool is_equal_to_sum_even(long n) {\n",
    "canonical_solution": "return false;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nbool is_equal_to_sum_even(long n) {\n  if (n >= 8 && n % 2 == 0) {\n    return true;\n  }\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_62_derivative",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nstd::vector<long> derivative(std::vector<long> xs) {\n",
    "canonical_solution": "return result;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nstd::vector<long> derivative(std::vector<long> xs) {\n  std::vector<long> result;\n  for (int i = 1; i < xs.size(); i++) {\n    result.push_back(xs[i] * i);\n  }\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_126_is_sorted",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool is_sorted(std::vector<long> lst) {\n",
    "canonical_solution": "return false;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool is_sorted(std::vector<long> lst) {\n  std::unordered_map<long, int> count;\n  for (int i = 0; i < lst.size(); i++) {\n    count[lst[i]]++;\n    if (count[lst[i]] > 2)\n      return false;\n    if (i != 0 && lst[i] < lst[i - 1])\n      ",
    "suffix": "\n  }\n  return true;\n}"
  },
  {
    "name": "HumanEval_161_solve",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string solve(std::string s) {\n",
    "canonical_solution": "for (char c : s) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string solve(std::string s) {\n  bool hasLetter = false;\n  ",
    "suffix": "\n    if (isalpha(c)) {\n      hasLetter = true;\n      break;\n    }\n  }\n\n  if (hasLetter) {\n    for (char& c : s) {\n      if (isupper(c)) c = tolower(c);\n      else if (islower(c)) c = toupper(c);\n    }\n  } else {\n    std::reverse(s.begin(), s.end());\n  }\n\n  return s;\n}"
  },
  {
    "name": "HumanEval_130_tri",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> tri(long n) {\n",
    "canonical_solution": "tribonacci[1] = 3;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> tri(long n) {\n  std::vector<long> tribonacci(n + 1);\n  tribonacci[0] = 1;\n  ",
    "suffix": "\n\n  for (long i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      tribonacci[i] = 1 + i / 2;\n    } else {\n      tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + (1 + (i + 1) / 2);\n    }\n  }\n\n  return tribonacci;\n}"
  },
  {
    "name": "HumanEval_36_fizz_buzz",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nlong fizz_buzz(long n) {\n",
    "canonical_solution": "return count;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nlong fizz_buzz(long n) {\n  long count = 0;\n  for (long i = 1; i < n; i++) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      std::string num = std::to_string(i);\n      count += std::count(num.begin(), num.end(), '7');\n    }\n  }\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_29_filter_by_prefix",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n",
    "canonical_solution": "for (const auto& str : strings) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n  std::vector<std::string> result;\n  ",
    "suffix": "\n    if (str.substr(0, prefix.length()) == prefix) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}"
  },
  {
    "name": "HumanEval_84_solve",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string solve(long N) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_129_minPath",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n",
    "canonical_solution": "path.push_back(min_val);",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  std::vector<long> path;\n  long N = grid.size();\n  long min_val = N * N + 1;\n  std::pair<long, long> start;\n\n  \n  for (long i = 0; i < N; ++i) {\n    for (long j = 0; j < N; ++j) {\n      if (grid[i][j] < min_val) {\n        min_val = grid[i][j];\n        start = {i, j};\n      }\n    }\n  }\n\n  \n  ",
    "suffix": "\n\n  \n  for (long i = 1; i < k; ++i) {\n    std::vector<long> neighbours;\n    if (start.first > 0) neighbours.push_back(grid[start.first - 1][start.second]);\n    if (start.first < N - 1) neighbours.push_back(grid[start.first + 1][start.second]);\n    if (start.second > 0) neighbours.push_back(grid[start.first][start.second - 1]);\n    if (start.second < N - 1) neighbours.push_back(grid[start.first][start.second + 1]);\n\n    \n    min_val = *std::min_element(neighbours.begin(), neighbours.end());\n    path.push_back(min_val);\n\n    \n    for (long dx = -1; dx <= 1; ++dx) {\n      for (long dy = -1; dy <= 1; ++dy) {\n        if (std::abs(dx) + std::abs(dy) != 1) continue;\n        long nx = start.first + dx;\n        long ny = start.second + dy;\n        if (nx >= 0 && nx < N && ny >= 0 && ny < N && grid[nx][ny] == min_val) {\n          start = {nx, ny};\n          break;\n        }\n      }\n    }\n  }\n\n  return path;\n}"
  },
  {
    "name": "HumanEval_98_count_upper",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nlong count_upper(std::string s) {\n",
    "canonical_solution": "char c = s[i];",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nlong count_upper(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.length(); i += 2) {\n    ",
    "suffix": "\n    if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n      count++;\n    }\n  }\n  return count;\n}"
  },
  {
    "name": "HumanEval_120_maximum",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n",
    "canonical_solution": "return arr;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.begin(), arr.end(), std::greater<long>());\n  arr.resize(k);\n  std::sort(arr.begin(), arr.end());\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_24_largest_divisor",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\nlong largest_divisor(long n) {\n",
    "canonical_solution": "for (long i = n - 1; i > 0; i--) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\nlong largest_divisor(long n) {\n  ",
    "suffix": "\n    if (n % i == 0) {\n      return i;\n    }\n  }\n  return 1;\n}"
  },
  {
    "name": "HumanEval_88_sort_array",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> sort_array(std::vector<long> array) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_106_f",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nstd::vector<long> f(long n) {\n",
    "canonical_solution": "for (long i = 1; i <= n; i++) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nstd::vector<long> f(long n) {\n  std::vector<long> result(n);\n  ",
    "suffix": "\n    if (i % 2 == 0) {\n      long factorial = 1;\n      for (long j = 1; j <= i; j++) {\n        factorial *= j;\n      }\n      result[i-1] = factorial;\n    } else {\n      long sum = 0;\n      for (long j = 1; j <= i; j++) {\n        sum += j;\n      }\n      result[i-1] = sum;\n    }\n  }\n  return result;\n}"
  },
  {
    "name": "HumanEval_77_iscube",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool iscube(long a) {\n",
    "canonical_solution": "return root * root * root == a;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool iscube(long a) {\n  long root = cbrt(a);\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_93_encode",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nstd::string encode(std::string message) {\n",
    "canonical_solution": "} else {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nstd::string encode(std::string message) {\n    std::string result = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                c = toupper(c);\n                if (c == 'A') c = 'C';\n                else if (c == 'E') c = 'G';\n                else if (c == 'I') c = 'K';\n                else if (c == 'O') c = 'Q';\n                else if (c == 'U') c = 'W';\n            ",
    "suffix": "\n                c = tolower(c);\n                if (c == 'a') c = 'c';\n                else if (c == 'e') c = 'g';\n                else if (c == 'i') c = 'k';\n                else if (c == 'o') c = 'q';\n                else if (c == 'u') c = 'w';\n            }\n        }\n        result += c;\n    }\n    return result;\n}"
  },
  {
    "name": "HumanEval_91_is_bored",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nlong is_bored(std::string S) {\n",
    "canonical_solution": "std::istringstream iss2(sentence);",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nlong is_bored(std::string S) {\n  long count = 0;\n  std::istringstream iss(S);\n  std::string sentence;\n  while (std::getline(iss, sentence, '.')) {\n    ",
    "suffix": "\n    std::string word;\n    if (iss2 >> word && word == \"I\") {\n      count++;\n    }\n  }\n  return count;\n}"
  },
  {
    "name": "HumanEval_43_pairs_sum_to_zero",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool pairs_sum_to_zero(std::vector<long> l) {\n",
    "canonical_solution": "return false;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool pairs_sum_to_zero(std::vector<long> l) {\n  std::unordered_set<long> s;\n  for (long i : l) {\n    if (s.find(-i) != s.end()) {\n      return true;\n    }\n    s.insert(i);\n  }\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_71_triangle_area",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nfloat triangle_area(long a, long b, long c) {\n",
    "canonical_solution": "if (a + b > c && a + c > b && b + c > a) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nfloat triangle_area(long a, long b, long c) {\n  ",
    "suffix": "\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return roundf(area * 100) / 100;\n  } else {\n    return -1;\n  }\n}"
  },
  {
    "name": "HumanEval_148_bf",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n",
    "canonical_solution": "for(auto it = it1 + 1; it < it2; ++it) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n  std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  std::vector<std::string> result;\n  auto it1 = std::find(planets.begin(), planets.end(), planet1);\n  auto it2 = std::find(planets.begin(), planets.end(), planet2);\n  \n  if(it1 == planets.end() || it2 == planets.end()) {\n    return result;\n  }\n  \n  if(it1 > it2) {\n    std::swap(it1, it2);\n  }\n  \n  ",
    "suffix": "\n    result.push_back(*it);\n  }\n  \n  return result;\n}"
  },
  {
    "name": "HumanEval_131_digits",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nlong digits(long n) {\n",
    "canonical_solution": "int digit = n % 10;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nlong digits(long n) {\n  long product = 1;\n  bool hasOdd = false;\n  while (n > 0) {\n    ",
    "suffix": "\n    if (digit % 2 != 0) {\n      product *= digit;\n      hasOdd = true;\n    }\n    n /= 10;\n  }\n  return hasOdd ? product : 0;\n}"
  },
  {
    "name": "HumanEval_101_words_string",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nstd::vector<std::string> words_string(std::string s) {\n",
    "canonical_solution": "for (auto x : s) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word = \"\";\n  ",
    "suffix": "\n    if (x == ' ' || x == ',') {\n      if (!word.empty()) {\n        words.push_back(word);\n        word = \"\";\n      }\n    } else {\n      word = word + x;\n    }\n  }\n  if (!word.empty()) {\n    words.push_back(word);\n  }\n  return words;\n}"
  },
  {
    "name": "HumanEval_18_how_many_times",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nlong how_many_times(std::string string, std::string substring) {\n",
    "canonical_solution": "long count = 0;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nlong how_many_times(std::string string, std::string substring) {\n  ",
    "suffix": "\n  size_t pos = 0;\n  \n  while ((pos = string.find(substring, pos)) != std::string::npos) {\n    count++;\n    pos++;\n  }\n  \n  return count;\n}"
  },
  {
    "name": "HumanEval_137_compare_one",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n\n\n\n\n\n\n\n\n\n\n\n\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_51_remove_vowels",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nstd::string remove_vowels(std::string text) {\n",
    "canonical_solution": "std::string result = \"\";",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nstd::string remove_vowels(std::string text) {\n  ",
    "suffix": "\n  for (char c : text) {\n    if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && \n        c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n      result += c;\n    }\n  }\n  return result;\n}"
  },
  {
    "name": "HumanEval_70_strange_sort_list",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n",
    "canonical_solution": "result.push_back(lst.front());",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  std::sort(lst.begin(), lst.end());\n  std::vector<long> result;\n  while (!lst.empty()) {\n    ",
    "suffix": "\n    lst.erase(lst.begin());\n    if (!lst.empty()) {\n      result.push_back(lst.back());\n      lst.pop_back();\n    }\n  }\n  return result;\n}"
  },
  {
    "name": "HumanEval_20_find_closest_elements",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n",
    "canonical_solution": "std::sort(numbers.begin(), numbers.end());",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n  ",
    "suffix": "\n  float min_diff = std::numeric_limits<float>::max();\n  std::tuple<float, float> closest_pair;\n\n  for (int i = 0; i < numbers.size() - 1; i++) {\n    float diff = numbers[i+1] - numbers[i];\n    if (diff < min_diff) {\n      min_diff = diff;\n      closest_pair = std::make_tuple(numbers[i], numbers[i+1]);\n    }\n  }\n\n  return closest_pair;\n}"
  },
  {
    "name": "HumanEval_76_is_simple_power",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool is_simple_power(long x, long n) {\n",
    "canonical_solution": "if (x == 1) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool is_simple_power(long x, long n) {\n  ",
    "suffix": "\n    return true;\n  }\n  while (x != 1) {\n    if (x % n != 0) {\n      return false;\n    }\n    x /= n;\n  }\n  return true;\n}"
  },
  {
    "name": "HumanEval_39_prime_fib",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nlong prime_fib(long n) {\n",
    "canonical_solution": "if (isPrime) primeFib.push_back(fib[i]);",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nlong prime_fib(long n) {\n  std::vector<long> fib = {0, 1};\n  std::vector<long> primeFib;\n\n  for (long i = 2; primeFib.size() < n; i++) {\n    fib.push_back(fib[i - 1] + fib[i - 2]);\n\n    if (fib[i] < 2) continue;\n\n    bool isPrime = true;\n    for (long j = 2; j * j <= fib[i]; j++) {\n      if (fib[i] % j == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n\n    ",
    "suffix": "\n  }\n\n  return primeFib[n - 1];\n}"
  },
  {
    "name": "HumanEval_145_order_by_points",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nstd::vector<long> order_by_points(std::vector<long> nums) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_0_has_close_elements",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_10_make_palindrome",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nstd::string make_palindrome(std::string string) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_11_string_xor",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\nstd::string string_xor(std::string a, std::string b) {\n",
    "canonical_solution": "for (int i = 0; i < a.size(); i++) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\nstd::string string_xor(std::string a, std::string b) {\n  std::string result = \"\";\n  ",
    "suffix": "\n    if (a[i] == b[i]) {\n      result += \"0\";\n    } else {\n      result += \"1\";\n    }\n  }\n  return result;\n}"
  },
  {
    "name": "HumanEval_139_special_factorial",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nlong special_factorial(long n) {\n",
    "canonical_solution": "for (long j = i; j > 0; j--) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nlong special_factorial(long n) {\n  long long result = 1;\n  for (long i = n; i > 0; i--) {\n    long long fact = 1;\n    ",
    "suffix": "\n      fact *= j;\n    }\n    result *= fact;\n  }\n  return result;\n}"
  },
  {
    "name": "HumanEval_122_add_elements",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nlong add_elements(std::vector<long> arr, long k) {\n",
    "canonical_solution": "for (int i = 0; i < k; i++) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  ",
    "suffix": "\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}"
  },
  {
    "name": "HumanEval_46_fib4",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nlong fib4(long n) {\n",
    "canonical_solution": "c = d;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nlong fib4(long n) {\n  if(n == 0 || n == 1 || n == 3) return 0;\n  if(n == 2) return 2;\n\n  long a = 0, b = 0, c = 2, d = 0, e;\n\n  for(long i = 4; i <= n; i++) {\n    e = a + b + c + d;\n    a = b;\n    b = c;\n    ",
    "suffix": "\n    d = e;\n  }\n\n  return d;\n}"
  },
  {
    "name": "HumanEval_104_unique_digits",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nstd::vector<long> unique_digits(std::vector<long> x) {\n",
    "canonical_solution": "hasEvenDigit = true;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (long num : x) {\n        bool hasEvenDigit = false;\n        long temp = num;\n        while (temp != 0) {\n            if ((temp % 10) % 2 == 0) {\n                ",
    "suffix": "\n                break;\n            }\n            temp /= 10;\n        }\n        if (!hasEvenDigit) {\n            result.push_back(num);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;\n}"
  },
  {
    "name": "HumanEval_117_select_words",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<std::string> select_words(std::string s, long n) {\n",
    "canonical_solution": "} else {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::istringstream iss(s);\n  std::string word;\n  while (iss >> word) {\n    long count = 0;\n    for (char c : word) {\n      c = tolower(c);\n      if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n        continue;\n      ",
    "suffix": "\n        count++;\n      }\n    }\n    if (count == n) {\n      result.push_back(word);\n    }\n  }\n  return result;\n}"
  },
  {
    "name": "HumanEval_72_will_it_fly",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool will_it_fly(std::vector<long> q, long w) {\n",
    "canonical_solution": "if (sum > w) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool will_it_fly(std::vector<long> q, long w) {\n  long sum = 0;\n  for (int i = 0; i < q.size(); i++) {\n    sum += q[i];\n  }\n  ",
    "suffix": "\n    return false;\n  }\n  \n  for (int i = 0; i < q.size() / 2; i++) {\n    if (q[i] != q[q.size() - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n}"
  },
  {
    "name": "HumanEval_55_fib",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nlong fib(long n) {\n",
    "canonical_solution": "return a;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nlong fib(long n) {\n  long a = 0, b = 1, c;\n  if (n == 0)\n    ",
    "suffix": "\n  for (long i = 2; i <= n; i++) {\n    c = a + b;\n    a = b;\n    b = c;\n  }\n  return b;\n}"
  },
  {
    "name": "HumanEval_153_Strongest_Extension",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n",
    "canonical_solution": "for (const auto& extension : extensions) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n  std::string strongest_extension = \"\";\n  int max_strength = INT_MIN;\n\n  ",
    "suffix": "\n    int cap = 0, sm = 0;\n    for (const auto& ch : extension) {\n      if (isupper(ch)) {\n        cap++;\n      } else if (islower(ch)) {\n        sm++;\n      }\n    }\n\n    int strength = cap - sm;\n    if (strength > max_strength) {\n      max_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n\n  return class_name + \".\" + strongest_extension;\n}"
  },
  {
    "name": "HumanEval_119_match_parens",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string match_parens(std::vector<std::string> lst) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_90_next_smallest",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nstd::optional<long> next_smallest(std::vector<long> lst) {\n",
    "canonical_solution": "if (lst[i] > lst[0]) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  \n  std::sort(lst.begin(), lst.end());\n  \n  for (int i = 1; i < lst.size(); i++) {\n    ",
    "suffix": "\n      return lst[i];\n    }\n  }\n  \n  return std::nullopt;\n}"
  },
  {
    "name": "HumanEval_92_any_int",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\nbool any_int(float x, float y, float z) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_2_truncate_number",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\nfloat truncate_number(float number) {\n",
    "canonical_solution": "int intPart = (int)number;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\nfloat truncate_number(float number) {\n  ",
    "suffix": "\n  float decimalPart = number - intPart;\n  return decimalPart;\n}"
  },
  {
    "name": "HumanEval_42_incr_list",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::vector<long> incr_list(std::vector<long> l) {\n",
    "canonical_solution": "for (int i = 0; i < l.size(); i++) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::vector<long> incr_list(std::vector<long> l) {\n  ",
    "suffix": "\n    l[i] += 1;\n  }\n  return l;\n}"
  },
  {
    "name": "HumanEval_150_x_or_y",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nlong x_or_y(long n, long x, long y) {\n",
    "canonical_solution": "break;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nlong x_or_y(long n, long x, long y) {\n  bool isPrime = true;\n\n  if (n <= 1) {\n    isPrime = false;\n  } else {\n    for (int i = 2; i <= sqrt(n); i++) {\n      if (n % i == 0) {\n        isPrime = false;\n        ",
    "suffix": "\n      }\n    }\n  }\n\n  if (isPrime) {\n    return x;\n  } else {\n    return y;\n  }\n}"
  },
  {
    "name": "HumanEval_49_modp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nlong modp(long n, long p) {\n",
    "canonical_solution": "n /= 2;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nlong modp(long n, long p) {\n  long result = 1;\n  long square = 2;\n  while (n > 0) {\n    if (n % 2 == 1) {\n      result = (result * square) % p;\n    }\n    square = (square * square) % p;\n    ",
    "suffix": "\n  }\n  return result;\n}"
  },
  {
    "name": "HumanEval_155_even_odd_count",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\nstd::tuple<long, long> even_odd_count(long num) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_80_is_happy",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool is_happy(std::string s) {\n",
    "canonical_solution": "return false;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool is_happy(std::string s) {\n  if (s.length() < 3)\n    ",
    "suffix": "\n  for (int i = 0; i < s.length() - 2; i++) {\n    if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2])\n      return false;\n  }\n  return true;\n}"
  },
  {
    "name": "HumanEval_59_largest_prime_factor",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nlong largest_prime_factor(long n) {\n",
    "canonical_solution": "while (n % i == 0) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nlong largest_prime_factor(long n) {\n    long maxPrime = -1;\n\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n >>= 1;\n    }\n\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        ",
    "suffix": "\n            maxPrime = i;\n            n = n / i;\n        }\n    }\n\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}"
  },
  {
    "name": "HumanEval_66_digitSum",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlong digitSum(std::string s) {\n",
    "canonical_solution": "if (isupper(c)) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    ",
    "suffix": "\n      sum += c;\n    }\n  }\n  return sum;\n}"
  },
  {
    "name": "HumanEval_21_rescale_to_unit",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n",
    "canonical_solution": "float max_num = *std::max_element(numbers.begin(), numbers.end());",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  float min_num = *std::min_element(numbers.begin(), numbers.end());\n  ",
    "suffix": "\n\n  for (int i = 0; i < numbers.size(); i++) {\n    numbers[i] = (numbers[i] - min_num) / (max_num - min_num);\n  }\n\n  return numbers;\n}"
  },
  {
    "name": "HumanEval_121_solution",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nlong solution(std::vector<long> lst) {\n",
    "canonical_solution": "if (lst[i] % 2 != 0) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i += 2) {\n    ",
    "suffix": "\n      sum += lst[i];\n    }\n  }\n  return sum;\n}"
  },
  {
    "name": "HumanEval_68_pluck",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> pluck(std::vector<long> arr) {\n",
    "canonical_solution": "if (arr[i] % 2 == 0 && arr[i] < smallest) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> pluck(std::vector<long> arr) {\n  std::vector<long> result;\n  long smallest = LONG_MAX;\n  int index = -1;\n  for (int i = 0; i < arr.size(); i++) {\n    ",
    "suffix": "\n      smallest = arr[i];\n      index = i;\n    }\n  }\n  if (index != -1) {\n    result.push_back(smallest);\n    result.push_back(index);\n  }\n  return result;\n}"
  },
  {
    "name": "HumanEval_147_get_max_triples",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nlong get_max_triples(long n) {\n",
    "canonical_solution": "std::vector<long> a(n);",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nlong get_max_triples(long n) {\n  ",
    "suffix": "\n  for (long i = 0; i < n; i++) {\n    a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n  }\n  \n  long count = 0;\n  for (long i = 0; i < n; i++) {\n    for (long j = i + 1; j < n; j++) {\n      for (long k = j + 1; k < n; k++) {\n        if ((a[i] + a[j] + a[k]) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n  \n  return count;\n}"
  },
  {
    "name": "HumanEval_110_exchange",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n",
    "canonical_solution": "if (lst1[i] % 2 != 0) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  for (int i = 0; i < lst1.size(); i++) {\n    ",
    "suffix": "\n      bool found = false;\n      for (int j = 0; j < lst2.size(); j++) {\n        if (lst2[j] % 2 == 0) {\n          std::swap(lst1[i], lst2[j]);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        return \"NO\";\n      }\n    }\n  }\n  return \"YES\";\n}"
  },
  {
    "name": "HumanEval_47_median",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nfloat median(std::vector<long> l) {\n",
    "canonical_solution": "sort(l.begin(), l.end());",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nfloat median(std::vector<long> l) {\n  ",
    "suffix": "\n  int n = l.size();\n  if (n % 2 != 0) {\n    return (float)l[n / 2];\n  } else {\n    return (float)(l[(n - 1) / 2] + l[n / 2]) / 2.0;\n  }\n}"
  },
  {
    "name": "HumanEval_82_prime_length",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nbool prime_length(std::string string) {\n",
    "canonical_solution": "if (length % 2 == 0) return false;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nbool prime_length(std::string string) {\n  int length = string.length();\n  if (length <= 1) return false;\n  if (length == 2) return true;\n  ",
    "suffix": "\n  for (int i = 3; i * i <= length; i += 2) {\n    if (length % i == 0) return false;\n  }\n  return true;\n}"
  },
  {
    "name": "HumanEval_73_smallest_change",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nlong smallest_change(std::vector<long> arr) {\n",
    "canonical_solution": "changes++;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nlong smallest_change(std::vector<long> arr) {\n  long changes = 0;\n  int i = 0, j = arr.size() - 1;\n  while (i < j) {\n    if (arr[i] != arr[j]) {\n      ",
    "suffix": "\n    }\n    i++;\n    j--;\n  }\n  return changes;\n}"
  },
  {
    "name": "HumanEval_133_sum_squares",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlong sum_squares(std::vector<float> lst) {\n",
    "canonical_solution": "int ceil_val = std::ceil(lst[i]);",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    ",
    "suffix": "\n    sum += ceil_val * ceil_val;\n  }\n  return sum;\n}"
  },
  {
    "name": "HumanEval_141_file_name_check",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string file_name_check(std::string file_name) {\n",
    "canonical_solution": "std::string extension = file_name.substr(dotPos + 1);",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string file_name_check(std::string file_name) {\n  int digitCount = 0;\n  for (char c : file_name) {\n    if (isdigit(c)) digitCount++;\n  }\n  if (digitCount > 3) return \"No\";\n\n  size_t dotPos = file_name.find('.');\n  if (dotPos == std::string::npos || dotPos == 0 || !isalpha(file_name[0])) return \"No\";\n\n  ",
    "suffix": "\n  if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") return \"No\";\n\n  return \"Yes\";\n}"
  },
  {
    "name": "HumanEval_40_triples_sum_to_zero",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool triples_sum_to_zero(std::vector<long> l) {\n",
    "canonical_solution": "sort(l.begin(), l.end());",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool triples_sum_to_zero(std::vector<long> l) {\n  int n = l.size();\n  ",
    "suffix": "\n\n  for (int i = 0; i < n - 2; i++) {\n    int left = i + 1;\n    int right = n - 1;\n\n    while (left < right) {\n      long sum = l[i] + l[left] + l[right];\n\n      if (sum == 0) {\n        return true;\n      } else if (sum < 0) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n  return false;\n}"
  },
  {
    "name": "HumanEval_127_intersection",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n",
    "canonical_solution": "if (length % i == 0) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get<0>(interval1);\n  long end1 = std::get<1>(interval1);\n  long start2 = std::get<0>(interval2);\n  long end2 = std::get<1>(interval2);\n\n  long intersectionStart = std::max(start1, start2);\n  long intersectionEnd = std::min(end1, end2);\n\n  if (intersectionStart > intersectionEnd) {\n    return \"NO\";\n  }\n\n  long length = intersectionEnd - intersectionStart;\n\n  if (length < 2) {\n    return \"NO\";\n  }\n\n  for (long i = 2; i * i <= length; ++i) {\n    ",
    "suffix": "\n      return \"NO\";\n    }\n  }\n\n  return \"YES\";\n}"
  },
  {
    "name": "HumanEval_1_separate_paren_groups",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n",
    "canonical_solution": "group.clear();",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n  std::vector<std::string> groups;\n  std::string group;\n  int openCount = 0;\n\n  for (char c : paren_string) {\n    if (c == ' ') continue;\n    if (c == '(') {\n      openCount++;\n    } else if (c == ')') {\n      openCount--;\n    }\n    group += c;\n\n    if (openCount == 0) {\n      groups.push_back(group);\n      ",
    "suffix": "\n    }\n  }\n  return groups;\n}"
  },
  {
    "name": "HumanEval_152_compare",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n",
    "canonical_solution": "result.push_back(abs(game[i] - guess[i]));",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n  std::vector<long> result;\n  for (int i = 0; i < game.size(); i++) {\n    ",
    "suffix": "\n  }\n  return result;\n}"
  },
  {
    "name": "HumanEval_83_starts_one_ends",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\nlong starts_one_ends(long n) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_134_check_if_last_char_is_a_letter",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool check_if_last_char_is_a_letter(std::string txt) {\n",
    "canonical_solution": "if (lastChar == ' ') {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty()) {\n    return false;\n  }\n\n  char lastChar = txt[txt.length() - 1];\n\n  ",
    "suffix": "\n    return false;\n  }\n\n  if (isalpha(lastChar)) {\n    if (txt.length() == 1 || txt[txt.length() - 2] == ' ') {\n      return true;\n    }\n  }\n\n  return false;\n}"
  },
  {
    "name": "HumanEval_124_valid_date",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool valid_date(std::string date) {\n",
    "canonical_solution": "return false;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool valid_date(std::string date) {\n  if (date.size() != 10 || date[2] != '-' || date[5] != '-')\n    return false;\n\n  int month = stoi(date.substr(0, 2));\n  int day = stoi(date.substr(3, 2));\n  int year = stoi(date.substr(6, 4));\n\n  if (month < 1 || month > 12 || day < 1 || day > 31)\n    return false;\n\n  if (month == 2) {\n    if (day > 29)\n      ",
    "suffix": "\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day > 30)\n      return false;\n  }\n\n  return true;\n}"
  },
  {
    "name": "HumanEval_108_count_nums",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nlong count_nums(std::vector<long> arr) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_86_anti_shuffle",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string anti_shuffle(std::string s) {\n",
    "canonical_solution": "if (!result.empty()) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string anti_shuffle(std::string s) {\n  std::stringstream ss(s);\n  std::string word, result = \"\";\n\n  while (ss >> word) {\n    std::sort(word.begin(), word.end());\n    result += word + \" \";\n  }\n\n  \n  ",
    "suffix": "\n    result.pop_back();\n  }\n\n  return result;\n}"
  },
  {
    "name": "HumanEval_48_is_palindrome",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nbool is_palindrome(std::string text) {\n",
    "canonical_solution": "return false;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nbool is_palindrome(std::string text) {\n  int start = 0;\n  int end = text.length() - 1;\n  while (start < end) {\n    if (text[start] != text[end]) {\n      ",
    "suffix": "\n    }\n    start++;\n    end--;\n  }\n  return true;\n}"
  },
  {
    "name": "HumanEval_118_get_closest_vowel",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string get_closest_vowel(std::string word) {\n",
    "canonical_solution": "std::string vowels = \"aeiouAEIOU\";",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string get_closest_vowel(std::string word) {\n    ",
    "suffix": "\n    for (int i = word.length() - 2; i > 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos && \n            vowels.find(word[i-1]) == std::string::npos && \n            vowels.find(word[i+1]) == std::string::npos) {\n            return std::string(1, word[i]);\n        }\n    }\n    return \"\";\n}"
  },
  {
    "name": "HumanEval_31_is_prime",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool is_prime(long n) {\n",
    "canonical_solution": "for(long i = 5; i * i <= n; i += 6) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool is_prime(long n) {\n  if(n <= 1) return false;\n  if(n <= 3) return true;\n\n  if(n % 2 == 0 || n % 3 == 0) return false;\n\n  ",
    "suffix": "\n    if(n % i == 0 || n % (i + 2) == 0) return false;\n  }\n\n  return true;\n}"
  },
  {
    "name": "HumanEval_144_simplify",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nbool simplify(std::string x, std::string n) {\n",
    "canonical_solution": "int den = den1 * den2;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nbool simplify(std::string x, std::string n) {\n  int num1, den1, num2, den2;\n  sscanf(x.c_str(), \"%d/%d\", &num1, &den1);\n  sscanf(n.c_str(), \"%d/%d\", &num2, &den2);\n\n  int num = num1 * num2;\n  ",
    "suffix": "\n\n  return num % den == 0;\n}"
  },
  {
    "name": "HumanEval_78_hex_key",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlong hex_key(std::string num) {\n",
    "canonical_solution": "for (char c : num) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlong hex_key(std::string num) {\n  long count = 0;\n  ",
    "suffix": "\n    if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n      count++;\n    }\n  }\n  return count;\n}"
  },
  {
    "name": "HumanEval_143_words_in_sentence",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string words_in_sentence(std::string sentence) {\n",
    "canonical_solution": "return true;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n    std::stringstream ss(sentence);\n    std::string word;\n\n    auto is_prime = [](int n) {\n        if (n <= 1) return false;\n        if (n == 2) return true;\n        if (n % 2 == 0) return false;\n        for (int i = 3; i * i <= n; i += 2)\n            if (n % i == 0) return false;\n        ",
    "suffix": "\n    };\n\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) result += \" \";\n            result += word;\n        }\n    }\n\n    return result;\n}"
  },
  {
    "name": "HumanEval_111_histogram",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::map<std::string,long> histogram(std::string test) {\n",
    "canonical_solution": "return result;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string,long> freq;\n  std::istringstream iss(test);\n  std::string word;\n  long maxCount = 0;\n\n  while (iss >> word) {\n    freq[word]++;\n    if (freq[word] > maxCount) {\n      maxCount = freq[word];\n    }\n  }\n\n  std::map<std::string,long> result;\n  for (auto &pair : freq) {\n    if (pair.second == maxCount) {\n      result.insert(pair);\n    }\n  }\n\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_87_get_row",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n",
    "canonical_solution": "for (long i = 0; i < lst.size(); i++) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> result;\n  ",
    "suffix": "\n    std::vector<long> row = lst[i];\n    for (long j = 0; j < row.size(); j++) {\n      if (row[j] == x) {\n        result.push_back(std::make_tuple(i, j));\n      }\n    }\n  }\n  \n  \n  std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n    if (std::get<0>(a) != std::get<0>(b)) {\n      return std::get<0>(a) < std::get<0>(b);\n    } else {\n      return std::get<1>(a) > std::get<1>(b);\n    }\n  });\n  \n  return result;\n}"
  },
  {
    "name": "HumanEval_123_get_odd_collatz",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> get_odd_collatz(long n) {\n",
    "canonical_solution": "std::vector<long> result;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> get_odd_collatz(long n) {\n  ",
    "suffix": "\n  while(n != 1){\n    if(n % 2 != 0){\n      result.push_back(n);\n    }\n    n = n % 2 == 0 ? n/2 : 3*n + 1;\n  }\n  result.push_back(1);\n  std::sort(result.begin(), result.end());\n  return result;\n}"
  },
  {
    "name": "HumanEval_135_can_arrange",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nlong can_arrange(std::vector<long> arr) {\n",
    "canonical_solution": "return i;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nlong can_arrange(std::vector<long> arr) {\n  for (int i = arr.size() - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) {\n      ",
    "suffix": "\n    }\n  }\n  return -1;\n}"
  },
  {
    "name": "HumanEval_19_sort_numbers",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::string sort_numbers(std::string numbers) {\n",
    "canonical_solution": "std::stringstream ss(numbers);",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::string sort_numbers(std::string numbers) {\n  std::map<std::string, int> num_map = {{\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4}, \n                                        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}};\n  std::vector<std::pair<int, std::string>> num_vec;\n  std::string word;\n  ",
    "suffix": "\n\n  while (ss >> word) {\n    num_vec.push_back({num_map[word], word});\n  }\n\n  std::sort(num_vec.begin(), num_vec.end());\n\n  std::string result = \"\";\n  for (auto pair : num_vec) {\n    if (result != \"\") {\n      result += \" \";\n    }\n    result += pair.second;\n  }\n\n  return result;\n}"
  },
  {
    "name": "HumanEval_65_circular_shift",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nstd::string circular_shift(long x, long shift) {\n",
    "canonical_solution": "return str;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nstd::string circular_shift(long x, long shift) {\n  std::string str = std::to_string(x);\n  int len = str.length();\n\n  if (shift > len) {\n    std::reverse(str.begin(), str.end());\n  } else {\n    std::rotate(str.rbegin(), str.rbegin() + shift, str.rend());\n  }\n\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_142_sum_squares",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nlong sum_squares(std::vector<long> lst) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_94_skjkasdkd",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlong skjkasdkd(std::vector<long> lst) {\n",
    "canonical_solution": "return false;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlong skjkasdkd(std::vector<long> lst) {\n  auto is_prime = [](long n) {\n    if (n <= 1)\n      return false;\n    if (n == 2)\n      return true;\n    if (n % 2 == 0)\n      return false;\n    for (long i = 3; i * i <= n; i += 2)\n      if (n % i == 0)\n        ",
    "suffix": "\n    return true;\n  };\n\n  long max_prime = 0;\n  for (long num : lst) {\n    if (is_prime(num) && num > max_prime) {\n      max_prime = num;\n    }\n  }\n\n  long sum = 0;\n  while (max_prime != 0) {\n    sum += max_prime % 10;\n    max_prime /= 10;\n  }\n\n  return sum;\n}"
  },
  {
    "name": "HumanEval_8_sum_product",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n",
    "canonical_solution": "product *= num;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n  long sum = 0;\n  long product = 1;\n  \n  for(auto num : numbers) {\n    sum += num;\n    ",
    "suffix": "\n  }\n  \n  return std::make_tuple(sum, product);\n}"
  },
  {
    "name": "HumanEval_102_choose_num",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nlong choose_num(long x, long y) {\n",
    "canonical_solution": "return -1;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nlong choose_num(long x, long y) {\n  if (x > y) return -1;\n  if (y % 2 == 0) return y;\n  else if (y - 1 >= x) return y - 1;\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_136_largest_smallest_integers",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n",
    "canonical_solution": "min_positive = num;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n  std::optional<long> max_negative = std::nullopt;\n  std::optional<long> min_positive = std::nullopt;\n\n  for (long num : lst) {\n    if (num < 0 && (!max_negative.has_value() || num > max_negative.value())) {\n      max_negative = num;\n    }\n    if (num > 0 && (!min_positive.has_value() || num < min_positive.value())) {\n      ",
    "suffix": "\n    }\n  }\n\n  return std::make_tuple(max_negative, min_positive);\n}"
  },
  {
    "name": "HumanEval_16_count_distinct_characters",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nlong count_distinct_characters(std::string string) {\n",
    "canonical_solution": "std::set<char> distinct_characters(string.begin(), string.end());",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nlong count_distinct_characters(std::string string) {\n  std::transform(string.begin(), string.end(), string.begin(), ::tolower);\n  ",
    "suffix": "\n  return distinct_characters.size();\n}"
  },
  {
    "name": "HumanEval_100_make_a_pile",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> make_a_pile(long n) {\n",
    "canonical_solution": "if (stones % 2 == 0) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  long stones = n;\n  for (long i = 0; i < n; i++) {\n    pile.push_back(stones);\n    ",
    "suffix": "\n      stones += 2;\n    } else {\n      stones += 2;\n    }\n  }\n  return pile;\n}"
  },
  {
    "name": "HumanEval_128_prod_signs",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nstd::optional<long> prod_signs(std::vector<long> arr) {\n",
    "canonical_solution": "break;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n  \n  long sum = 0;\n  int sign_product = 1;\n  \n  for (auto num : arr) {\n    sum += abs(num);\n    if (num < 0) {\n      sign_product *= -1;\n    } else if (num > 0) {\n      sign_product *= 1;\n    } else {\n      sign_product = 0;\n      ",
    "suffix": "\n    }\n  }\n  \n  return sum * sign_product;\n}"
  },
  {
    "name": "HumanEval_114_minSubArraySum",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nlong minSubArraySum(std::vector<long> nums) {\n",
    "canonical_solution": "for (int i = 1; i < nums.size(); i++) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nlong minSubArraySum(std::vector<long> nums) {\n  long minSum = nums[0];\n  long currentSum = nums[0];\n\n  ",
    "suffix": "\n    currentSum = std::min(nums[i], currentSum + nums[i]);\n    minSum = std::min(minSum, currentSum);\n  }\n\n  return minSum;\n}"
  },
  {
    "name": "HumanEval_15_string_sequence",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::string string_sequence(long n) {\n",
    "canonical_solution": "std::string result = \"\";",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::string string_sequence(long n) {\n  ",
    "suffix": "\n  for (long i = 0; i <= n; i++) {\n    result += std::to_string(i);\n    if (i != n) {\n      result += \" \";\n    }\n  }\n  return result;\n}"
  },
  {
    "name": "HumanEval_154_cycpattern_check",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool cycpattern_check(std::string a, std::string b) {\n",
    "canonical_solution": "if (a.find(b) != std::string::npos) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool cycpattern_check(std::string a, std::string b) {\n  for (int i = 0; i < b.size(); i++) {\n    std::rotate(b.begin(), b.begin() + 1, b.end());\n    ",
    "suffix": "\n      return true;\n    }\n  }\n  return false;\n}"
  },
  {
    "name": "HumanEval_57_monotonic",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nbool monotonic(std::vector<long> l) {\n",
    "canonical_solution": "decreasing = false;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nbool monotonic(std::vector<long> l) {\n  bool increasing = true;\n  bool decreasing = true;\n\n  for(int i = 0; i < l.size() - 1; ++i) {\n    if(l[i] > l[i+1]) {\n      increasing = false;\n    }\n    if(l[i] < l[i+1]) {\n      ",
    "suffix": "\n    }\n  }\n\n  return increasing || decreasing;\n}"
  },
  {
    "name": "HumanEval_12_longest",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n",
    "canonical_solution": "return std::nullopt;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    ",
    "suffix": "\n  }\n\n  std::string longest_string = strings[0];\n\n  for (const auto& str : strings) {\n    if (str.length() > longest_string.length()) {\n      longest_string = str;\n    }\n  }\n\n  return longest_string;\n}"
  },
  {
    "name": "HumanEval_52_below_threshold",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nbool below_threshold(std::vector<long> l, long t) {\n",
    "canonical_solution": "return false;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nbool below_threshold(std::vector<long> l, long t) {\n  for (long num : l) {\n    if (num >= t) {\n      ",
    "suffix": "\n    }\n  }\n  return true;\n}"
  },
  {
    "name": "HumanEval_75_is_multiply_prime",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nbool is_multiply_prime(long a) {\n",
    "canonical_solution": "count++;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nbool is_multiply_prime(long a) {\n    std::vector<int> prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int count = 0;\n    for (int i = 0; i < prime.size(); i++) {\n        while (a % prime[i] == 0) {\n            a /= prime[i];\n            ",
    "suffix": "\n        }\n    }\n    if (count == 3 && a == 1) {\n        return true;\n    }\n    return false;\n}"
  },
  {
    "name": "HumanEval_30_get_positive",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::vector<long> get_positive(std::vector<long> l) {\n",
    "canonical_solution": "return positive_numbers;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::vector<long> get_positive(std::vector<long> l) {\n  std::vector<long> positive_numbers;\n  for (int i = 0; i < l.size(); i++) {\n    if (l[i] > 0) {\n      positive_numbers.push_back(l[i]);\n    }\n  }\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_33_sort_third",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nstd::vector<long> sort_third(std::vector<long> l) {\n",
    "canonical_solution": "divisible.push_back(l[i]);",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nstd::vector<long> sort_third(std::vector<long> l) {\n  std::vector<long> divisible;\n  for (int i = 0; i < l.size(); i++) {\n    if (i % 3 == 0) {\n      ",
    "suffix": "\n    }\n  }\n  \n  std::sort(divisible.begin(), divisible.end());\n  \n  int j = 0;\n  for (int i = 0; i < l.size(); i++) {\n    if (i % 3 == 0) {\n      l[i] = divisible[j++];\n    }\n  }\n  \n  return l;\n}"
  },
  {
    "name": "HumanEval_6_parse_nested_parens",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n",
    "canonical_solution": "current_depth--;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n  std::stringstream ss(paren_string);\n  std::string group;\n\n  while(std::getline(ss, group, ' ')) {\n    long max_depth = 0;\n    long current_depth = 0;\n    for(char ch : group) {\n      if(ch == '(') {\n        current_depth++;\n        if(current_depth > max_depth) {\n          max_depth = current_depth;\n        }\n      } else if(ch == ')') {\n        if(current_depth > 0) {\n          ",
    "suffix": "\n        }\n      }\n    }\n    result.push_back(max_depth);\n  }\n  return result;\n}"
  },
  {
    "name": "HumanEval_45_triangle_area",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\nfloat triangle_area(long a, long h) {\n",
    "canonical_solution": "return 0.5f * a * h;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\nfloat triangle_area(long a, long h) {\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_97_multiply",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\nlong multiply(long a, long b) {\n",
    "canonical_solution": "long unitA = abs(a) % 10;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\nlong multiply(long a, long b) {\n  ",
    "suffix": "\n  long unitB = abs(b) % 10;\n  return unitA * unitB;\n}"
  },
  {
    "name": "HumanEval_4_mean_absolute_deviation",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n",
    "canonical_solution": "for (auto& num : numbers) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0.0f;\n  for (auto& num : numbers) {\n    sum += num;\n  }\n  float mean = sum / numbers.size();\n\n  float mad = 0.0f;\n  ",
    "suffix": "\n    mad += std::abs(num - mean);\n  }\n  return mad / numbers.size();\n}"
  },
  {
    "name": "HumanEval_58_common",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n",
    "canonical_solution": "common_elements.erase(std::unique(common_elements.begin(), common_elements.end()), common_elements.end());",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n  std::vector<long> common_elements;\n  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n\n  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(common_elements));\n\n  ",
    "suffix": "\n\n  return common_elements;\n}"
  },
  {
    "name": "HumanEval_156_int_to_mini_roman",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nstd::string int_to_mini_roman(long number) {\n",
    "canonical_solution": "std::string roman_numerals[13] = {\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nstd::string int_to_mini_roman(long number) {\n  ",
    "suffix": "\n  int integer_values[13] = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\n\n  std::string result = \"\";\n  for (int i = 0; i < 13; i++) {\n    while (number >= integer_values[i]) {\n      number -= integer_values[i];\n      result += roman_numerals[i];\n    }\n  }\n  return result;\n}"
  },
  {
    "name": "HumanEval_67_fruit_distribution",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlong fruit_distribution(std::string s, long n) {\n",
    "canonical_solution": "ss >> apples >> temp >> temp >> oranges;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlong fruit_distribution(std::string s, long n) {\n  std::stringstream ss(s);\n  long apples, oranges;\n  std::string temp;\n  \n  ",
    "suffix": "\n  \n  return n - (apples + oranges);\n}"
  },
  {
    "name": "HumanEval_112_reverse_delete",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n",
    "canonical_solution": "return std::make_tuple(result, result == reversed);",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result = \"\";\n  for (char ch : s) {\n    if (c.find(ch) == std::string::npos) {\n      result += ch;\n    }\n  }\n  \n  std::string reversed = result;\n  std::reverse(reversed.begin(), reversed.end());\n  \n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_13_greatest_common_divisor",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nlong greatest_common_divisor(long a, long b) {\n",
    "canonical_solution": "long temp = b;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nlong greatest_common_divisor(long a, long b) {\n  while (b != 0) {\n    ",
    "suffix": "\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}"
  },
  {
    "name": "HumanEval_125_split_words",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n\n\n\n\n\n\n\n\n\n\nUnion_std_vector_std_string__long split_words(std::string txt) {\n",
    "canonical_solution": "while(std::getline(iss, token, ' ')) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n\n\n\n\n\n\n\n\n\n\nUnion_std_vector_std_string__long split_words(std::string txt) {\n  std::vector<std::string> words;\n  std::istringstream iss(txt);\n  std::string token;\n\n  if(txt.find(' ') != std::string::npos) {\n    ",
    "suffix": "\n      words.push_back(token);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else if(txt.find(',') != std::string::npos) {\n    while(std::getline(iss, token, ',')) {\n      words.push_back(token);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else {\n    long oddCount = 0;\n    for(char c : txt) {\n      if(islower(c) && (c - 'a') % 2 != 0) {\n        oddCount++;\n      }\n    }\n    return Union_std_vector_std_string__long(oddCount);\n  }\n}"
  },
  {
    "name": "HumanEval_116_sort_array",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nstd::vector<long> sort_array(std::vector<long> arr) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_28_concatenate",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::string concatenate(std::vector<std::string> strings) {\n",
    "canonical_solution": "return result;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result = \"\";\n  for (const auto& str : strings) {\n    result += str;\n  }\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_149_sorted_list_sum",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n",
    "canonical_solution": "if (a.length() == b.length()) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  std::vector<std::string> evenLengthStrings;\n\n  \n  for (const auto& str : lst) {\n    if (str.length() % 2 == 0) {\n      evenLengthStrings.push_back(str);\n    }\n  }\n\n  \n  std::sort(evenLengthStrings.begin(), evenLengthStrings.end(), \n            [](const std::string& a, const std::string& b) {\n              ",
    "suffix": "\n                return a < b;\n              }\n              return a.length() < b.length();\n            });\n\n  return evenLengthStrings;\n}"
  },
  {
    "name": "HumanEval_7_filter_by_substring",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n",
    "canonical_solution": "for(const auto& str : strings) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n  std::vector<std::string> result;\n  ",
    "suffix": "\n    if(str.find(substring) != std::string::npos) {\n      result.push_back(str);\n    }\n  }\n  return result;\n}"
  },
  {
    "name": "HumanEval_99_closest_integer",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nlong closest_integer(std::string value) {\n",
    "canonical_solution": "double number = std::stod(value);",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nlong closest_integer(std::string value) {\n  ",
    "suffix": "\n  long result = (number > 0.0) ? (long)(number + 0.5) : (long)(number - 0.5);\n  return result;\n}"
  },
  {
    "name": "HumanEval_64_vowels_count",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nlong vowels_count(std::string s) {\n",
    "canonical_solution": "for (int i = 0; i < s.length(); i++) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nlong vowels_count(std::string s) {\n  long count = 0;\n  ",
    "suffix": "\n    char c = tolower(s[i]);\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || (c == 'y' && i == s.length() - 1)) {\n      count++;\n    }\n  }\n  return count;\n}"
  },
  {
    "name": "HumanEval_158_find_max",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nstd::string find_max(std::vector<std::string> words) {\n",
    "canonical_solution": "for (auto word : words) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n  int max_unique_chars = 0;\n\n  ",
    "suffix": "\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_word = word;\n      max_unique_chars = unique_chars.size();\n    } else if (unique_chars.size() == max_unique_chars && word < max_word) {\n      max_word = word;\n    }\n  }\n\n  return max_word;\n}"
  },
  {
    "name": "HumanEval_162_string_to_md5",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\nstd::optional<std::string> string_to_md5(std::string text) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_44_change_base",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nstd::string change_base(long x, long base) {\n",
    "canonical_solution": "return result;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nstd::string change_base(long x, long base) {\n  std::string result = \"\";\n  while(x > 0) {\n    result = std::to_string(x % base) + result;\n    x /= base;\n  }\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_157_right_angle_triangle",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nbool right_angle_triangle(long a, long b, long c) {\n",
    "canonical_solution": "return (b*b + c*c == a*a);",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nbool right_angle_triangle(long a, long b, long c) {\n  long max_val = std::max({a, b, c});\n  \n  if(max_val == a) {\n    ",
    "suffix": "\n  } else if(max_val == b) {\n    return (a*a + c*c == b*b);\n  } else {\n    return (a*a + b*b == c*c);\n  }\n}"
  },
  {
    "name": "HumanEval_81_numerical_letter_grade",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n",
    "canonical_solution": "letter_grades.push_back(\"A+\");",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float grade : grades) {\n    if (grade == 4.0f) {\n      ",
    "suffix": "\n    } else if (grade > 3.7f) {\n      letter_grades.push_back(\"A\");\n    } else if (grade > 3.3f) {\n      letter_grades.push_back(\"A-\");\n    } else if (grade > 3.0f) {\n      letter_grades.push_back(\"B+\");\n    } else if (grade > 2.7f) {\n      letter_grades.push_back(\"B\");\n    } else if (grade > 2.3f) {\n      letter_grades.push_back(\"B-\");\n    } else if (grade > 2.0f) {\n      letter_grades.push_back(\"C+\");\n    } else if (grade > 1.7f) {\n      letter_grades.push_back(\"C\");\n    } else if (grade > 1.3f) {\n      letter_grades.push_back(\"C-\");\n    } else if (grade > 1.0f) {\n      letter_grades.push_back(\"D+\");\n    } else if (grade > 0.7f) {\n      letter_grades.push_back(\"D\");\n    } else if (grade > 0.0f) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}"
  },
  {
    "name": "HumanEval_5_intersperse",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n",
    "canonical_solution": "std::vector<long> result;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n  ",
    "suffix": "\n  for (int i = 0; i < numbers.size(); i++) {\n    if (i != 0) {\n      result.push_back(delimeter);\n    }\n    result.push_back(numbers[i]);\n  }\n  return result;\n}"
  },
  {
    "name": "HumanEval_146_specialFilter",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nlong specialFilter(std::vector<long> nums) {\n",
    "canonical_solution": "for (long num : nums) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\nlong specialFilter(std::vector<long> nums) {\n  long count = 0;\n  ",
    "suffix": "\n    if (num > 10) {\n      long firstDigit = num;\n      while (firstDigit >= 10) {\n        firstDigit /= 10;\n      }\n      long lastDigit = num % 10;\n      if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n}"
  },
  {
    "name": "HumanEval_60_sum_to_n",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nlong sum_to_n(long n) {\n",
    "canonical_solution": "return n * (n + 1) / 2;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nlong sum_to_n(long n) {\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_26_remove_duplicates",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_163_generate_integers",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\nstd::vector<long> generate_integers(long a, long b) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_9_rolling_max",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_3_below_zero",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nbool below_zero(std::vector<long> operations) {\n",
    "canonical_solution": "for (long operation : operations) {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  ",
    "suffix": "\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}"
  },
  {
    "name": "HumanEval_69_search",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nlong search(std::vector<long> lst) {\n",
    "canonical_solution": "long max_val = -1;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\nlong search(std::vector<long> lst) {\n  std::map<long, long> freq;\n  for (auto &i : lst) {\n    freq[i]++;\n  }\n  \n  ",
    "suffix": "\n  for (auto &i : freq) {\n    if (i.first <= i.second) {\n      max_val = std::max(max_val, i.first);\n    }\n  }\n  \n  return max_val;\n}"
  },
  {
    "name": "HumanEval_61_correct_bracketing",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nbool correct_bracketing(std::string brackets) {\n",
    "canonical_solution": "balance++;",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            ",
    "suffix": "\n        } else if (c == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}"
  },
  {
    "name": "HumanEval_37_sort_even",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nstd::vector<long> sort_even(std::vector<long> l) {\n",
    "canonical_solution": "std::sort(even_elements.begin(), even_elements.end());",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\nstd::vector<long> sort_even(std::vector<long> l) {\n  std::vector<long> even_elements;\n  for(int i = 0; i < l.size(); i += 2) {\n    even_elements.push_back(l[i]);\n  }\n  ",
    "suffix": "\n\n  for(int i = 0, j = 0; i < l.size(); i += 2, j++) {\n    l[i] = even_elements[j];\n  }\n  \n  return l;\n}"
  },
  {
    "name": "HumanEval_54_same_chars",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool same_chars(std::string s0, std::string s1) {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_56_correct_bracketing",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nbool correct_bracketing(std::string brackets) {\n",
    "canonical_solution": "if (c == '<') {",
    "prefix": "#include<assert.h>\n#include<bits/stdc++.h>\n\n\n\n\n\n\n\n\n\n\nbool correct_bracketing(std::string brackets) {\n  int balance = 0;\n  for (char c : brackets) {\n    ",
    "suffix": "\n      balance++;\n    } else if (c == '>') {\n      balance--;\n    }\n    if (balance < 0) {\n      return false;\n    }\n  }\n  return balance == 0;\n}"
  }
]