[
  {
    "name": "HumanEval_23_strlen",
    "prompt": "package strlen_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc strlen(myString string) int {\n",
    "canonical_solution": "return len(myString)",
    "prefix": "package strlen_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc strlen(myString string) int {\n    ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_89_encrypt",
    "prompt": "package encrypt_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc encrypt(s string) string {\n",
    "canonical_solution": "encrypted += string((char-'A'+4)%26 + 'A')",
    "prefix": "package encrypt_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc encrypt(s string) string {\n    encrypted := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            encrypted += string((char-'a'+4)%26 + 'a')\n        } else if char >= 'A' && char <= 'Z' {\n            ",
    "suffix": "\n        } else {\n            encrypted += string(char)\n        }\n    }\n    return encrypted\n}"
  },
  {
    "name": "HumanEval_95_check_dict_case",
    "prompt": "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc check_dict_case(dict map[string]string) bool {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_85_add",
    "prompt": "package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\nfunc add(lst []int) int {\n",
    "canonical_solution": "for i := 1; i < len(lst); i += 2 {",
    "prefix": "package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\nfunc add(lst []int) int {\n    sum := 0\n    ",
    "suffix": "\n        if lst[i] % 2 == 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}"
  },
  {
    "name": "HumanEval_140_fix_spaces",
    "prompt": "package fix_spaces_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc fix_spaces(text string) string {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_63_fibfib",
    "prompt": "package fibfib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc fibfib(n int) int {\n",
    "canonical_solution": "return 0",
    "prefix": "package fibfib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc fibfib(n int) int {\n    if n == 0 || n == 1 {\n        ",
    "suffix": "\n    }\n    if n == 2 {\n        return 1\n    }\n    a, b, c := 0, 0, 1\n    for i := 3; i <= n; i++ {\n        a, b, c = b, c, a+b+c\n    }\n    return c\n}"
  },
  {
    "name": "HumanEval_151_double_the_difference",
    "prompt": "package double_the_difference_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc double_the_difference(lst []float64) int {\n",
    "canonical_solution": "sum := 0",
    "prefix": "package double_the_difference_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc double_the_difference(lst []float64) int {\n    ",
    "suffix": "\n    for _, num := range lst {\n        if num < 0 || num != float64(int(num)) {\n            continue\n        }\n        if int(num)%2 != 0 {\n            sum += int(num) * int(num)\n        }\n    }\n    return sum\n}"
  },
  {
    "name": "HumanEval_22_filter_integers",
    "prompt": "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc filter_integers(values []interface{}) []int {\n",
    "canonical_solution": "ints = append(ints, v)",
    "prefix": "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc filter_integers(values []interface{}) []int {\n    var ints []int\n    for _, value := range values {\n        if v, ok := value.(int); ok {\n            ",
    "suffix": "\n        }\n    }\n    return ints\n}"
  },
  {
    "name": "HumanEval_41_car_race_collision",
    "prompt": "package car_race_collision_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc car_race_collision(n int) int {\n",
    "canonical_solution": "return n * n;",
    "prefix": "package car_race_collision_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc car_race_collision(n int) int {\n    ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_17_parse_music",
    "prompt": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc parse_music(music_string string) []int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_79_decimal_to_binary",
    "prompt": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc decimal_to_binary(decimal int) string {\n",
    "canonical_solution": "return \"db\" + binary + \"db\"",
    "prefix": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc decimal_to_binary(decimal int) string {\n    binary := fmt.Sprintf(\"%b\", decimal)\n    ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_14_all_prefixes",
    "prompt": "package all_prefixes_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\nfunc all_prefixes(myString string) []string {\n",
    "canonical_solution": "prefixes = append(prefixes, myString[:i])",
    "prefix": "package all_prefixes_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\nfunc all_prefixes(myString string) []string {\n    var prefixes []string\n    for i := 1; i <= len(myString); i++ {\n        ",
    "suffix": "\n    }\n    return prefixes\n}"
  },
  {
    "name": "HumanEval_53_add",
    "prompt": "package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc add(x int, y int) int {\n",
    "canonical_solution": "return x + y",
    "prefix": "package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc add(x int, y int) int {\n    ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_159_eat",
    "prompt": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc eat(number int, need int, remaining int) []int {\n",
    "canonical_solution": "if remaining >= need {",
    "prefix": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc eat(number int, need int, remaining int) []int {\n    ",
    "suffix": "\n        return []int{number + need, remaining - need}\n    } else {\n        return []int{number + remaining, 0}\n    }\n}"
  },
  {
    "name": "HumanEval_115_max_fill",
    "prompt": "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc max_fill(grid [][]int, capacity int) int {\n",
    "canonical_solution": "totalWater += cell",
    "prefix": "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc max_fill(grid [][]int, capacity int) int {\n    totalWater := 0\n    for _, row := range grid {\n        for _, cell := range row {\n            ",
    "suffix": "\n        }\n    }\n    if totalWater%capacity == 0 {\n        return totalWater / capacity\n    }\n    return totalWater/capacity + 1\n}"
  },
  {
    "name": "HumanEval_160_do_algebra",
    "prompt": "package do_algebra_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc do_algebra(operator []string, operand []int) int {\n",
    "canonical_solution": "result += operand[i+1]",
    "prefix": "package do_algebra_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc do_algebra(operator []string, operand []int) int {\n    result := operand[0]\n    for i, op := range operator {\n        switch op {\n        case \"+\":\n            ",
    "suffix": "\n        case \"-\":\n            result -= operand[i+1]\n        case \"*\":\n            result *= operand[i+1]\n        case \"/\":\n            result /= operand[i+1]\n        case \"**\":\n            temp := result\n            for j := 1; j < operand[i+1]; j++ {\n                result *= temp\n            }\n        }\n    }\n    return result\n}"
  },
  {
    "name": "HumanEval_27_flip_case",
    "prompt": "package flip_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\nfunc flip_case(myString string) string {\n",
    "canonical_solution": "for _, c := range myString {",
    "prefix": "package flip_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\nfunc flip_case(myString string) string {\n    flipped := \"\"\n    ",
    "suffix": "\n        if c >= 'a' && c <= 'z' {\n            flipped += string(c - 32)\n        } else if c >= 'A' && c <= 'Z' {\n            flipped += string(c + 32)\n        } else {\n            flipped += string(c)\n        }\n    }\n    return flipped\n}"
  },
  {
    "name": "HumanEval_105_by_length",
    "prompt": "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc by_length(arr []int) []string {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_25_factorize",
    "prompt": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc factorize(n int) []int {\n",
    "canonical_solution": "factors = append(factors, i)",
    "prefix": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc factorize(n int) []int {\n  factors := make([]int, 0)\n  for i := 2; i*i <= n; i++ {\n    for n%i == 0 {\n      ",
    "suffix": "\n      n /= i\n    }\n  }\n  if n > 1 {\n    factors = append(factors, n)\n  }\n  return factors\n}"
  },
  {
    "name": "HumanEval_96_count_up_to",
    "prompt": "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc count_up_to(n int) []int {\n",
    "canonical_solution": "break",
    "prefix": "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc count_up_to(n int) []int {\n  primes := []int{}\n  for i := 2; i < n; i++ {\n    isPrime := true\n    for j := 2; j*j <= i; j++ {\n      if i%j == 0 {\n        isPrime = false\n        ",
    "suffix": "\n      }\n    }\n    if isPrime {\n      primes = append(primes, i)\n    }\n  }\n  return primes\n}"
  },
  {
    "name": "HumanEval_34_unique",
    "prompt": "package unique_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\nfunc unique(l []int) []int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_74_total_match",
    "prompt": "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc total_match(lst1 []string, lst2 []string) []string {\n",
    "canonical_solution": "count2 += len(str)",
    "prefix": "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc total_match(lst1 []string, lst2 []string) []string {\n    var count1, count2 int\n    for _, str := range lst1 {\n        count1 += len(str)\n    }\n    for _, str := range lst2 {\n        ",
    "suffix": "\n    }\n    if count1 <= count2 {\n        return lst1\n    }\n    return lst2\n}"
  },
  {
    "name": "HumanEval_35_max_element",
    "prompt": "package max_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc max_element(l []int) int {\n",
    "canonical_solution": "if value > max {",
    "prefix": "package max_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc max_element(l []int) int {\n  max := l[0]\n  for _, value := range l {\n    ",
    "suffix": "\n      max = value\n    }\n  }\n  return max\n}"
  },
  {
    "name": "HumanEval_132_is_nested",
    "prompt": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc is_nested(myString string) bool {\n",
    "canonical_solution": "for _, char := range myString {",
    "prefix": "package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc is_nested(myString string) bool {\n    var stack []rune\n    ",
    "suffix": "\n        if char == '[' {\n            stack = append(stack, char)\n        } else if char == ']' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) != len(myString)/2\n}"
  },
  {
    "name": "HumanEval_113_odd_count",
    "prompt": "package odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc odd_count(lst []string) []string {\n",
    "canonical_solution": "count := 0",
    "prefix": "package odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc odd_count(lst []string) []string {\n    var res []string\n    for _, s := range lst {\n        ",
    "suffix": "\n        for _, c := range s {\n            if (c-'0')%2 != 0 {\n                count++\n            }\n        }\n        res = append(res, fmt.Sprintf(\"the number of odd elements %dn the str%dng %d of the %dnput.\", count, count, count, count))\n    }\n    return res\n}"
  },
  {
    "name": "HumanEval_109_move_one_ball",
    "prompt": "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc move_one_ball(arr []int) bool {\n",
    "canonical_solution": "for j := n-1; j > 0; j-- {",
    "prefix": "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc move_one_ball(arr []int) bool {\n    n := len(arr)\n    if n == 0 {\n        return true\n    }\n\n    for i := 0; i < n; i++ {\n        isSorted := true\n        for j := 1; j < n; j++ {\n            if arr[j] < arr[j-1] {\n                isSorted = false\n                break\n            }\n        }\n        if isSorted {\n            return true\n        }\n\n        lastElement := arr[n-1]\n        ",
    "suffix": "\n            arr[j] = arr[j-1]\n        }\n        arr[0] = lastElement\n    }\n\n    return false\n}"
  },
  {
    "name": "HumanEval_107_even_odd_palindrome",
    "prompt": "package even_odd_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc even_odd_palindrome(n int) []interface{} {\n",
    "canonical_solution": "for n != 0 {",
    "prefix": "package even_odd_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc even_odd_palindrome(n int) []interface{} {\n    evenCount := 0\n    oddCount := 0\n\n    for i := 1; i <= n; i++ {\n        if isPalindrome(i) {\n            if i%2 == 0 {\n                evenCount++\n            } else {\n                oddCount++\n            }\n        }\n    }\n\n    return []interface{}{evenCount, oddCount}\n}\n\nfunc isPalindrome(n int) bool {\n    original := n\n    reversed := 0\n\n    ",
    "suffix": "\n        remainder := n % 10\n        reversed = reversed*10 + remainder\n        n /= 10\n    }\n\n    return original == reversed\n}"
  },
  {
    "name": "HumanEval_138_is_equal_to_sum_even",
    "prompt": "package is_equal_to_sum_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc is_equal_to_sum_even(n int) bool {\n",
    "canonical_solution": "return n % 2 == 0",
    "prefix": "package is_equal_to_sum_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc is_equal_to_sum_even(n int) bool {\n    if n < 8 {\n        return false\n    }\n    ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_62_derivative",
    "prompt": "package derivative_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc derivative(xs []int) []int {\n",
    "canonical_solution": "return result",
    "prefix": "package derivative_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc derivative(xs []int) []int {\n    var result []int\n    for i := 1; i < len(xs); i++ {\n        result = append(result, xs[i]*i)\n    }\n    ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_126_is_sorted",
    "prompt": "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc is_sorted(lst []int) bool {\n",
    "canonical_solution": "return false",
    "prefix": "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc is_sorted(lst []int) bool {\n    counts := make(map[int]int)\n    for i := 0; i < len(lst); i++ {\n        counts[lst[i]]++\n        if counts[lst[i]] > 2 {\n            return false\n        }\n        if i > 0 && lst[i] < lst[i-1] {\n            ",
    "suffix": "\n        }\n    }\n    return true\n}"
  },
  {
    "name": "HumanEval_161_solve",
    "prompt": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc solve(s string) string {\n",
    "canonical_solution": "res += string(r + 32)",
    "prefix": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc solve(s string) string {\n    hasLetter := false\n    for _, r := range s {\n        if r >= 'a' && r <= 'z' || r >= 'A' && r <= 'Z' {\n            hasLetter = true\n            break\n        }\n    }\n\n    if !hasLetter {\n        runes := []rune(s)\n        for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n            runes[i], runes[j] = runes[j], runes[i]\n        }\n        return string(runes)\n    }\n\n    res := \"\"\n    for _, r := range s {\n        if r >= 'a' && r <= 'z' {\n            res += string(r - 32)\n        } else if r >= 'A' && r <= 'Z' {\n            ",
    "suffix": "\n        } else {\n            res += string(r)\n        }\n    }\n    return res\n}"
  },
  {
    "name": "HumanEval_130_tri",
    "prompt": "package tri_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc tri(n int) []int {\n",
    "canonical_solution": "if i%2 == 0 {",
    "prefix": "package tri_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc tri(n int) []int {\n    result := make([]int, n+1)\n    result[0] = 1\n    result[1] = 3\n\n    for i := 2; i <= n; i++ {\n        ",
    "suffix": "\n            result[i] = 1 + i/2\n        } else {\n            result[i] = result[i-1] + result[i-2] + result[(i+1)%len(result)]\n        }\n    }\n    return result\n}"
  },
  {
    "name": "HumanEval_36_fizz_buzz",
    "prompt": "package fizz_buzz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc fizz_buzz(n int) int {\n",
    "canonical_solution": "num := i",
    "prefix": "package fizz_buzz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc fizz_buzz(n int) int {\n    count := 0\n    for i := 1; i < n; i++ {\n        if i % 11 == 0 || i % 13 == 0 {\n            ",
    "suffix": "\n            for num > 0 {\n                if num % 10 == 7 {\n                    count++\n                }\n                num /= 10\n            }\n        }\n    }\n    return count\n}"
  },
  {
    "name": "HumanEval_29_filter_by_prefix",
    "prompt": "package filter_by_prefix_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc filter_by_prefix(strings []string, prefix string) []string {\n",
    "canonical_solution": "result = append(result, str)",
    "prefix": "package filter_by_prefix_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc filter_by_prefix(strings []string, prefix string) []string {\n    var result []string\n    for _, str := range strings {\n        if len(str) >= len(prefix) && str[:len(prefix)] == prefix {\n            ",
    "suffix": "\n        }\n    }\n    return result\n}"
  },
  {
    "name": "HumanEval_84_solve",
    "prompt": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc solve(N int) string {\n",
    "canonical_solution": "binary := fmt.Sprintf(\"%b\", N)",
    "prefix": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc solve(N int) string {\n    ",
    "suffix": "\n    sum := 0\n    for _, digit := range binary {\n        sum += int(digit - '0')\n    }\n    return fmt.Sprintf(\"%d\", sum)\n}"
  },
  {
    "name": "HumanEval_129_minPath",
    "prompt": "package minPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc minPath(grid [][]int, k int) []int {\n",
    "canonical_solution": "if steps == k {",
    "prefix": "package minPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc minPath(grid [][]int, k int) []int {\n    n := len(grid)\n    visited := make([][]bool, n)\n    for i := range visited {\n        visited[i] = make([]bool, n)\n    }\n    \n    minPath := make([]int, 0, k)\n    minVal := n*n + 1\n    minI, minJ := -1, -1\n    \n    for i := 0; i < n; i++ {\n        for j := 0; j < n; j++ {\n            if grid[i][j] < minVal {\n                minVal = grid[i][j]\n                minI, minJ = i, j\n            }\n        }\n    }\n    \n    var dfs func(i, j, steps int)\n    dfs = func(i, j, steps int) {\n        ",
    "suffix": "\n            return\n        }\n        \n        directions := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n        for _, dir := range directions {\n            ni, nj := i + dir[0], j + dir[1]\n            if ni >= 0 && ni < n && nj >= 0 && nj < n && !visited[ni][nj] {\n                visited[ni][nj] = true\n                minPath = append(minPath, grid[ni][nj])\n                dfs(ni, nj, steps+1)\n                if len(minPath) == k {\n                    return\n                }\n                visited[ni][nj] = false\n                minPath = minPath[:len(minPath)-1]\n            }\n        }\n    }\n    \n    visited[minI][minJ] = true\n    minPath = append(minPath, grid[minI][minJ])\n    dfs(minI, minJ, 1)\n    \n    return minPath\n}"
  },
  {
    "name": "HumanEval_98_count_upper",
    "prompt": "package count_upper_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc count_upper(s string) int {\n",
    "canonical_solution": "count := 0",
    "prefix": "package count_upper_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc count_upper(s string) int {\n    ",
    "suffix": "\n    for i := 0; i < len(s); i += 2 {\n        if s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U' {\n            count++\n        }\n    }\n    return count\n}"
  },
  {
    "name": "HumanEval_120_maximum",
    "prompt": "package maximum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc maximum(arr []int, k int) []int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_24_largest_divisor",
    "prompt": "package largest_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\nfunc largest_divisor(n int) int {\n",
    "canonical_solution": "if n % i == 0 {",
    "prefix": "package largest_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\nfunc largest_divisor(n int) int {\n    for i := n - 1; i > 0; i-- {\n        ",
    "suffix": "\n            return i\n        }\n    }\n    return 1\n}"
  },
  {
    "name": "HumanEval_88_sort_array",
    "prompt": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc sort_array(array []int) []int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_106_f",
    "prompt": "package f_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc f(n int) []int {\n",
    "canonical_solution": "result[i-1] = 0",
    "prefix": "package f_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc f(n int) []int {\n    result := make([]int, n)\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            result[i-1] = 1\n            for j := 2; j <= i; j++ {\n                result[i-1] *= j\n            }\n        } else {\n            ",
    "suffix": "\n            for j := 1; j <= i; j++ {\n                result[i-1] += j\n            }\n        }\n    }\n    return result\n}"
  },
  {
    "name": "HumanEval_77_iscube",
    "prompt": "package iscube_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc iscube(a int) bool {\n",
    "canonical_solution": "cubeRoot := int(float64(a) / 3.0)",
    "prefix": "package iscube_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc iscube(a int) bool {\n    ",
    "suffix": "\n    return cubeRoot*cubeRoot*cubeRoot == a\n}"
  },
  {
    "name": "HumanEval_93_encode",
    "prompt": "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc encode(message string) string {\n",
    "canonical_solution": "encodedMessage += string(ch - 24 - 'A' + 'a')",
    "prefix": "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc encode(message string) string {\n    encodedMessage := \"\"\n    for _, ch := range message {\n        if ch >= 'a' && ch <= 'z' {\n            if ch == 'y' || ch == 'z' {\n                encodedMessage += string(ch - 24 - 'a' + 'A')\n            } else if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n                encodedMessage += string(ch + 2 - 'a' + 'A')\n            } else {\n                encodedMessage += string(ch - 'a' + 'A')\n            }\n        } else if ch >= 'A' && ch <= 'Z' {\n            if ch == 'Y' || ch == 'Z' {\n                ",
    "suffix": "\n            } else if ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U' {\n                encodedMessage += string(ch + 2 - 'A' + 'a')\n            } else {\n                encodedMessage += string(ch - 'A' + 'a')\n            }\n        } else {\n            encodedMessage += string(ch)\n        }\n    }\n    return encodedMessage\n}"
  },
  {
    "name": "HumanEval_91_is_bored",
    "prompt": "package is_bored_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc is_bored(S string) int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_43_pairs_sum_to_zero",
    "prompt": "package pairs_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc pairs_sum_to_zero(l []int) bool {\n",
    "canonical_solution": "return false",
    "prefix": "package pairs_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc pairs_sum_to_zero(l []int) bool {\n  m := make(map[int]bool)\n  for _, num := range l {\n    if m[-num] {\n      return true\n    }\n    m[num] = true\n  }\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_71_triangle_area",
    "prompt": "package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc triangle_area(a int, b int, c int) float64 {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_148_bf",
    "prompt": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc bf(planet1 string, planet2 string) []interface{} {\n",
    "canonical_solution": "p2Index := -1",
    "prefix": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    p1Index := -1\n    ",
    "suffix": "\n\n    for i, planet := range planets {\n        if planet == planet1 {\n            p1Index = i\n        }\n        if planet == planet2 {\n            p2Index = i\n        }\n    }\n\n    if p1Index == -1 || p2Index == -1 {\n        return []interface{}{}\n    }\n\n    if p1Index > p2Index {\n        p1Index, p2Index = p2Index, p1Index\n    }\n\n    result := []interface{}{}\n    for i := p1Index + 1; i < p2Index; i++ {\n        result = append(result, planets[i])\n    }\n\n    return result\n}"
  },
  {
    "name": "HumanEval_131_digits",
    "prompt": "package digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc digits(n int) int {\n",
    "canonical_solution": "hasOdd := false",
    "prefix": "package digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc digits(n int) int {\nproduct := 1\n",
    "suffix": "\n\nfor n > 0 {\n    digit := n % 10\n    if digit % 2 != 0 {\n        product *= digit\n        hasOdd = true\n    }\n    n /= 10\n}\n\nif hasOdd {\n    return product\n}\nreturn 0\n}"
  },
  {
    "name": "HumanEval_101_words_string",
    "prompt": "package words_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc words_string(s string) []string {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_18_how_many_times",
    "prompt": "package how_many_times_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc how_many_times(myString string, substring string) int {\n",
    "canonical_solution": "for i := 0; i < len(myString); i++ {",
    "prefix": "package how_many_times_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc how_many_times(myString string, substring string) int {\n  count := 0\n  ",
    "suffix": "\n    if len(myString[i:]) >= len(substring) && myString[i:i+len(substring)] == substring {\n      count++\n    }\n  }\n  return count\n}"
  },
  {
    "name": "HumanEval_51_remove_vowels",
    "prompt": "package remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc remove_vowels(text string) string {\n",
    "canonical_solution": "if !vowels[char] {",
    "prefix": "package remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc remove_vowels(text string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'A': true, 'E': true, 'I': true, 'O': true, 'U': true}\n    result := \"\"\n    for _, char := range text {\n        ",
    "suffix": "\n            result += string(char)\n        }\n    }\n    return result\n}"
  },
  {
    "name": "HumanEval_70_strange_sort_list",
    "prompt": "package strange_sort_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc strange_sort_list(lst []int) []int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_20_find_closest_elements",
    "prompt": "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\nfunc find_closest_elements(numbers []float64) []interface{} {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_76_is_simple_power",
    "prompt": "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc is_simple_power(x int, n int) bool {\n",
    "canonical_solution": "if x == 1 {",
    "prefix": "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc is_simple_power(x int, n int) bool {\n    ",
    "suffix": "\n        return true\n    }\n\n    for i := n; i <= x; i *= n {\n        if i == x {\n            return true\n        }\n    }\n\n    return false\n}"
  },
  {
    "name": "HumanEval_39_prime_fib",
    "prompt": "package prime_fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc prime_fib(n int) int {\n",
    "canonical_solution": "fmt.Println(\"Invalid input\")",
    "prefix": "package prime_fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc prime_fib(n int) int {\n    primes := []int{2, 3, 5, 13, 89}\n    if n <= 0 || n > len(primes) {\n        ",
    "suffix": "\n        return -1\n    }\n    return primes[n-1]\n}"
  },
  {
    "name": "HumanEval_145_order_by_points",
    "prompt": "package order_by_points_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc order_by_points(nums []int) []int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_0_has_close_elements",
    "prompt": "package has_close_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\nfunc has_close_elements(numbers []float64, threshold float64) bool {\n",
    "canonical_solution": "for i := 0; i < len(numbers); i++ {",
    "prefix": "package has_close_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\nfunc has_close_elements(numbers []float64, threshold float64) bool {\n    ",
    "suffix": "\n        for j := i+1; j < len(numbers); j++ {\n            if abs(numbers[i] - numbers[j]) < threshold {\n                return true\n            }\n        }\n    }\n    return false\n}\n\nfunc abs(x float64) float64 {\n    if x < 0 {\n        return -x\n    }\n    return x\n}"
  },
  {
    "name": "HumanEval_10_make_palindrome",
    "prompt": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc make_palindrome(myString string) string {\n",
    "canonical_solution": "return myString + reverse(myString[i:])",
    "prefix": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return \"\"\n    }\n\n    reverse := func(s string) string {\n        runes := []rune(s)\n        for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n            runes[i], runes[j] = runes[j], runes[i]\n        }\n        return string(runes)\n    }\n\n    for i := len(myString); i >= 0; i-- {\n        if myString[:i] == reverse(myString[:i]) {\n            ",
    "suffix": "\n        }\n    }\n\n    return myString + reverse(myString[1:])\n}"
  },
  {
    "name": "HumanEval_11_string_xor",
    "prompt": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\nfunc string_xor(a string, b string) string {\n",
    "canonical_solution": "result += \"1\"",
    "prefix": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\nfunc string_xor(a string, b string) string {\n    result := \"\"\n    for i := 0; i < len(a); i++ {\n        if a[i] == b[i] {\n            result += \"0\"\n        } else {\n            ",
    "suffix": "\n        }\n    }\n    return result\n}"
  },
  {
    "name": "HumanEval_139_special_factorial",
    "prompt": "package special_factorial_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc special_factorial(n int) int {\n",
    "canonical_solution": "return 1",
    "prefix": "package special_factorial_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc special_factorial(n int) int {\n    if n == 0 {\n        ",
    "suffix": "\n    } else {\n        return n * special_factorial(n-1) * special_factorial(n-2)\n    }\n}"
  },
  {
    "name": "HumanEval_122_add_elements",
    "prompt": "package add_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc add_elements(arr []int, k int) int {\n",
    "canonical_solution": "if arr[i] >= -99 && arr[i] <= 99 {",
    "prefix": "package add_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc add_elements(arr []int, k int) int {\n    sum := 0\n    for i := 0; i < k; i++ {\n        ",
    "suffix": "\n            sum += arr[i]\n        }\n    }\n    return sum\n}"
  },
  {
    "name": "HumanEval_46_fib4",
    "prompt": "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc fib4(n int) int {\n",
    "canonical_solution": "a, b, c, d := 0, 0, 2, 0",
    "prefix": "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc fib4(n int) int {\n  if n < 4 {\n    if n == 2 {\n      return 2\n    }\n    return 0\n  }\n\n  ",
    "suffix": "\n  for i := 4; i <= n; i++ {\n    a, b, c, d = b, c, d, a+b+c+d\n  }\n\n  return d\n}"
  },
  {
    "name": "HumanEval_104_unique_digits",
    "prompt": "package unique_digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc unique_digits(x []int) []int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_117_select_words",
    "prompt": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc select_words(s string, n int) []string {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_72_will_it_fly",
    "prompt": "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc will_it_fly(q []int, w int) bool {\n",
    "canonical_solution": "for _, v := range q {",
    "prefix": "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc will_it_fly(q []int, w int) bool {\n    sum := 0\n    ",
    "suffix": "\n        sum += v\n    }\n    if sum > w {\n        return false\n    }\n\n    for i := 0; i < len(q)/2; i++ {\n        if q[i] != q[len(q)-i-1] {\n            return false\n        }\n    }\n\n    return true\n}"
  },
  {
    "name": "HumanEval_55_fib",
    "prompt": "package fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc fib(n int) int {\n",
    "canonical_solution": "return n",
    "prefix": "package fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc fib(n int) int {\n    if n <= 1 {\n        ",
    "suffix": "\n    }\n    a, b := 0, 1\n    for i := 2; i <= n; i++ {\n        a, b = b, a+b\n    }\n    return b\n}"
  },
  {
    "name": "HumanEval_153_Strongest_Extension",
    "prompt": "package Strongest_Extension_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Strongest_Extension(class_name string, extensions []string) string {\n",
    "canonical_solution": "for _, extension := range extensions {",
    "prefix": "package Strongest_Extension_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Strongest_Extension(class_name string, extensions []string) string {\n  strongestExtension := \"\"\n  maxStrength := -1\n  ",
    "suffix": "\n    cap, sm := 0, 0\n    for _, char := range extension {\n      if char >= 'A' && char <= 'Z' {\n        cap++\n      } else if char >= 'a' && char <= 'z' {\n        sm++\n      }\n    }\n    strength := cap - sm\n    if strength > maxStrength {\n      maxStrength = strength\n      strongestExtension = extension\n    }\n  }\n  return class_name + \".\" + strongestExtension\n}"
  },
  {
    "name": "HumanEval_119_match_parens",
    "prompt": "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc match_parens(lst []string) string {\n",
    "canonical_solution": "if balance == 0 {",
    "prefix": "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc match_parens(lst []string) string {\n    balance := 0\n    for _, str := range lst {\n        for _, ch := range str {\n            if ch == '(' {\n                balance++\n            } else if ch == ')' {\n                balance--\n            }\n            if balance < 0 {\n                return \"No\"\n            }\n        }\n    }\n    ",
    "suffix": "\n        return \"Yes\"\n    }\n    return \"No\"\n}"
  },
  {
    "name": "HumanEval_92_any_int",
    "prompt": "package any_int_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc any_int(x float64, y float64, z float64) bool {\n",
    "canonical_solution": "return true",
    "prefix": "package any_int_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc any_int(x float64, y float64, z float64) bool {\n    if x == y+z || y == x+z || z == x+y {\n        ",
    "suffix": "\n    }\n    return false\n}"
  },
  {
    "name": "HumanEval_2_truncate_number",
    "prompt": "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\nfunc truncate_number(number float64) float64 {\n",
    "canonical_solution": "return decimalPart",
    "prefix": "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\nfunc truncate_number(number float64) float64 {\n  integerPart := int(number)\n  decimalPart := number - float64(integerPart)\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_42_incr_list",
    "prompt": "package incr_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc incr_list(l []int) []int {\n",
    "canonical_solution": "return l",
    "prefix": "package incr_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc incr_list(l []int) []int {\n    for i := range l {\n        l[i]++\n    }\n    ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_150_x_or_y",
    "prompt": "package x_or_y_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc x_or_y(n int, x int, y int) int {\n",
    "canonical_solution": "if n%i == 0 {",
    "prefix": "package x_or_y_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc x_or_y(n int, x int, y int) int {\n    if isPrime(n) {\n        return x\n    } else {\n        return y\n    }\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        ",
    "suffix": "\n            return false\n        }\n    }\n    return true\n}"
  },
  {
    "name": "HumanEval_49_modp",
    "prompt": "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc modp(n int, p int) int {\n",
    "canonical_solution": "return result",
    "prefix": "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc modp(n int, p int) int {\n    result := 1\n    for i := 0; i < n; i++ {\n        result = (result * 2) % p\n    }\n    ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_155_even_odd_count",
    "prompt": "package even_odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\nfunc even_odd_count(num int) []interface{} {\n",
    "canonical_solution": "func abs(x int) int {",
    "prefix": "package even_odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\nfunc even_odd_count(num int) []interface{} {\n    even_count := 0\n    odd_count := 0\n\n    num = abs(num)\n\n    for num != 0 {\n        digit := num % 10\n        if digit % 2 == 0 {\n            even_count++\n        } else {\n            odd_count++\n        }\n        num = num / 10\n    }\n\n    return []interface{}{even_count, odd_count}\n}\n\n",
    "suffix": "\n    if x < 0 {\n        return -x\n    }\n    return x\n}"
  },
  {
    "name": "HumanEval_80_is_happy",
    "prompt": "package is_happy_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc is_happy(s string) bool {\n",
    "canonical_solution": "if len(s) < 3 {",
    "prefix": "package is_happy_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc is_happy(s string) bool {\n    ",
    "suffix": "\n        return false\n    }\n\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2] {\n            return false\n        }\n    }\n\n    return true\n}"
  },
  {
    "name": "HumanEval_59_largest_prime_factor",
    "prompt": "package largest_prime_factor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc largest_prime_factor(n int) int {\n",
    "canonical_solution": "largest := 2",
    "prefix": "package largest_prime_factor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc largest_prime_factor(n int) int {\n    ",
    "suffix": "\n\n    for n % 2 == 0 {\n        n = n / 2\n    }\n\n    for i := 3; i*i <= n; i += 2 {\n        for n % i == 0 {\n            largest = i\n            n = n / i\n        }\n    }\n\n    if n > 2 {\n        largest = n\n    }\n\n    return largest\n}"
  },
  {
    "name": "HumanEval_66_digitSum",
    "prompt": "package digitSum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc digitSum(s string) int {\n",
    "canonical_solution": "if 'A' <= r && r <= 'Z' {",
    "prefix": "package digitSum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc digitSum(s string) int {\n    sum := 0\n    for _, r := range s {\n        ",
    "suffix": "\n            sum += int(r)\n        }\n    }\n    return sum\n}"
  },
  {
    "name": "HumanEval_21_rescale_to_unit",
    "prompt": "package rescale_to_unit_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\nfunc rescale_to_unit(numbers []float64) []float64 {\n",
    "canonical_solution": "return numbers",
    "prefix": "package rescale_to_unit_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\nfunc rescale_to_unit(numbers []float64) []float64 {\n    min := numbers[0]\n    max := numbers[0]\n\n    for _, num := range numbers {\n        if num < min {\n            min = num\n        }\n        if num > max {\n            max = num\n        }\n    }\n\n    for i, num := range numbers {\n        numbers[i] = (num - min) / (max - min)\n    }\n\n    ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_121_solution",
    "prompt": "package solution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc solution(lst []int) int {\n",
    "canonical_solution": "for i := 0; i < len(lst); i += 2 {",
    "prefix": "package solution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc solution(lst []int) int {\n    sum := 0\n    ",
    "suffix": "\n        if lst[i] % 2 != 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}"
  },
  {
    "name": "HumanEval_68_pluck",
    "prompt": "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc pluck(arr []int) []int {\n",
    "canonical_solution": "return []int{min, index}",
    "prefix": "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc pluck(arr []int) []int {\n  min := -1\n  index := -1\n  for i, val := range arr {\n    if val%2 == 0 {\n      if min == -1 || val < min {\n        min = val\n        index = i\n      }\n    }\n  }\n  if min == -1 {\n    return []int{}\n  }\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_147_get_max_triples",
    "prompt": "package get_max_triples_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc get_max_triples(n int) int {\n",
    "canonical_solution": "for k := j+1; k < n; k++ {",
    "prefix": "package get_max_triples_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc get_max_triples(n int) int {\n    a := make([]int, n)\n    for i := 1; i <= n; i++ {\n        a[i-1] = i*i - i + 1\n    }\n\n    count := 0\n    for i := 0; i < n; i++ {\n        for j := i+1; j < n; j++ {\n            ",
    "suffix": "\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count++\n                }\n            }\n        }\n    }\n    return count\n}"
  },
  {
    "name": "HumanEval_110_exchange",
    "prompt": "package exchange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc exchange(lst1 []int, lst2 []int) string {\n",
    "canonical_solution": "for _, num := range lst2 {",
    "prefix": "package exchange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc exchange(lst1 []int, lst2 []int) string {\n  oddCount1 := 0\n  evenCount2 := 0\n\n  for _, num := range lst1 {\n    if num%2 != 0 {\n      oddCount1++\n    }\n  }\n\n  ",
    "suffix": "\n    if num%2 == 0 {\n      evenCount2++\n    }\n  }\n\n  if oddCount1 <= evenCount2 {\n    return \"YES\"\n  } else {\n    return \"NO\"\n  }\n}"
  },
  {
    "name": "HumanEval_47_median",
    "prompt": "package median_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc median(l []int) float64 {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_82_prime_length",
    "prompt": "package prime_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc prime_length(myString string) bool {\n",
    "canonical_solution": "return false",
    "prefix": "package prime_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc prime_length(myString string) bool {\n    n := len(myString)\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i * i <= n; i++ {\n        if n % i == 0 {\n            ",
    "suffix": "\n        }\n    }\n    return true\n}"
  },
  {
    "name": "HumanEval_73_smallest_change",
    "prompt": "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc smallest_change(arr []int) int {\n",
    "canonical_solution": "changes := 0",
    "prefix": "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc smallest_change(arr []int) int {\n    ",
    "suffix": "\n    i := 0\n    j := len(arr) - 1\n    for i <= j {\n        if arr[i] != arr[j] {\n            changes++\n        }\n        i++\n        j--\n    }\n    return changes\n}"
  },
  {
    "name": "HumanEval_133_sum_squares",
    "prompt": "package sum_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc sum_squares(lst []float64) int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_141_file_name_check",
    "prompt": "package file_name_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc file_name_check(file_name string) string {\n",
    "canonical_solution": "return \"No\"",
    "prefix": "package file_name_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc file_name_check(file_name string) string {\n    countDigits := 0\n    for _, char := range file_name {\n        if char >= '0' && char <= '9' {\n            countDigits++\n        }\n    }\n\n    if countDigits > 3 {\n        ",
    "suffix": "\n    }\n\n    dotIndex := -1\n    for i, char := range file_name {\n        if char == '.' {\n            if dotIndex != -1 {\n                return \"No\"\n            }\n            dotIndex = i\n        }\n    }\n\n    if dotIndex == -1 || dotIndex == 0 || !(file_name[0] >= 'a' && file_name[0] <= 'z' || file_name[0] >= 'A' && file_name[0] <= 'Z') {\n        return \"No\"\n    }\n\n    extension := file_name[dotIndex+1:]\n    if extension != \"txt\" && extension != \"exe\" && extension != \"dll\" {\n        return \"No\"\n    }\n\n    return \"Yes\"\n}"
  },
  {
    "name": "HumanEval_40_triples_sum_to_zero",
    "prompt": "package triples_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc triples_sum_to_zero(l []int) bool {\n",
    "canonical_solution": "for k := j+1; k < n; k++ {",
    "prefix": "package triples_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc triples_sum_to_zero(l []int) bool {\n    n := len(l)\n    for i := 0; i < n-2; i++ {\n        for j := i+1; j < n-1; j++ {\n            ",
    "suffix": "\n                if l[i]+l[j]+l[k] == 0 {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}"
  },
  {
    "name": "HumanEval_127_intersection",
    "prompt": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n",
    "canonical_solution": "return a",
    "prefix": "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n    start := max(interval1[0].(int), interval2[0].(int))\n    end := min(interval1[1].(int), interval2[1].(int))\n\n    if end < start {\n        return \"NO\"\n    }\n\n    length := end - start + 1\n\n    if isPrime(length) {\n        return \"YES\"\n    }\n\n    return \"NO\"\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        ",
    "suffix": "\n    }\n    return b\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}"
  },
  {
    "name": "HumanEval_1_separate_paren_groups",
    "prompt": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\nfunc separate_paren_groups(paren_string string) []string {\n",
    "canonical_solution": "temp += string(char)",
    "prefix": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var temp string\n    var count int\n\n    for _, char := range paren_string {\n        if char == '(' {\n            count++\n            temp += string(char)\n        } else if char == ')' {\n            count--\n            ",
    "suffix": "\n            if count == 0 {\n                result = append(result, temp)\n                temp = \"\"\n            }\n        }\n    }\n\n    return result\n}"
  },
  {
    "name": "HumanEval_152_compare",
    "prompt": "package compare_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc compare(game []int, guess []int) []int {\n",
    "canonical_solution": "result := make([]int, len(game))",
    "prefix": "package compare_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc compare(game []int, guess []int) []int {\n    ",
    "suffix": "\n    for i := range game {\n        result[i] = abs(game[i] - guess[i])\n    }\n    return result\n}\n\nfunc abs(n int) int {\n    if n < 0 {\n        return -n\n    }\n    return n\n}"
  },
  {
    "name": "HumanEval_83_starts_one_ends",
    "prompt": "package starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\nfunc starts_one_ends(n int) int {\n",
    "canonical_solution": "if n == 1 {",
    "prefix": "package starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\nfunc starts_one_ends(n int) int {\n    ",
    "suffix": "\n        return 2\n    }\n    return 2 * 10 * (1 << (n - 2))\n}"
  },
  {
    "name": "HumanEval_134_check_if_last_char_is_a_letter",
    "prompt": "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc check_if_last_char_is_a_letter(txt string) bool {\n",
    "canonical_solution": "return true",
    "prefix": "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n    if lastChar >= 'a' && lastChar <= 'z' || lastChar >= 'A' && lastChar <= 'Z' {\n        if len(txt) == 1 || txt[len(txt)-2] == ' ' {\n            ",
    "suffix": "\n        }\n    }\n    return false\n}"
  },
  {
    "name": "HumanEval_124_valid_date",
    "prompt": "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc valid_date(date string) bool {\n",
    "canonical_solution": "_, err := fmt.Sscanf(date, \"%2d-%2d-%4d\", &month, &day, &year)",
    "prefix": "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc valid_date(date string) bool {\n    if len(date) != 10 {\n        return false\n    }\n    \n    var day, month, year int\n    ",
    "suffix": "\n    if err != nil {\n        return false\n    }\n\n    if month < 1 || month > 12 {\n        return false\n    }\n\n    if day < 1 {\n        return false\n    }\n\n    if month == 2 {\n        if day > 29 {\n            return false\n        }\n    } else if month == 4 || month == 6 || month == 9 || month == 11 {\n        if day > 30 {\n            return false\n        }\n    } else {\n        if day > 31 {\n            return false\n        }\n    }\n\n    return true\n}"
  },
  {
    "name": "HumanEval_108_count_nums",
    "prompt": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc count_nums(arr []int) int {\n",
    "canonical_solution": "return count",
    "prefix": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, num := range arr {\n        sum := 0\n        for num != 0 {\n            sum += num % 10\n            num /= 10\n        }\n        if sum > 0 {\n            count++\n        }\n    }\n    ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_86_anti_shuffle",
    "prompt": "package anti_shuffle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc anti_shuffle(s string) string {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_48_is_palindrome",
    "prompt": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc is_palindrome(text string) bool {\n",
    "canonical_solution": "if text[i] != text[len(text)-i-1] {",
    "prefix": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc is_palindrome(text string) bool {\n    for i := 0; i < len(text)/2; i++ {\n        ",
    "suffix": "\n            return false\n        }\n    }\n    return true\n}"
  },
  {
    "name": "HumanEval_118_get_closest_vowel",
    "prompt": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc get_closest_vowel(word string) string {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_31_is_prime",
    "prompt": "package is_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc is_prime(n int) bool {\n",
    "canonical_solution": "return false",
    "prefix": "package is_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc is_prime(n int) bool {\n  if n <= 1 {\n    return false\n  }\n  for i := 2; i * i <= n; i++ {\n    if n % i == 0 {\n      ",
    "suffix": "\n    }\n  }\n  return true\n}"
  },
  {
    "name": "HumanEval_144_simplify",
    "prompt": "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc simplify(x string, n string) bool {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_78_hex_key",
    "prompt": "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc hex_key(num string) int {\n",
    "canonical_solution": "count := 0",
    "prefix": "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc hex_key(num string) int {\n  ",
    "suffix": "\n  primes := map[rune]bool{'2': true, '3': true, '5': true, '7': true, 'B': true, 'D': true}\n\n  for _, digit := range num {\n    if primes[digit] {\n      count++\n    }\n  }\n\n  return count\n}"
  },
  {
    "name": "HumanEval_143_words_in_sentence",
    "prompt": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc words_in_sentence(sentence string) string {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_111_histogram",
    "prompt": "package histogram_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc histogram(test string) map[string]int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_87_get_row",
    "prompt": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc get_row(lst [][]int, x int) [][]interface{} {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_123_get_odd_collatz",
    "prompt": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc get_odd_collatz(n int) []int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_135_can_arrange",
    "prompt": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc can_arrange(arr []int) int {\n",
    "canonical_solution": "for i := len(arr) - 1; i > 0; i-- {",
    "prefix": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc can_arrange(arr []int) int {\n    ",
    "suffix": "\n        if arr[i] < arr[i-1] {\n            return i\n        }\n    }\n    return -1\n}"
  },
  {
    "name": "HumanEval_19_sort_numbers",
    "prompt": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc sort_numbers(numbers string) string {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_65_circular_shift",
    "prompt": "package circular_shift_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc circular_shift(x int, shift int) string {\n",
    "canonical_solution": "if shift >= length {",
    "prefix": "package circular_shift_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc circular_shift(x int, shift int) string {\n    xStr := fmt.Sprintf(\"%d\", x)\n    length := len(xStr)\n\n    ",
    "suffix": "\n        return string(reverse([]rune(xStr)))\n    }\n\n    return xStr[length-shift:] + xStr[:length-shift]\n}\n\nfunc reverse(runes []rune) []rune {\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return runes\n}"
  },
  {
    "name": "HumanEval_142_sum_squares",
    "prompt": "package sum_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc sum_squares(lst []int) int {\n",
    "canonical_solution": "sum += num",
    "prefix": "package sum_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc sum_squares(lst []int) int {\n    sum := 0\n    for i, num := range lst {\n        if i % 3 == 0 && i % 4 != 0 {\n            sum += num * num\n        } else if i % 4 == 0 {\n            sum += num * num * num\n        } else {\n            ",
    "suffix": "\n        }\n    }\n    return sum\n}"
  },
  {
    "name": "HumanEval_94_skjkasdkd",
    "prompt": "package skjkasdkd_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc skjkasdkd(lst []int) int {\n",
    "canonical_solution": "return sumDigits(maxPrime)",
    "prefix": "package skjkasdkd_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc skjkasdkd(lst []int) int {\n    maxPrime := -1\n    for _, num := range lst {\n        if isPrime(num) && num > maxPrime {\n            maxPrime = num\n        }\n    }\n    if maxPrime == -1 {\n        return 0\n    }\n    ",
    "suffix": "\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    for i := 3; i*i <= n; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc sumDigits(n int) int {\n    sum := 0\n    for n != 0 {\n        sum += n % 10\n        n /= 10\n    }\n    return sum\n}"
  },
  {
    "name": "HumanEval_8_sum_product",
    "prompt": "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\nfunc sum_product(numbers []int) []interface{} {\n",
    "canonical_solution": "sum := 0",
    "prefix": "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\nfunc sum_product(numbers []int) []interface{} {\n    ",
    "suffix": "\n    product := 1\n    for _, number := range numbers {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum, product}\n}"
  },
  {
    "name": "HumanEval_102_choose_num",
    "prompt": "package choose_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc choose_num(x int, y int) int {\n",
    "canonical_solution": "if x > y {",
    "prefix": "package choose_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc choose_num(x int, y int) int {\n    ",
    "suffix": "\n        return -1\n    }\n    if y % 2 == 0 {\n        return y\n    }\n    if (y-1) >= x && (y-1) % 2 == 0 {\n        return y - 1\n    }\n    return -1\n}"
  },
  {
    "name": "HumanEval_136_largest_smallest_integers",
    "prompt": "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc largest_smallest_integers(lst []int) []interface{} {\n",
    "canonical_solution": "if maxNegative == nil || num > *maxNegative {",
    "prefix": "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc largest_smallest_integers(lst []int) []interface{} {\n    var maxNegative, minPositive *int\n\n    for _, num := range lst {\n        if num < 0 {\n            ",
    "suffix": "\n                maxNegative = &num\n            }\n        } else if num > 0 {\n            if minPositive == nil || num < *minPositive {\n                minPositive = &num\n            }\n        }\n    }\n\n    return []interface{}{maxNegative, minPositive}\n}"
  },
  {
    "name": "HumanEval_16_count_distinct_characters",
    "prompt": "package count_distinct_characters_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc count_distinct_characters(myString string) int {\n",
    "canonical_solution": "charSet[char] = true",
    "prefix": "package count_distinct_characters_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc count_distinct_characters(myString string) int {\n    charSet := make(map[rune]bool)\n    for _, char := range myString {\n        ",
    "suffix": "\n    }\n    return len(charSet)\n}"
  },
  {
    "name": "HumanEval_100_make_a_pile",
    "prompt": "package make_a_pile_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc make_a_pile(n int) []int {\n",
    "canonical_solution": "pile := make([]int, n)",
    "prefix": "package make_a_pile_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc make_a_pile(n int) []int {\n    ",
    "suffix": "\n    for i := 0; i < n; i++ {\n        pile[i] = n + 2 * i\n    }\n    return pile\n}"
  },
  {
    "name": "HumanEval_114_minSubArraySum",
    "prompt": "package minSubArraySum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc minSubArraySum(nums []int) int {\n",
    "canonical_solution": "return minSum",
    "prefix": "package minSubArraySum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc minSubArraySum(nums []int) int {\n  minSum := nums[0]\n  for i := 0; i < len(nums); i++ {\n    sum := 0\n    for j := i; j < len(nums); j++ {\n      sum += nums[j]\n      if sum < minSum {\n        minSum = sum\n      }\n    }\n  }\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_15_string_sequence",
    "prompt": "package string_sequence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc string_sequence(n int) string {\n",
    "canonical_solution": "result += fmt.Sprintf(\"%d\", i)",
    "prefix": "package string_sequence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc string_sequence(n int) string {\n  result := \"\"\n  for i := 0; i <= n; i++ {\n    if i != n {\n      result += fmt.Sprintf(\"%d \", i)\n    } else {\n      ",
    "suffix": "\n    }\n  }\n  return result\n}"
  },
  {
    "name": "HumanEval_154_cycpattern_check",
    "prompt": "package cycpattern_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc cycpattern_check(a string, b string) bool {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_57_monotonic",
    "prompt": "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc monotonic(l []int) bool {\n",
    "canonical_solution": "if direction > 0 && l[i] - l[i-1] < 0 {",
    "prefix": "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc monotonic(l []int) bool {\n    if len(l) <= 2 {\n        return true\n    }\n\n    direction := l[1] - l[0]\n    for i := 2; i < len(l); i++ {\n        ",
    "suffix": "\n            return false\n        } else if direction < 0 && l[i] - l[i-1] > 0 {\n            return false\n        } else if direction == 0 {\n            direction = l[i] - l[i-1]\n        }\n    }\n\n    return true\n}"
  },
  {
    "name": "HumanEval_52_below_threshold",
    "prompt": "package below_threshold_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc below_threshold(l []int, t int) bool {\n",
    "canonical_solution": "for _, num := range l {",
    "prefix": "package below_threshold_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc below_threshold(l []int, t int) bool {\n    ",
    "suffix": "\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}"
  },
  {
    "name": "HumanEval_75_is_multiply_prime",
    "prompt": "package is_multiply_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc is_multiply_prime(a int) bool {\n",
    "canonical_solution": "primes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}",
    "prefix": "package is_multiply_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc is_multiply_prime(a int) bool {\n    ",
    "suffix": "\n    for _, i := range primes {\n        for _, j := range primes {\n            for _, k := range primes {\n                if i*j*k == a {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}"
  },
  {
    "name": "HumanEval_30_get_positive",
    "prompt": "package get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc get_positive(l []int) []int {\n",
    "canonical_solution": "for _, num := range l {",
    "prefix": "package get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc get_positive(l []int) []int {\n  var positive []int\n  ",
    "suffix": "\n    if num > 0 {\n      positive = append(positive, num)\n    }\n  }\n  return positive\n}"
  },
  {
    "name": "HumanEval_33_sort_third",
    "prompt": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc sort_third(l []int) []int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_6_parse_nested_parens",
    "prompt": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc parse_nested_parens(paren_string string) []int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_45_triangle_area",
    "prompt": "package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\nfunc triangle_area(a int, h int) float64 {\n",
    "canonical_solution": "return float64(a) * float64(h) / 2.0",
    "prefix": "package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\nfunc triangle_area(a int, h int) float64 {\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_97_multiply",
    "prompt": "package multiply_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc multiply(a int, b int) int {\n",
    "canonical_solution": "return (a % 10) * (b % 10)",
    "prefix": "package multiply_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc multiply(a int, b int) int {\n    ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_4_mean_absolute_deviation",
    "prompt": "package mean_absolute_deviation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc mean_absolute_deviation(numbers []float64) float64 {\n",
    "canonical_solution": "if x < 0 {",
    "prefix": "package mean_absolute_deviation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc mean_absolute_deviation(numbers []float64) float64 {\n    var sum float64\n    for _, number := range numbers {\n        sum += number\n    }\n\n    mean := sum / float64(len(numbers))\n\n    var madSum float64\n    for _, number := range numbers {\n        madSum += abs(number - mean)\n    }\n\n    return madSum / float64(len(numbers))\n}\n\nfunc abs(x float64) float64 {\n    ",
    "suffix": "\n        return -x\n    }\n    return x\n}"
  },
  {
    "name": "HumanEval_58_common",
    "prompt": "package common_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc common(l1 []int, l2 []int) []int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_156_int_to_mini_roman",
    "prompt": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc int_to_mini_roman(number int) string {\n",
    "canonical_solution": "return roman",
    "prefix": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc int_to_mini_roman(number int) string {\n    values := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n    symbols := []string{\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n\n    roman := \"\"\n    i := 0\n    for number > 0 {\n        k := number / values[i]\n        for j := 0; j < k; j++ {\n            roman += symbols[i]\n            number -= values[i]\n        }\n        i++\n    }\n    ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_67_fruit_distribution",
    "prompt": "package fruit_distribution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc fruit_distribution(s string, n int) int {\n",
    "canonical_solution": "fmt.Sscanf(s, \"%d apples and %d oranges\", &apples, &oranges)",
    "prefix": "package fruit_distribution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc fruit_distribution(s string, n int) int {\n    var apples, oranges int\n    ",
    "suffix": "\n    mangoes := n - (apples + oranges)\n    return mangoes\n}"
  },
  {
    "name": "HumanEval_112_reverse_delete",
    "prompt": "package reverse_delete_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc reverse_delete(s string, c string) []interface{} {\n",
    "canonical_solution": "for _, ch := range c {",
    "prefix": "package reverse_delete_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc reverse_delete(s string, c string) []interface{} {\n    chars := make(map[rune]bool)\n    ",
    "suffix": "\n        chars[ch] = true\n    }\n\n    var result []rune\n    for _, ch := range s {\n        if !chars[ch] {\n            result = append(result, ch)\n        }\n    }\n\n    str := string(result)\n    isPalindrome := str == reverse(str)\n\n    return []interface{}{str, isPalindrome}\n}\n\nfunc reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}"
  },
  {
    "name": "HumanEval_13_greatest_common_divisor",
    "prompt": "package greatest_common_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc greatest_common_divisor(a int, b int) int {\n",
    "canonical_solution": "a = t",
    "prefix": "package greatest_common_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc greatest_common_divisor(a int, b int) int {\n    for b != 0 {\n        t := b\n        b = a % b\n        ",
    "suffix": "\n    }\n    return a\n}"
  },
  {
    "name": "HumanEval_116_sort_array",
    "prompt": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc sort_array(arr []int) []int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_28_concatenate",
    "prompt": "package concatenate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc concatenate(strings []string) string {\n",
    "canonical_solution": "result += str",
    "prefix": "package concatenate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc concatenate(strings []string) string {\n    var result string\n    for _, str := range strings {\n        ",
    "suffix": "\n    }\n    return result\n}"
  },
  {
    "name": "HumanEval_149_sorted_list_sum",
    "prompt": "package sorted_list_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc sorted_list_sum(lst []string) []string {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_7_filter_by_substring",
    "prompt": "package filter_by_substring_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc filter_by_substring(strings []string, substring string) []string {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_99_closest_integer",
    "prompt": "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc closest_integer(value string) int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_64_vowels_count",
    "prompt": "package vowels_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc vowels_count(s string) int {\n",
    "canonical_solution": "case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':",
    "prefix": "package vowels_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc vowels_count(s string) int {\n    count := 0\n    for i, char := range s {\n        switch char {\n        ",
    "suffix": "\n            count++\n        case 'y', 'Y':\n            if i == len(s)-1 {\n                count++\n            }\n        }\n    }\n    return count\n}"
  },
  {
    "name": "HumanEval_158_find_max",
    "prompt": "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc find_max(words []string) string {\n",
    "canonical_solution": "if len(unique) > maxUnique || (len(unique) == maxUnique && word < lexOrder) {",
    "prefix": "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc find_max(words []string) string {\n    maxUnique := 0\n    lexOrder := \"\"\n    for _, word := range words {\n        unique := make(map[rune]bool)\n        for _, char := range word {\n            unique[char] = true\n        }\n        ",
    "suffix": "\n            maxUnique = len(unique)\n            lexOrder = word\n        }\n    }\n    return lexOrder\n}"
  },
  {
    "name": "HumanEval_44_change_base",
    "prompt": "package change_base_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc change_base(x int, base int) string {\n",
    "canonical_solution": "result = fmt.Sprintf(\"%d\", x%base) + result",
    "prefix": "package change_base_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc change_base(x int, base int) string {\n    var result string\n    for x > 0 {\n        ",
    "suffix": "\n        x = x / base\n    }\n    return result\n}"
  },
  {
    "name": "HumanEval_157_right_angle_triangle",
    "prompt": "package right_angle_triangle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc right_angle_triangle(a int, b int, c int) bool {\n",
    "canonical_solution": "if a*a == b*b + c*c || b*b == a*a + c*c || c*c == a*a + b*b {",
    "prefix": "package right_angle_triangle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc right_angle_triangle(a int, b int, c int) bool {\n    ",
    "suffix": "\n        return true\n    }\n    return false\n}"
  },
  {
    "name": "HumanEval_81_numerical_letter_grade",
    "prompt": "package numerical_letter_grade_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc numerical_letter_grade(grades []float64) []string {\n",
    "canonical_solution": "for i, grade := range grades {",
    "prefix": "package numerical_letter_grade_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc numerical_letter_grade(grades []float64) []string {\n    letterGrades := make([]string, len(grades))\n\n    ",
    "suffix": "\n        switch {\n        case grade == 4.0:\n            letterGrades[i] = \"A+\"\n        case grade > 3.7:\n            letterGrades[i] = \"A\"\n        case grade > 3.3:\n            letterGrades[i] = \"A-\"\n        case grade > 3.0:\n            letterGrades[i] = \"B+\"\n        case grade > 2.7:\n            letterGrades[i] = \"B\"\n        case grade > 2.3:\n            letterGrades[i] = \"B-\"\n        case grade > 2.0:\n            letterGrades[i] = \"C+\"\n        case grade > 1.7:\n            letterGrades[i] = \"C\"\n        case grade > 1.3:\n            letterGrades[i] = \"C-\"\n        case grade > 1.0:\n            letterGrades[i] = \"D+\"\n        case grade > 0.7:\n            letterGrades[i] = \"D\"\n        case grade > 0.0:\n            letterGrades[i] = \"D-\"\n        default:\n            letterGrades[i] = \"E\"\n        }\n    }\n\n    return letterGrades\n}"
  },
  {
    "name": "HumanEval_5_intersperse",
    "prompt": "package intersperse_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc intersperse(numbers []int, delimeter int) []int {\n",
    "canonical_solution": "if len(numbers) < 2 {",
    "prefix": "package intersperse_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\nfunc intersperse(numbers []int, delimeter int) []int {\n  ",
    "suffix": "\n    return numbers\n  }\n\n  result := make([]int, 0, len(numbers)*2-1)\n  for i, number := range numbers {\n    if i > 0 {\n      result = append(result, delimeter)\n    }\n    result = append(result, number)\n  }\n\n  return result\n}"
  },
  {
    "name": "HumanEval_146_specialFilter",
    "prompt": "package specialFilter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc specialFilter(nums []int) int {\n",
    "canonical_solution": "count := 0",
    "prefix": "package specialFilter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\nfunc specialFilter(nums []int) int {\n    ",
    "suffix": "\n    for _, num := range nums {\n        if num > 10 && num%2 != 0 && (num/10)%2 != 0 {\n            count++\n        }\n    }\n    return count\n}"
  },
  {
    "name": "HumanEval_60_sum_to_n",
    "prompt": "package sum_to_n_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc sum_to_n(n int) int {\n",
    "canonical_solution": "return sum",
    "prefix": "package sum_to_n_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc sum_to_n(n int) int {\n  sum := 0\n  for i := 1; i <= n; i++ {\n    sum += i\n  }\n  ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_26_remove_duplicates",
    "prompt": "package remove_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\nfunc remove_duplicates(numbers []int) []int {\n",
    "canonical_solution": "if _, value := keys[entry]; !value {",
    "prefix": "package remove_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\nfunc remove_duplicates(numbers []int) []int {\n    var result []int\n    keys := make(map[int]bool)\n    for _, entry := range numbers {\n        ",
    "suffix": "\n            keys[entry] = true\n            result = append(result, entry)\n        }\n    }\n    return result\n}"
  },
  {
    "name": "HumanEval_163_generate_integers",
    "prompt": "package generate_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc generate_integers(a int, b int) []int {\n",
    "canonical_solution": "a, b = b, a",
    "prefix": "package generate_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc generate_integers(a int, b int) []int {\n    if a > b {\n        ",
    "suffix": "\n    }\n\n    var result []int\n    for i := a; i <= b; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n        }\n    }\n    return result\n}"
  },
  {
    "name": "HumanEval_9_rolling_max",
    "prompt": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\nfunc rolling_max(numbers []int) []int {\n",
    "canonical_solution": "return result",
    "prefix": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\nfunc rolling_max(numbers []int) []int {\n    max := numbers[0]\n    result := make([]int, len(numbers))\n    result[0] = max\n\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n        result[i] = max\n    }\n    ",
    "suffix": "\n}"
  },
  {
    "name": "HumanEval_3_below_zero",
    "prompt": "package below_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc below_zero(operations []int) bool {\n",
    "canonical_solution": "return true",
    "prefix": "package below_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc below_zero(operations []int) bool {\n    balance := 0\n    for _, operation := range operations {\n        balance += operation\n        if balance < 0 {\n            ",
    "suffix": "\n        }\n    }\n    return false\n}"
  },
  {
    "name": "HumanEval_69_search",
    "prompt": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc search(lst []int) int {\n",
    "canonical_solution": "max := -1",
    "prefix": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc search(lst []int) int {\n    freq := make(map[int]int)\n    ",
    "suffix": "\n    for _, v := range lst {\n        freq[v]++\n        if freq[v] >= v && v > max {\n            max = v\n        }\n    }\n    return max\n}"
  },
  {
    "name": "HumanEval_61_correct_bracketing",
    "prompt": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc correct_bracketing(brackets string) bool {\n",
    "canonical_solution": "if char == '(' {",
    "prefix": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc correct_bracketing(brackets string) bool {\n    count := 0\n    for _, char := range brackets {\n        ",
    "suffix": "\n            count++\n        } else if char == ')' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}"
  },
  {
    "name": "HumanEval_37_sort_even",
    "prompt": "package sort_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\nfunc sort_even(l []int) []int {\n",
    "canonical_solution": ""
  },
  {
    "name": "HumanEval_54_same_chars",
    "prompt": "package same_chars_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc same_chars(s0 string, s1 string) bool {\n",
    "canonical_solution": "return false",
    "prefix": "package same_chars_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc same_chars(s0 string, s1 string) bool {\n    if len(s0) != len(s1) {\n        return false\n    }\n    count := make(map[rune]int)\n    for _, c := range s0 {\n        count[c]++\n    }\n    for _, c := range s1 {\n        if count[c] == 0 {\n            ",
    "suffix": "\n        }\n        count[c]--\n    }\n    return true\n}"
  },
  {
    "name": "HumanEval_56_correct_bracketing",
    "prompt": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc correct_bracketing(brackets string) bool {\n",
    "canonical_solution": "for _, bracket := range brackets {",
    "prefix": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc correct_bracketing(brackets string) bool {\n    count := 0\n    ",
    "suffix": "\n        if bracket == '<' {\n            count++\n        } else if bracket == '>' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}"
  }
]