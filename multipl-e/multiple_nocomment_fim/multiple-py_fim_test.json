[
  {
    "name": "SingleLineInfilling/HumanEval/23/L0",
    "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\n\ndef strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n\n    return len(string)\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/89/L0",
    "prompt": "\ndef encrypt(s):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if c in d:",
    "prefix": "\ndef encrypt(s):\n    \"\"\"-\"\"\"\n\n    d = 'abcdefghijklmnopqrstuvwxyz'\n\n    out = ''\n    for c in s:\n        ",
    "suffix": "\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/89/L0",
    "prompt": "\ndef encrypt(s):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "else:",
    "prefix": "\ndef encrypt(s):\n    \"\"\"-\"\"\"\n\n    d = 'abcdefghijklmnopqrstuvwxyz'\n\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        ",
    "suffix": "\n            out += c\n    return out\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/89/L0",
    "prompt": "\ndef encrypt(s):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "for c in s:",
    "prefix": "\ndef encrypt(s):\n    \"\"\"-\"\"\"\n\n    d = 'abcdefghijklmnopqrstuvwxyz'\n\n    out = ''\n    ",
    "suffix": "\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/89/L0",
    "prompt": "\ndef encrypt(s):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return out",
    "prefix": "\ndef encrypt(s):\n    \"\"\"-\"\"\"\n\n    d = 'abcdefghijklmnopqrstuvwxyz'\n\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/89/L0",
    "prompt": "\ndef encrypt(s):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "out += c",
    "prefix": "\ndef encrypt(s):\n    \"\"\"-\"\"\"\n\n    d = 'abcdefghijklmnopqrstuvwxyz'\n\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            ",
    "suffix": "\n    return out\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/89/L0",
    "prompt": "\ndef encrypt(s):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "out = ''",
    "prefix": "\ndef encrypt(s):\n    \"\"\"-\"\"\"\n\n    d = 'abcdefghijklmnopqrstuvwxyz'\n\n    ",
    "suffix": "\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/89/L0",
    "prompt": "\ndef encrypt(s):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "out += d[(d.index(c)+2*2) % 26]",
    "prefix": "\ndef encrypt(s):\n    \"\"\"-\"\"\"\n\n    d = 'abcdefghijklmnopqrstuvwxyz'\n\n    out = ''\n    for c in s:\n        if c in d:\n            ",
    "suffix": "\n        else:\n            out += c\n    return out\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/95/L17",
    "prompt": "\ndef check_dict_case(dict):\n    \"\"\"-\"\"\"\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n",
    "canonical_solution": "else:",
    "prefix": "\ndef check_dict_case(dict):\n    \"\"\"-\"\"\"\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n\n                    break\n            ",
    "suffix": "\n                break\n        return state == \"upper\" or state == \"lower\" \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/95/L17",
    "prompt": "\ndef check_dict_case(dict):\n    \"\"\"-\"\"\"\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n",
    "canonical_solution": "break",
    "prefix": "\ndef check_dict_case(dict):\n    \"\"\"-\"\"\"\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n\n                    ",
    "suffix": "\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/95/L17",
    "prompt": "\ndef check_dict_case(dict):\n    \"\"\"-\"\"\"\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n",
    "canonical_solution": "return state == \"upper\" or state == \"lower\" ",
    "prefix": "\ndef check_dict_case(dict):\n    \"\"\"-\"\"\"\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n\n                    break\n            else:\n                break\n        ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/95/L17",
    "prompt": "\ndef check_dict_case(dict):\n    \"\"\"-\"\"\"\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n",
    "canonical_solution": "break",
    "prefix": "\ndef check_dict_case(dict):\n    \"\"\"-\"\"\"\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n\n                    break\n            else:\n                ",
    "suffix": "\n        return state == \"upper\" or state == \"lower\" \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/85/L0",
    "prompt": "\ndef add(lst):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\ndef add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n\n    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/140/L2",
    "prompt": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n",
    "canonical_solution": "else:",
    "prefix": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        ",
    "suffix": "\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/140/L2",
    "prompt": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n",
    "canonical_solution": "while i < len(text):",
    "prefix": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n\n    ",
    "suffix": "\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/140/L2",
    "prompt": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n",
    "canonical_solution": "new_text += \"_\"*(end - start)+text[i]",
    "prefix": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                ",
    "suffix": "\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/140/L2",
    "prompt": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n",
    "canonical_solution": "i+=1",
    "prefix": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        ",
    "suffix": "\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/140/L2",
    "prompt": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n",
    "canonical_solution": "new_text += \"_\"",
    "prefix": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        ",
    "suffix": "\n    return new_text\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/140/L2",
    "prompt": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n",
    "canonical_solution": "return new_text",
    "prefix": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/140/L2",
    "prompt": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n",
    "canonical_solution": "start, end = i+1, i+1",
    "prefix": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            ",
    "suffix": "\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/140/L2",
    "prompt": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n",
    "canonical_solution": "end += 1",
    "prefix": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n\n    while i < len(text):\n        if text[i] == \" \":\n            ",
    "suffix": "\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/140/L2",
    "prompt": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n",
    "canonical_solution": "new_text += text[i]",
    "prefix": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                ",
    "suffix": "\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/140/L2",
    "prompt": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n",
    "canonical_solution": "new_text += \"-\"",
    "prefix": "\ndef fix_spaces(text):\n    \"\"\"-\"\"\"\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        ",
    "suffix": "\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/63/L4",
    "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"-\"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n",
    "canonical_solution": "return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)",
    "prefix": "\n\ndef fibfib(n: int):\n    \"\"\"-\"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n\n        return 1\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/63/L4",
    "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"-\"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n",
    "canonical_solution": "return 1",
    "prefix": "\n\ndef fibfib(n: int):\n    \"\"\"-\"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n\n        ",
    "suffix": "\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/151/L0",
    "prompt": "\ndef double_the_difference(lst):\n    '''-'''\n\n",
    "canonical_solution": "\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n\n    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/22/L0",
    "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n\n    return [x for x in values if isinstance(x, int)]\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/41/L0",
    "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\n\n    return n**2\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/17/L1",
    "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"-\"\"\"\n    note_map = {'o': 4, 'o|': 2, '.|': 1}\n",
    "canonical_solution": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/79/L0",
    "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\ndef decimal_to_binary(decimal):\n    \"\"\"You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n\n    return \"db\" + bin(decimal)[2:] + \"db\"\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/14/L3",
    "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"-\"\"\"\n    result = []\n\n    for i in range(len(string)):\n",
    "canonical_solution": "return result",
    "prefix": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"-\"\"\"\n    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/53/L0",
    "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\n\ndef add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n\n    return x + y\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/159/L1",
    "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"-\"\"\"\n    if(need <= remaining):\n",
    "canonical_solution": "else:",
    "prefix": "\ndef eat(number, need, remaining):\n    \"\"\"-\"\"\"\n    if(need <= remaining):\n        return [ number + need , remaining-need ]\n\n    ",
    "suffix": "\n        return [ number + remaining , 0]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/159/L1",
    "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"-\"\"\"\n    if(need <= remaining):\n",
    "canonical_solution": "return [ number + remaining , 0]",
    "prefix": "\ndef eat(number, need, remaining):\n    \"\"\"-\"\"\"\n    if(need <= remaining):\n        return [ number + need , remaining-need ]\n\n    else:\n        ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/115/L0",
    "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n\n    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/160/L0",
    "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "expression+= oprt + str(oprn)",
    "prefix": "\ndef do_algebra(operator, operand):\n    \"\"\"-\"\"\"\n\n    expression = str(operand[0])\n\n    for oprt, oprn in zip(operator, operand[1:]):\n        ",
    "suffix": "\n    return eval(expression)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/160/L0",
    "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "for oprt, oprn in zip(operator, operand[1:]):",
    "prefix": "\ndef do_algebra(operator, operand):\n    \"\"\"-\"\"\"\n\n    expression = str(operand[0])\n\n    ",
    "suffix": "\n        expression+= oprt + str(oprn)\n    return eval(expression)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/160/L0",
    "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return eval(expression)",
    "prefix": "\ndef do_algebra(operator, operand):\n    \"\"\"-\"\"\"\n\n    expression = str(operand[0])\n\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/27/L0",
    "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n\n    return string.swapcase()\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/105/L2",
    "prompt": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n",
    "canonical_solution": "pass",
    "prefix": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            ",
    "suffix": "\n    return new_arr\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/105/L2",
    "prompt": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n",
    "canonical_solution": "8: \"Eight\",",
    "prefix": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        ",
    "suffix": "\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/105/L2",
    "prompt": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n",
    "canonical_solution": "sorted_arr = sorted(arr, reverse=True)",
    "prefix": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    ",
    "suffix": "\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/105/L2",
    "prompt": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n",
    "canonical_solution": "for var in sorted_arr:",
    "prefix": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    ",
    "suffix": "\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/105/L2",
    "prompt": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n",
    "canonical_solution": "5: \"Five\",",
    "prefix": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n\n        3: \"Three\",\n        4: \"Four\",\n        ",
    "suffix": "\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/105/L2",
    "prompt": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n",
    "canonical_solution": "except:",
    "prefix": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        ",
    "suffix": "\n            pass\n    return new_arr\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/105/L2",
    "prompt": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n",
    "canonical_solution": "new_arr.append(dic[var])",
    "prefix": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            ",
    "suffix": "\n        except:\n            pass\n    return new_arr\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/105/L2",
    "prompt": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n",
    "canonical_solution": "new_arr = []",
    "prefix": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    ",
    "suffix": "\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/105/L2",
    "prompt": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n",
    "canonical_solution": "return new_arr",
    "prefix": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/105/L2",
    "prompt": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n",
    "canonical_solution": "try:",
    "prefix": "\ndef by_length(arr):\n    \"\"\"-\"\"\"\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        ",
    "suffix": "\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/25/L12",
    "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"-\"\"\"\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n",
    "canonical_solution": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/96/L4",
    "prompt": "\ndef count_up_to(n):\n    \"\"\"-\"\"\"\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n",
    "canonical_solution": "is_prime = False",
    "prefix": "\ndef count_up_to(n):\n    \"\"\"-\"\"\"\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n\n                ",
    "suffix": "\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/96/L4",
    "prompt": "\ndef count_up_to(n):\n    \"\"\"-\"\"\"\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n",
    "canonical_solution": "break",
    "prefix": "\ndef count_up_to(n):\n    \"\"\"-\"\"\"\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n\n                is_prime = False\n                ",
    "suffix": "\n        if is_prime:\n            primes.append(i)\n    return primes\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/96/L4",
    "prompt": "\ndef count_up_to(n):\n    \"\"\"-\"\"\"\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n",
    "canonical_solution": "primes.append(i)",
    "prefix": "\ndef count_up_to(n):\n    \"\"\"-\"\"\"\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n\n                is_prime = False\n                break\n        if is_prime:\n            ",
    "suffix": "\n    return primes\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/96/L4",
    "prompt": "\ndef count_up_to(n):\n    \"\"\"-\"\"\"\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n",
    "canonical_solution": "if is_prime:",
    "prefix": "\ndef count_up_to(n):\n    \"\"\"-\"\"\"\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n\n                is_prime = False\n                break\n        ",
    "suffix": "\n            primes.append(i)\n    return primes\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/96/L4",
    "prompt": "\ndef count_up_to(n):\n    \"\"\"-\"\"\"\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n",
    "canonical_solution": "return primes",
    "prefix": "\ndef count_up_to(n):\n    \"\"\"-\"\"\"\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    ",
    "suffix": "\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/34/L0",
    "prompt": "\n\ndef unique(l: list):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\n\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n\n    return sorted(list(set(l)))\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/74/L11",
    "prompt": "\ndef total_match(lst1, lst2):\n    '''-'''\n    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n",
    "canonical_solution": "\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/35/L4",
    "prompt": "\n\ndef max_element(l: list):\n    \"\"\"-\"\"\"\n    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n",
    "canonical_solution": "\n\ndef max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/132/L2",
    "prompt": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n",
    "canonical_solution": "closing_bracket_index.reverse()",
    "prefix": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    ",
    "suffix": "\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/132/L2",
    "prompt": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n",
    "canonical_solution": "cnt += 1",
    "prefix": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            ",
    "suffix": "\n            i += 1\n    return cnt >= 2\n\n    \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/132/L2",
    "prompt": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n",
    "canonical_solution": "i = 0",
    "prefix": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    ",
    "suffix": "\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/132/L2",
    "prompt": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n",
    "canonical_solution": "for idx in opening_bracket_index:",
    "prefix": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    ",
    "suffix": "\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/132/L2",
    "prompt": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n",
    "canonical_solution": "else:",
    "prefix": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        ",
    "suffix": "\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/132/L2",
    "prompt": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n",
    "canonical_solution": "cnt = 0",
    "prefix": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    ",
    "suffix": "\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/132/L2",
    "prompt": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n",
    "canonical_solution": "if i < l and idx < closing_bracket_index[i]:",
    "prefix": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        ",
    "suffix": "\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/132/L2",
    "prompt": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n",
    "canonical_solution": "if string[i] == '[':",
    "prefix": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n\n        ",
    "suffix": "\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/132/L2",
    "prompt": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n",
    "canonical_solution": "i += 1",
    "prefix": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            ",
    "suffix": "\n    return cnt >= 2\n\n    \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/132/L2",
    "prompt": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n",
    "canonical_solution": "opening_bracket_index.append(i)",
    "prefix": "\ndef is_nested(string):\n    '''-'''\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n\n        if string[i] == '[':\n            ",
    "suffix": "\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/103/L5",
    "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"-\"\"\"\n    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n",
    "canonical_solution": "\ndef rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/113/L1",
    "prompt": "\ndef odd_count(lst):\n    \"\"\"-\"\"\"\n    res = []\n",
    "canonical_solution": "res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")",
    "prefix": "\ndef odd_count(lst):\n    \"\"\"-\"\"\"\n    res = []\n    for arr in lst:\n\n        n = sum(int(d)%2==1 for d in arr)\n        ",
    "suffix": "\n    return res\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/113/L1",
    "prompt": "\ndef odd_count(lst):\n    \"\"\"-\"\"\"\n    res = []\n",
    "canonical_solution": "return res",
    "prefix": "\ndef odd_count(lst):\n    \"\"\"-\"\"\"\n    res = []\n    for arr in lst:\n\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/113/L1",
    "prompt": "\ndef odd_count(lst):\n    \"\"\"-\"\"\"\n    res = []\n",
    "canonical_solution": "n = sum(int(d)%2==1 for d in arr)",
    "prefix": "\ndef odd_count(lst):\n    \"\"\"-\"\"\"\n    res = []\n    for arr in lst:\n\n        ",
    "suffix": "\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/109/L8",
    "prompt": "\ndef move_one_ball(arr):\n    \"\"\"-\"\"\"\n    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n",
    "canonical_solution": "return True",
    "prefix": "\ndef move_one_ball(arr):\n    \"\"\"-\"\"\"\n    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/109/L8",
    "prompt": "\ndef move_one_ball(arr):\n    \"\"\"-\"\"\"\n    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n",
    "canonical_solution": "return False",
    "prefix": "\ndef move_one_ball(arr):\n    \"\"\"-\"\"\"\n    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n\n      if my_arr[i]!=sorted_array[i]:\n        ",
    "suffix": "\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/109/L8",
    "prompt": "\ndef move_one_ball(arr):\n    \"\"\"-\"\"\"\n    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n",
    "canonical_solution": "if my_arr[i]!=sorted_array[i]:",
    "prefix": "\ndef move_one_ball(arr):\n    \"\"\"-\"\"\"\n    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n\n      ",
    "suffix": "\n        return False\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/107/L11",
    "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"-\"\"\"\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n",
    "canonical_solution": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/138/L0",
    "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\ndef is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    Example\n    is_equal_to_sum_even(4) == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8) == True\n    \"\"\"\n\n    return n%2 == 0 and n >= 8\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/62/L0",
    "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\n\ndef derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n\n    return [(i * x) for i, x in enumerate(xs)][1:]\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/126/L3",
    "prompt": "\ndef is_sorted(lst):\n    '''-'''\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n",
    "canonical_solution": "return False",
    "prefix": "\ndef is_sorted(lst):\n    '''-'''\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n\n        ",
    "suffix": "\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/126/L3",
    "prompt": "\ndef is_sorted(lst):\n    '''-'''\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n",
    "canonical_solution": "else:",
    "prefix": "\ndef is_sorted(lst):\n    '''-'''\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    ",
    "suffix": "\n        return False\n    \n    \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/126/L3",
    "prompt": "\ndef is_sorted(lst):\n    '''-'''\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n",
    "canonical_solution": "return False",
    "prefix": "\ndef is_sorted(lst):\n    '''-'''\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        ",
    "suffix": "\n    \n    \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/126/L3",
    "prompt": "\ndef is_sorted(lst):\n    '''-'''\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n",
    "canonical_solution": "if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):",
    "prefix": "\ndef is_sorted(lst):\n    '''-'''\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n\n        return False\n    ",
    "suffix": "\n        return True\n    else:\n        return False\n    \n    \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/126/L3",
    "prompt": "\ndef is_sorted(lst):\n    '''-'''\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n",
    "canonical_solution": "return True",
    "prefix": "\ndef is_sorted(lst):\n    '''-'''\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        ",
    "suffix": "\n    else:\n        return False\n    \n    \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/161/L10",
    "prompt": "\ndef solve(s):\n    \"\"\"-\"\"\"\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n",
    "canonical_solution": "return s",
    "prefix": "\ndef solve(s):\n    \"\"\"-\"\"\"\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n\n    if flg == 0:\n        return s[len(s)::-1]\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/161/L10",
    "prompt": "\ndef solve(s):\n    \"\"\"-\"\"\"\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n",
    "canonical_solution": "return s[len(s)::-1]",
    "prefix": "\ndef solve(s):\n    \"\"\"-\"\"\"\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n\n    if flg == 0:\n        ",
    "suffix": "\n    return s\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/161/L10",
    "prompt": "\ndef solve(s):\n    \"\"\"-\"\"\"\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n",
    "canonical_solution": "if flg == 0:",
    "prefix": "\ndef solve(s):\n    \"\"\"-\"\"\"\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n\n    ",
    "suffix": "\n        return s[len(s)::-1]\n    return s\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/130/L8",
    "prompt": "\ndef tri(n):\n    \"\"\"-\"\"\"\n    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n",
    "canonical_solution": "\ndef tri(n):\n    \"\"\"Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"\n    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/36/L7",
    "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"-\"\"\"\n    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n",
    "canonical_solution": "return ans",
    "prefix": "\n\ndef fizz_buzz(n: int):\n    \"\"\"-\"\"\"\n    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/29/L0",
    "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n\n    return [x for x in strings if x.startswith(prefix)]\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/84/L0",
    "prompt": "\ndef solve(N):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\ndef solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n\n    return bin(sum(int(i) for i in str(N)))[2:]\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/129/L25",
    "prompt": "\ndef minPath(grid, k):\n    \"\"\"-\"\"\"\n    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n",
    "canonical_solution": "return ans",
    "prefix": "\ndef minPath(grid, k):\n    \"\"\"-\"\"\"\n    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/98/L1",
    "prompt": "\ndef count_upper(s):\n    \"\"\"-\"\"\"\n    count = 0\n",
    "canonical_solution": "if s[i] in \"AEIOU\":",
    "prefix": "\ndef count_upper(s):\n    \"\"\"-\"\"\"\n    count = 0\n    for i in range(0,len(s),2):\n\n        ",
    "suffix": "\n            count += 1\n    return count\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/98/L1",
    "prompt": "\ndef count_upper(s):\n    \"\"\"-\"\"\"\n    count = 0\n",
    "canonical_solution": "return count",
    "prefix": "\ndef count_upper(s):\n    \"\"\"-\"\"\"\n    count = 0\n    for i in range(0,len(s),2):\n\n        if s[i] in \"AEIOU\":\n            count += 1\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/98/L1",
    "prompt": "\ndef count_upper(s):\n    \"\"\"-\"\"\"\n    count = 0\n",
    "canonical_solution": "count += 1",
    "prefix": "\ndef count_upper(s):\n    \"\"\"-\"\"\"\n    count = 0\n    for i in range(0,len(s),2):\n\n        if s[i] in \"AEIOU\":\n            ",
    "suffix": "\n    return count\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/120/L1",
    "prompt": "\ndef maximum(arr, k):\n    \"\"\"-\"\"\"\n    if k == 0:\n",
    "canonical_solution": "return ans",
    "prefix": "\ndef maximum(arr, k):\n    \"\"\"-\"\"\"\n    if k == 0:\n        return []\n\n    arr.sort()\n    ans = arr[-k:]\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/120/L1",
    "prompt": "\ndef maximum(arr, k):\n    \"\"\"-\"\"\"\n    if k == 0:\n",
    "canonical_solution": "arr.sort()",
    "prefix": "\ndef maximum(arr, k):\n    \"\"\"-\"\"\"\n    if k == 0:\n        return []\n\n    ",
    "suffix": "\n    ans = arr[-k:]\n    return ans\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/120/L1",
    "prompt": "\ndef maximum(arr, k):\n    \"\"\"-\"\"\"\n    if k == 0:\n",
    "canonical_solution": "ans = arr[-k:]",
    "prefix": "\ndef maximum(arr, k):\n    \"\"\"-\"\"\"\n    if k == 0:\n        return []\n\n    arr.sort()\n    ",
    "suffix": "\n    return ans\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/24/L0",
    "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return i",
    "prefix": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"-\"\"\"\n\n    for i in reversed(range(n)):\n\n        if n % i == 0:\n            ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/24/L0",
    "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if n % i == 0:",
    "prefix": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"-\"\"\"\n\n    for i in reversed(range(n)):\n\n        ",
    "suffix": "\n            return i\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/88/L0",
    "prompt": "\ndef sort_array(array):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\ndef sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/106/L5",
    "prompt": "\ndef f(n):\n    \"\"\"-\"\"\"\n    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n",
    "canonical_solution": "for j in range(1,i+1): x += j",
    "prefix": "\ndef f(n):\n    \"\"\"-\"\"\"\n    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n\n        else:\n            x = 0\n            ",
    "suffix": "\n            ret += [x]\n    return ret\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/106/L5",
    "prompt": "\ndef f(n):\n    \"\"\"-\"\"\"\n    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n",
    "canonical_solution": "return ret",
    "prefix": "\ndef f(n):\n    \"\"\"-\"\"\"\n    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/106/L5",
    "prompt": "\ndef f(n):\n    \"\"\"-\"\"\"\n    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n",
    "canonical_solution": "else:",
    "prefix": "\ndef f(n):\n    \"\"\"-\"\"\"\n    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n\n        ",
    "suffix": "\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/106/L5",
    "prompt": "\ndef f(n):\n    \"\"\"-\"\"\"\n    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n",
    "canonical_solution": "ret += [x]",
    "prefix": "\ndef f(n):\n    \"\"\"-\"\"\"\n    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ",
    "suffix": "\n    return ret\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/106/L5",
    "prompt": "\ndef f(n):\n    \"\"\"-\"\"\"\n    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n",
    "canonical_solution": "x = 0",
    "prefix": "\ndef f(n):\n    \"\"\"-\"\"\"\n    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n\n        else:\n            ",
    "suffix": "\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/77/L0",
    "prompt": "\ndef iscube(a):\n    '''-'''\n\n",
    "canonical_solution": "return int(round(a ** (1. / 3))) ** 3 == a",
    "prefix": "\ndef iscube(a):\n    '''-'''\n\n    a = abs(a)\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/93/L3",
    "prompt": "\ndef encode(message):\n    \"\"\"-\"\"\"\n    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n",
    "canonical_solution": "\ndef encode(message):\n    \"\"\"\n    Write a function that takes a message, and encodes in such a \n    way that it swaps case of all letters, replaces all vowels in \n    the message with the letter that appears 2 places ahead of that \n    vowel in the english alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/91/L2",
    "prompt": "\ndef is_bored(S):\n    \"\"\"-\"\"\"\n    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n",
    "canonical_solution": "\ndef is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/43/L3",
    "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"-\"\"\"\n    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n",
    "canonical_solution": "return False",
    "prefix": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"-\"\"\"\n    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/71/L0",
    "prompt": "\ndef triangle_area(a, b, c):\n    '''-'''\n\n",
    "canonical_solution": "return -1 ",
    "prefix": "\ndef triangle_area(a, b, c):\n    '''-'''\n\n    if a + b <= c or a + c <= b or b + c <= a:\n\n        ",
    "suffix": "\n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/71/L0",
    "prompt": "\ndef triangle_area(a, b, c):\n    '''-'''\n\n",
    "canonical_solution": "return area",
    "prefix": "\ndef triangle_area(a, b, c):\n    '''-'''\n\n    if a + b <= c or a + c <= b or b + c <= a:\n\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/71/L0",
    "prompt": "\ndef triangle_area(a, b, c):\n    '''-'''\n\n",
    "canonical_solution": "area = (s * (s - a) * (s - b) * (s - c)) ** 0.5",
    "prefix": "\ndef triangle_area(a, b, c):\n    '''-'''\n\n    if a + b <= c or a + c <= b or b + c <= a:\n\n        return -1 \n    s = (a + b + c)/2    \n    ",
    "suffix": "\n    area = round(area, 2)\n    return area\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/71/L0",
    "prompt": "\ndef triangle_area(a, b, c):\n    '''-'''\n\n",
    "canonical_solution": "s = (a + b + c)/2    ",
    "prefix": "\ndef triangle_area(a, b, c):\n    '''-'''\n\n    if a + b <= c or a + c <= b or b + c <= a:\n\n        return -1 \n    ",
    "suffix": "\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/71/L0",
    "prompt": "\ndef triangle_area(a, b, c):\n    '''-'''\n\n",
    "canonical_solution": "area = round(area, 2)",
    "prefix": "\ndef triangle_area(a, b, c):\n    '''-'''\n\n    if a + b <= c or a + c <= b or b + c <= a:\n\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    ",
    "suffix": "\n    return area\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/148/L1",
    "prompt": "\ndef bf(planet1, planet2):\n    '''-'''\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n",
    "canonical_solution": "else:",
    "prefix": "\ndef bf(planet1, planet2):\n    '''-'''\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    ",
    "suffix": "\n        return (planet_names[planet2_index + 1 : planet1_index])\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/148/L1",
    "prompt": "\ndef bf(planet1, planet2):\n    '''-'''\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n",
    "canonical_solution": "return (planet_names[planet2_index + 1 : planet1_index])",
    "prefix": "\ndef bf(planet1, planet2):\n    '''-'''\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/148/L1",
    "prompt": "\ndef bf(planet1, planet2):\n    '''-'''\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n",
    "canonical_solution": "return (planet_names[planet1_index + 1: planet2_index])",
    "prefix": "\ndef bf(planet1, planet2):\n    '''-'''\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        ",
    "suffix": "\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/148/L1",
    "prompt": "\ndef bf(planet1, planet2):\n    '''-'''\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n",
    "canonical_solution": "planet2_index = planet_names.index(planet2)",
    "prefix": "\ndef bf(planet1, planet2):\n    '''-'''\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n\n        return ()\n    planet1_index = planet_names.index(planet1)\n    ",
    "suffix": "\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/148/L1",
    "prompt": "\ndef bf(planet1, planet2):\n    '''-'''\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n",
    "canonical_solution": "if planet1_index < planet2_index:",
    "prefix": "\ndef bf(planet1, planet2):\n    '''-'''\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    ",
    "suffix": "\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/148/L1",
    "prompt": "\ndef bf(planet1, planet2):\n    '''-'''\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n",
    "canonical_solution": "return ()",
    "prefix": "\ndef bf(planet1, planet2):\n    '''-'''\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n\n        ",
    "suffix": "\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/148/L1",
    "prompt": "\ndef bf(planet1, planet2):\n    '''-'''\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n",
    "canonical_solution": "planet1_index = planet_names.index(planet1)",
    "prefix": "\ndef bf(planet1, planet2):\n    '''-'''\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n\n        return ()\n    ",
    "suffix": "\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/131/L9",
    "prompt": "\ndef digits(n):\n    \"\"\"-\"\"\"\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n",
    "canonical_solution": "return product",
    "prefix": "\ndef digits(n):\n    \"\"\"-\"\"\"\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n\n        ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/101/L9",
    "prompt": "\ndef words_string(s):\n    \"\"\"-\"\"\"\n    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n",
    "canonical_solution": "s_list = \"\".join(s_list)",
    "prefix": "\ndef words_string(s):\n    \"\"\"-\"\"\"\n    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n\n    ",
    "suffix": "\n    return s_list.split()\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/101/L9",
    "prompt": "\ndef words_string(s):\n    \"\"\"-\"\"\"\n    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n",
    "canonical_solution": "return s_list.split()",
    "prefix": "\ndef words_string(s):\n    \"\"\"-\"\"\"\n    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n\n    s_list = \"\".join(s_list)\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/18/L6",
    "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"-\"\"\"\n    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n",
    "canonical_solution": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/137/L4",
    "prompt": "\ndef compare_one(a, b):\n    \"\"\"-\"\"\"\n    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n",
    "canonical_solution": "\ndef compare_one(a, b):\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_one(1, 2.5) \u279e 2.5\n    compare_one(1, \"2,3\") \u279e \"2,3\"\n    compare_one(\"5,1\", \"6\") \u279e \"6\"\n    compare_one(\"1\", 1) \u279e None\n    \"\"\"\n    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/51/L0",
    "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n\n    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/70/L3",
    "prompt": "\ndef strange_sort_list(lst):\n    '''-'''\n    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n",
    "canonical_solution": "return res",
    "prefix": "\ndef strange_sort_list(lst):\n    '''-'''\n    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n\n        switch = not switch\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/70/L3",
    "prompt": "\ndef strange_sort_list(lst):\n    '''-'''\n    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n",
    "canonical_solution": "switch = not switch",
    "prefix": "\ndef strange_sort_list(lst):\n    '''-'''\n    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n\n        ",
    "suffix": "\n    return res\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/20/L13",
    "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"-\"\"\"\n    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n",
    "canonical_solution": "return closest_pair",
    "prefix": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"-\"\"\"\n    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/76/L2",
    "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"-\"\"\"\n    if (n == 1): \n        return (x == 1) \n",
    "canonical_solution": "power = power * n ",
    "prefix": "\ndef is_simple_power(x, n):\n    \"\"\"-\"\"\"\n    if (n == 1): \n        return (x == 1) \n    power = 1\n\n    while (power < x): \n        ",
    "suffix": "\n    return (power == x) \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/76/L2",
    "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"-\"\"\"\n    if (n == 1): \n        return (x == 1) \n",
    "canonical_solution": "while (power < x): ",
    "prefix": "\ndef is_simple_power(x, n):\n    \"\"\"-\"\"\"\n    if (n == 1): \n        return (x == 1) \n    power = 1\n\n    ",
    "suffix": "\n        power = power * n \n    return (power == x) \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/76/L2",
    "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"-\"\"\"\n    if (n == 1): \n        return (x == 1) \n",
    "canonical_solution": "return (power == x) ",
    "prefix": "\ndef is_simple_power(x, n):\n    \"\"\"-\"\"\"\n    if (n == 1): \n        return (x == 1) \n    power = 1\n\n    while (power < x): \n        power = power * n \n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/39/L0",
    "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "f.append(f[-1] + f[-2])",
    "prefix": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n    import math\n\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        ",
    "suffix": "\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/39/L0",
    "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):",
    "prefix": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n    import math\n\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        ",
    "suffix": "\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/39/L0",
    "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if n == 0:",
    "prefix": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n    import math\n\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        ",
    "suffix": "\n            return f[-1]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/39/L0",
    "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if p % k == 0:",
    "prefix": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n    import math\n\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            ",
    "suffix": "\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/39/L0",
    "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return f[-1]",
    "prefix": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n    import math\n\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/39/L0",
    "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "def is_prime(p):",
    "prefix": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n    import math\n\n\n    ",
    "suffix": "\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/39/L0",
    "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "n -= 1",
    "prefix": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n    import math\n\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            ",
    "suffix": "\n        if n == 0:\n            return f[-1]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/39/L0",
    "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if p < 2:",
    "prefix": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n    import math\n\n\n    def is_prime(p):\n        ",
    "suffix": "\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/39/L0",
    "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "while True:",
    "prefix": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n    import math\n\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    ",
    "suffix": "\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/39/L0",
    "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "f = [0, 1]",
    "prefix": "\n\ndef prime_fib(n: int):\n    \"\"\"-\"\"\"\n\n    import math\n\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    ",
    "suffix": "\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/145/L0",
    "prompt": "\ndef order_by_points(nums):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "n = [int(i) for i in str(n)]",
    "prefix": "\ndef order_by_points(nums):\n    \"\"\"-\"\"\"\n\n    def digits_sum(n):\n\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        ",
    "suffix": "\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/145/L0",
    "prompt": "\ndef order_by_points(nums):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "n[0] = n[0] * neg",
    "prefix": "\ndef order_by_points(nums):\n    \"\"\"-\"\"\"\n\n    def digits_sum(n):\n\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        ",
    "suffix": "\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/145/L0",
    "prompt": "\ndef order_by_points(nums):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return sum(n)",
    "prefix": "\ndef order_by_points(nums):\n    \"\"\"-\"\"\"\n\n    def digits_sum(n):\n\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        ",
    "suffix": "\n    return sorted(nums, key=digits_sum)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/145/L0",
    "prompt": "\ndef order_by_points(nums):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if n < 0: n, neg = -1 * n, -1 ",
    "prefix": "\ndef order_by_points(nums):\n    \"\"\"-\"\"\"\n\n    def digits_sum(n):\n\n        neg = 1\n        ",
    "suffix": "\n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/145/L0",
    "prompt": "\ndef order_by_points(nums):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "neg = 1",
    "prefix": "\ndef order_by_points(nums):\n    \"\"\"-\"\"\"\n\n    def digits_sum(n):\n\n        ",
    "suffix": "\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/145/L0",
    "prompt": "\ndef order_by_points(nums):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return sorted(nums, key=digits_sum)",
    "prefix": "\ndef order_by_points(nums):\n    \"\"\"-\"\"\"\n\n    def digits_sum(n):\n\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/0/L7",
    "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"-\"\"\"\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n",
    "canonical_solution": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/10/L6",
    "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"-\"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"-\"\"\"\n    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n",
    "canonical_solution": "return string + string[:beginning_of_suffix][::-1]",
    "prefix": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"-\"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"-\"\"\"\n    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/11/L1",
    "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"-\"\"\"\n    def xor(i, j):\n",
    "canonical_solution": "return ''.join(xor(x, y) for x, y in zip(a, b))",
    "prefix": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"-\"\"\"\n    def xor(i, j):\n        if i == j:\n\n            return '0'\n        else:\n            return '1'\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/11/L1",
    "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"-\"\"\"\n    def xor(i, j):\n",
    "canonical_solution": "return '0'",
    "prefix": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"-\"\"\"\n    def xor(i, j):\n        if i == j:\n\n            ",
    "suffix": "\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/11/L1",
    "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"-\"\"\"\n    def xor(i, j):\n",
    "canonical_solution": "else:",
    "prefix": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"-\"\"\"\n    def xor(i, j):\n        if i == j:\n\n            return '0'\n        ",
    "suffix": "\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/11/L1",
    "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"-\"\"\"\n    def xor(i, j):\n",
    "canonical_solution": "return '1'",
    "prefix": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"-\"\"\"\n    def xor(i, j):\n        if i == j:\n\n            return '0'\n        else:\n            ",
    "suffix": "\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/139/L3",
    "prompt": "\ndef special_factorial(n):\n    \"\"\"-\"\"\"\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n",
    "canonical_solution": "special_fact *= fact_i",
    "prefix": "\ndef special_factorial(n):\n    \"\"\"-\"\"\"\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n\n        ",
    "suffix": "\n    return special_fact\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/139/L3",
    "prompt": "\ndef special_factorial(n):\n    \"\"\"-\"\"\"\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n",
    "canonical_solution": "return special_fact",
    "prefix": "\ndef special_factorial(n):\n    \"\"\"-\"\"\"\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n\n        special_fact *= fact_i\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/122/L0",
    "prompt": "\ndef add_elements(arr, k):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\ndef add_elements(arr, k):\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"\n\n    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/46/L8",
    "prompt": "\n\ndef fib4(n: int):\n    \"\"\"-\"\"\"\n    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n",
    "canonical_solution": "\n\ndef fib4(n: int):\n    \"\"\"The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/104/L2",
    "prompt": "\ndef unique_digits(x):\n    \"\"\"-\"\"\"\n    odd_digit_elements = []\n    for i in x:\n",
    "canonical_solution": "return sorted(odd_digit_elements)",
    "prefix": "\ndef unique_digits(x):\n    \"\"\"-\"\"\"\n    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n\n            odd_digit_elements.append(i)\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/104/L2",
    "prompt": "\ndef unique_digits(x):\n    \"\"\"-\"\"\"\n    odd_digit_elements = []\n    for i in x:\n",
    "canonical_solution": "odd_digit_elements.append(i)",
    "prefix": "\ndef unique_digits(x):\n    \"\"\"-\"\"\"\n    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n\n            ",
    "suffix": "\n    return sorted(odd_digit_elements)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/117/L1",
    "prompt": "\ndef select_words(s, n):\n    \"\"\"-\"\"\"\n    result = []\n",
    "canonical_solution": "n_consonants += 1 ",
    "prefix": "\ndef select_words(s, n):\n    \"\"\"-\"\"\"\n    result = []\n    for word in s.split():\n\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                ",
    "suffix": "\n        if n_consonants == n:\n            result.append(word)\n    return result\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/117/L1",
    "prompt": "\ndef select_words(s, n):\n    \"\"\"-\"\"\"\n    result = []\n",
    "canonical_solution": "return result",
    "prefix": "\ndef select_words(s, n):\n    \"\"\"-\"\"\"\n    result = []\n    for word in s.split():\n\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    ",
    "suffix": "\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/117/L1",
    "prompt": "\ndef select_words(s, n):\n    \"\"\"-\"\"\"\n    result = []\n",
    "canonical_solution": "n_consonants = 0",
    "prefix": "\ndef select_words(s, n):\n    \"\"\"-\"\"\"\n    result = []\n    for word in s.split():\n\n        ",
    "suffix": "\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/117/L1",
    "prompt": "\ndef select_words(s, n):\n    \"\"\"-\"\"\"\n    result = []\n",
    "canonical_solution": "if n_consonants == n:",
    "prefix": "\ndef select_words(s, n):\n    \"\"\"-\"\"\"\n    result = []\n    for word in s.split():\n\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        ",
    "suffix": "\n            result.append(word)\n    return result\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/117/L1",
    "prompt": "\ndef select_words(s, n):\n    \"\"\"-\"\"\"\n    result = []\n",
    "canonical_solution": "if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:",
    "prefix": "\ndef select_words(s, n):\n    \"\"\"-\"\"\"\n    result = []\n    for word in s.split():\n\n        n_consonants = 0\n        for i in range(0, len(word)):\n            ",
    "suffix": "\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/117/L1",
    "prompt": "\ndef select_words(s, n):\n    \"\"\"-\"\"\"\n    result = []\n",
    "canonical_solution": "for i in range(0, len(word)):",
    "prefix": "\ndef select_words(s, n):\n    \"\"\"-\"\"\"\n    result = []\n    for word in s.split():\n\n        n_consonants = 0\n        ",
    "suffix": "\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/117/L1",
    "prompt": "\ndef select_words(s, n):\n    \"\"\"-\"\"\"\n    result = []\n",
    "canonical_solution": "result.append(word)",
    "prefix": "\ndef select_words(s, n):\n    \"\"\"-\"\"\"\n    result = []\n    for word in s.split():\n\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            ",
    "suffix": "\n    return result\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/72/L7",
    "prompt": "\ndef will_it_fly(q,w):\n    '''-'''\n    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n",
    "canonical_solution": "j-=1",
    "prefix": "\ndef will_it_fly(q,w):\n    '''-'''\n    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n\n        ",
    "suffix": "\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/72/L7",
    "prompt": "\ndef will_it_fly(q,w):\n    '''-'''\n    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n",
    "canonical_solution": "return True",
    "prefix": "\ndef will_it_fly(q,w):\n    '''-'''\n    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n\n        j-=1\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/55/L4",
    "prompt": "\n\ndef fib(n: int):\n    \"\"\"-\"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n",
    "canonical_solution": "\n\ndef fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/153/L9",
    "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"-\"\"\"\n    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n",
    "canonical_solution": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n    For example, if you are given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/119/L5",
    "prompt": "\ndef match_parens(lst):\n    '''-'''\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n",
    "canonical_solution": "if val < 0:",
    "prefix": "\ndef match_parens(lst):\n    '''-'''\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n\n                val = val - 1\n            ",
    "suffix": "\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/119/L5",
    "prompt": "\ndef match_parens(lst):\n    '''-'''\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n",
    "canonical_solution": "S1 = lst[0] + lst[1]",
    "prefix": "\ndef match_parens(lst):\n    '''-'''\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    ",
    "suffix": "\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/119/L5",
    "prompt": "\ndef match_parens(lst):\n    '''-'''\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n",
    "canonical_solution": "S2 = lst[1] + lst[0]",
    "prefix": "\ndef match_parens(lst):\n    '''-'''\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    ",
    "suffix": "\n    return 'Yes' if check(S1) or check(S2) else 'No'\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/119/L5",
    "prompt": "\ndef match_parens(lst):\n    '''-'''\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n",
    "canonical_solution": "return True if val == 0 else False",
    "prefix": "\ndef match_parens(lst):\n    '''-'''\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n\n                val = val - 1\n            if val < 0:\n                return False\n        ",
    "suffix": "\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/119/L5",
    "prompt": "\ndef match_parens(lst):\n    '''-'''\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n",
    "canonical_solution": "return 'Yes' if check(S1) or check(S2) else 'No'",
    "prefix": "\ndef match_parens(lst):\n    '''-'''\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/119/L5",
    "prompt": "\ndef match_parens(lst):\n    '''-'''\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n",
    "canonical_solution": "val = val - 1",
    "prefix": "\ndef match_parens(lst):\n    '''-'''\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n\n                ",
    "suffix": "\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/119/L5",
    "prompt": "\ndef match_parens(lst):\n    '''-'''\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n",
    "canonical_solution": "return False",
    "prefix": "\ndef match_parens(lst):\n    '''-'''\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n\n                val = val - 1\n            if val < 0:\n                ",
    "suffix": "\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/90/L0",
    "prompt": "\ndef next_smallest(lst):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return None if len(lst) < 2 else lst[1]",
    "prefix": "\ndef next_smallest(lst):\n    \"\"\"-\"\"\"\n\n    lst = sorted(set(lst))\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/92/L5",
    "prompt": "\ndef any_int(x, y, z):\n    '''-'''\n    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n",
    "canonical_solution": "\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u279e True\n    \n    any_int(3, 2, 2) \u279e False\n\n    any_int(3, -2, 1) \u279e True\n    \n    any_int(3.6, -2.2, 2) \u279e False\n  \n\n    \n    '''\n    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/2/L0",
    "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n\n    return number % 1.0\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/42/L0",
    "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\n\ndef incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n\n    return [(e + 1) for e in l]\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/150/L3",
    "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"-\"\"\"\n    if n == 1:\n        return y\n    for i in range(2, n):\n",
    "canonical_solution": "return y",
    "prefix": "\ndef x_or_y(n, x, y):\n    \"\"\"-\"\"\"\n    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n\n            ",
    "suffix": "\n            break\n    else:\n        return x\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/150/L3",
    "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"-\"\"\"\n    if n == 1:\n        return y\n    for i in range(2, n):\n",
    "canonical_solution": "else:",
    "prefix": "\ndef x_or_y(n, x, y):\n    \"\"\"-\"\"\"\n    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n\n            return y\n            break\n    ",
    "suffix": "\n        return x\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/150/L3",
    "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"-\"\"\"\n    if n == 1:\n        return y\n    for i in range(2, n):\n",
    "canonical_solution": "return x",
    "prefix": "\ndef x_or_y(n, x, y):\n    \"\"\"-\"\"\"\n    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n\n            return y\n            break\n    else:\n        ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/150/L3",
    "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"-\"\"\"\n    if n == 1:\n        return y\n    for i in range(2, n):\n",
    "canonical_solution": "break",
    "prefix": "\ndef x_or_y(n, x, y):\n    \"\"\"-\"\"\"\n    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n\n            return y\n            ",
    "suffix": "\n    else:\n        return x\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/49/L2",
    "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"-\"\"\"\n    ret = 1\n    for i in range(n):\n",
    "canonical_solution": "return ret",
    "prefix": "\n\ndef modp(n: int, p: int):\n    \"\"\"-\"\"\"\n    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/155/L1",
    "prompt": "\ndef even_odd_count(num):\n    \"\"\"-\"\"\"\n    even_count = 0\n",
    "canonical_solution": "return (even_count, odd_count)",
    "prefix": "\ndef even_odd_count(num):\n    \"\"\"-\"\"\"\n    even_count = 0\n    odd_count = 0\n\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/155/L1",
    "prompt": "\ndef even_odd_count(num):\n    \"\"\"-\"\"\"\n    even_count = 0\n",
    "canonical_solution": "odd_count +=1",
    "prefix": "\ndef even_odd_count(num):\n    \"\"\"-\"\"\"\n    even_count = 0\n    odd_count = 0\n\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            ",
    "suffix": "\n    return (even_count, odd_count)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/155/L1",
    "prompt": "\ndef even_odd_count(num):\n    \"\"\"-\"\"\"\n    even_count = 0\n",
    "canonical_solution": "even_count +=1",
    "prefix": "\ndef even_odd_count(num):\n    \"\"\"-\"\"\"\n    even_count = 0\n    odd_count = 0\n\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            ",
    "suffix": "\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/155/L1",
    "prompt": "\ndef even_odd_count(num):\n    \"\"\"-\"\"\"\n    even_count = 0\n",
    "canonical_solution": "else:",
    "prefix": "\ndef even_odd_count(num):\n    \"\"\"-\"\"\"\n    even_count = 0\n    odd_count = 0\n\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        ",
    "suffix": "\n            odd_count +=1\n    return (even_count, odd_count)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/155/L1",
    "prompt": "\ndef even_odd_count(num):\n    \"\"\"-\"\"\"\n    even_count = 0\n",
    "canonical_solution": "if int(i)%2==0:",
    "prefix": "\ndef even_odd_count(num):\n    \"\"\"-\"\"\"\n    even_count = 0\n    odd_count = 0\n\n    for i in str(abs(num)):\n        ",
    "suffix": "\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/155/L1",
    "prompt": "\ndef even_odd_count(num):\n    \"\"\"-\"\"\"\n    even_count = 0\n",
    "canonical_solution": "for i in str(abs(num)):",
    "prefix": "\ndef even_odd_count(num):\n    \"\"\"-\"\"\"\n    even_count = 0\n    odd_count = 0\n\n    ",
    "suffix": "\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/80/L0",
    "prompt": "\ndef is_happy(s):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "for i in range(len(s) - 2):",
    "prefix": "\ndef is_happy(s):\n    \"\"\"-\"\"\"\n\n    if len(s) < 3:\n\n      return False\n\n    ",
    "suffix": "\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/80/L0",
    "prompt": "\ndef is_happy(s):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return True",
    "prefix": "\ndef is_happy(s):\n    \"\"\"-\"\"\"\n\n    if len(s) < 3:\n\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/80/L0",
    "prompt": "\ndef is_happy(s):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:",
    "prefix": "\ndef is_happy(s):\n    \"\"\"-\"\"\"\n\n    if len(s) < 3:\n\n      return False\n\n    for i in range(len(s) - 2):\n      \n      ",
    "suffix": "\n        return False\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/80/L0",
    "prompt": "\ndef is_happy(s):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return False",
    "prefix": "\ndef is_happy(s):\n    \"\"\"-\"\"\"\n\n    if len(s) < 3:\n\n      ",
    "suffix": "\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/80/L0",
    "prompt": "\ndef is_happy(s):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return False",
    "prefix": "\ndef is_happy(s):\n    \"\"\"-\"\"\"\n\n    if len(s) < 3:\n\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        ",
    "suffix": "\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/59/L5",
    "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"-\"\"\"\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n",
    "canonical_solution": "largest = max(largest, j)",
    "prefix": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"-\"\"\"\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            ",
    "suffix": "\n    return largest\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/59/L5",
    "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"-\"\"\"\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n",
    "canonical_solution": "largest = 1",
    "prefix": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"-\"\"\"\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n\n        return True\n    ",
    "suffix": "\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/59/L5",
    "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"-\"\"\"\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n",
    "canonical_solution": "return largest",
    "prefix": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"-\"\"\"\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/59/L5",
    "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"-\"\"\"\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n",
    "canonical_solution": "for j in range(2, n + 1):",
    "prefix": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"-\"\"\"\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n\n        return True\n    largest = 1\n    ",
    "suffix": "\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/59/L5",
    "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"-\"\"\"\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n",
    "canonical_solution": "if n % j == 0 and is_prime(j):",
    "prefix": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"-\"\"\"\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        ",
    "suffix": "\n            largest = max(largest, j)\n    return largest\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/59/L5",
    "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"-\"\"\"\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n",
    "canonical_solution": "return True",
    "prefix": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"-\"\"\"\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n\n        ",
    "suffix": "\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/66/L1",
    "prompt": "\ndef digitSum(s):\n    \"\"\"-\"\"\"\n    if s == \"\": return 0\n",
    "canonical_solution": "\ndef digitSum(s):\n    \"\"\"Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/21/L2",
    "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"-\"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n",
    "canonical_solution": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/121/L0",
    "prompt": "\ndef solution(lst):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\ndef solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n\n    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/68/L1",
    "prompt": "\ndef pluck(arr):\n    \"\"\"-\"\"\"\n    if(len(arr) == 0): return []\n",
    "canonical_solution": "return [min(evens), arr.index(min(evens))]",
    "prefix": "\ndef pluck(arr):\n    \"\"\"-\"\"\"\n    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n\n    if(evens == []): return []\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/68/L1",
    "prompt": "\ndef pluck(arr):\n    \"\"\"-\"\"\"\n    if(len(arr) == 0): return []\n",
    "canonical_solution": "if(evens == []): return []",
    "prefix": "\ndef pluck(arr):\n    \"\"\"-\"\"\"\n    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n\n    ",
    "suffix": "\n    return [min(evens), arr.index(min(evens))]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/147/L2",
    "prompt": "\ndef get_max_triples(n):\n    \"\"\"-\"\"\"\n    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n",
    "canonical_solution": "return len(ans)",
    "prefix": "\ndef get_max_triples(n):\n    \"\"\"-\"\"\"\n    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/147/L2",
    "prompt": "\ndef get_max_triples(n):\n    \"\"\"-\"\"\"\n    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n",
    "canonical_solution": "ans += [(A[i],A[j],A[k])]",
    "prefix": "\ndef get_max_triples(n):\n    \"\"\"-\"\"\"\n    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ",
    "suffix": "\n    return len(ans)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/147/L2",
    "prompt": "\ndef get_max_triples(n):\n    \"\"\"-\"\"\"\n    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n",
    "canonical_solution": "for k in range(j+1,n):",
    "prefix": "\ndef get_max_triples(n):\n    \"\"\"-\"\"\"\n    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n\n        for j in range(i+1,n):\n            ",
    "suffix": "\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/147/L2",
    "prompt": "\ndef get_max_triples(n):\n    \"\"\"-\"\"\"\n    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n",
    "canonical_solution": "for j in range(i+1,n):",
    "prefix": "\ndef get_max_triples(n):\n    \"\"\"-\"\"\"\n    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n\n        ",
    "suffix": "\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/147/L2",
    "prompt": "\ndef get_max_triples(n):\n    \"\"\"-\"\"\"\n    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n",
    "canonical_solution": "if (A[i]+A[j]+A[k])%3 == 0:",
    "prefix": "\ndef get_max_triples(n):\n    \"\"\"-\"\"\"\n    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                ",
    "suffix": "\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/110/L9",
    "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"-\"\"\"\n    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n",
    "canonical_solution": "return \"NO\"",
    "prefix": "\ndef exchange(lst1, lst2):\n    \"\"\"-\"\"\"\n    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n\n    ",
    "suffix": "\n            \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/47/L2",
    "prompt": "\n\ndef median(l: list):\n    \"\"\"-\"\"\"\n    l = sorted(l)\n    if len(l) % 2 == 1:\n",
    "canonical_solution": "else:",
    "prefix": "\n\ndef median(l: list):\n    \"\"\"-\"\"\"\n    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n\n    ",
    "suffix": "\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/47/L2",
    "prompt": "\n\ndef median(l: list):\n    \"\"\"-\"\"\"\n    l = sorted(l)\n    if len(l) % 2 == 1:\n",
    "canonical_solution": "return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0",
    "prefix": "\n\ndef median(l: list):\n    \"\"\"-\"\"\"\n    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n\n    else:\n        ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/82/L5",
    "prompt": "\ndef prime_length(string):\n    \"\"\"-\"\"\"\n    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n",
    "canonical_solution": "return True",
    "prefix": "\ndef prime_length(string):\n    \"\"\"-\"\"\"\n    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/73/L2",
    "prompt": "\ndef smallest_change(arr):\n    \"\"\"-\"\"\"\n    ans = 0\n    for i in range(len(arr) // 2):\n",
    "canonical_solution": "return ans",
    "prefix": "\ndef smallest_change(arr):\n    \"\"\"-\"\"\"\n    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n\n            ans += 1\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/73/L2",
    "prompt": "\ndef smallest_change(arr):\n    \"\"\"-\"\"\"\n    ans = 0\n    for i in range(len(arr) // 2):\n",
    "canonical_solution": "ans += 1",
    "prefix": "\ndef smallest_change(arr):\n    \"\"\"-\"\"\"\n    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n\n            ",
    "suffix": "\n    return ans\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/133/L0",
    "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "for i in lst:",
    "prefix": "\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n\n    import math\n\n    squared = 0\n    ",
    "suffix": "\n        squared += math.ceil(i)**2\n    return squared\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/133/L0",
    "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "squared += math.ceil(i)**2",
    "prefix": "\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n\n    import math\n\n    squared = 0\n    for i in lst:\n        ",
    "suffix": "\n    return squared\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/133/L0",
    "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return squared",
    "prefix": "\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n\n    import math\n\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/133/L0",
    "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "squared = 0",
    "prefix": "\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n\n    import math\n\n    ",
    "suffix": "\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/141/L5",
    "prompt": "\ndef file_name_check(file_name):\n    \"\"\"-\"\"\"\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n",
    "canonical_solution": "return 'Yes'",
    "prefix": "\ndef file_name_check(file_name):\n    \"\"\"-\"\"\"\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/141/L5",
    "prompt": "\ndef file_name_check(file_name):\n    \"\"\"-\"\"\"\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n",
    "canonical_solution": "if len(lst[0]) == 0:",
    "prefix": "\ndef file_name_check(file_name):\n    \"\"\"-\"\"\"\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n\n    ",
    "suffix": "\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/141/L5",
    "prompt": "\ndef file_name_check(file_name):\n    \"\"\"-\"\"\"\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n",
    "canonical_solution": "t = len([x for x in lst[0] if x.isdigit()])",
    "prefix": "\ndef file_name_check(file_name):\n    \"\"\"-\"\"\"\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    ",
    "suffix": "\n    if t > 3:\n        return 'No'\n    return 'Yes'\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/141/L5",
    "prompt": "\ndef file_name_check(file_name):\n    \"\"\"-\"\"\"\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n",
    "canonical_solution": "return 'No'",
    "prefix": "\ndef file_name_check(file_name):\n    \"\"\"-\"\"\"\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        ",
    "suffix": "\n    return 'Yes'\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/141/L5",
    "prompt": "\ndef file_name_check(file_name):\n    \"\"\"-\"\"\"\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n",
    "canonical_solution": "return 'No'",
    "prefix": "\ndef file_name_check(file_name):\n    \"\"\"-\"\"\"\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n\n    if len(lst[0]) == 0:\n        ",
    "suffix": "\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/141/L5",
    "prompt": "\ndef file_name_check(file_name):\n    \"\"\"-\"\"\"\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n",
    "canonical_solution": "if t > 3:",
    "prefix": "\ndef file_name_check(file_name):\n    \"\"\"-\"\"\"\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    ",
    "suffix": "\n        return 'No'\n    return 'Yes'\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/141/L5",
    "prompt": "\ndef file_name_check(file_name):\n    \"\"\"-\"\"\"\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n",
    "canonical_solution": "return 'No'",
    "prefix": "\ndef file_name_check(file_name):\n    \"\"\"-\"\"\"\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        ",
    "suffix": "\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/141/L5",
    "prompt": "\ndef file_name_check(file_name):\n    \"\"\"-\"\"\"\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n",
    "canonical_solution": "if not lst[0][0].isalpha():",
    "prefix": "\ndef file_name_check(file_name):\n    \"\"\"-\"\"\"\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n\n    if len(lst[0]) == 0:\n        return 'No'\n    ",
    "suffix": "\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/40/L4",
    "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"-\"\"\"\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n",
    "canonical_solution": "return False",
    "prefix": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"-\"\"\"\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/127/L0",
    "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if length > 0 and is_prime(length):",
    "prefix": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n    def is_prime(num):\n\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    ",
    "suffix": "\n        return \"YES\"\n    return \"NO\"\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/127/L0",
    "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return True",
    "prefix": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n    def is_prime(num):\n\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            ",
    "suffix": "\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/127/L0",
    "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "length = r - l",
    "prefix": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n    def is_prime(num):\n\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    ",
    "suffix": "\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/127/L0",
    "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "l = max(interval1[0], interval2[0])",
    "prefix": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n    def is_prime(num):\n\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    ",
    "suffix": "\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/127/L0",
    "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "for i in range(2, num):",
    "prefix": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n    def is_prime(num):\n\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        ",
    "suffix": "\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/127/L0",
    "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return False",
    "prefix": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n    def is_prime(num):\n\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                ",
    "suffix": "\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/127/L0",
    "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if num == 2:",
    "prefix": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n    def is_prime(num):\n\n        if num == 1 or num == 0:\n            return False\n        ",
    "suffix": "\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/127/L0",
    "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "r = min(interval1[1], interval2[1])",
    "prefix": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n    def is_prime(num):\n\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    ",
    "suffix": "\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/127/L0",
    "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return False",
    "prefix": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n    def is_prime(num):\n\n        if num == 1 or num == 0:\n            ",
    "suffix": "\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/127/L0",
    "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if num == 1 or num == 0:",
    "prefix": "\ndef intersection(interval1, interval2):\n    \"\"\"-\"\"\"\n\n    def is_prime(num):\n\n        ",
    "suffix": "\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/1/L7",
    "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"-\"\"\"\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n",
    "canonical_solution": "result.append(''.join(current_string))",
    "prefix": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"-\"\"\"\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                ",
    "suffix": "\n                current_string.clear()\n\n    return result\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/1/L7",
    "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"-\"\"\"\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n",
    "canonical_solution": "current_depth -= 1",
    "prefix": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"-\"\"\"\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n\n        elif c == ')':\n            ",
    "suffix": "\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/1/L7",
    "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"-\"\"\"\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n",
    "canonical_solution": "return result",
    "prefix": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"-\"\"\"\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/1/L7",
    "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"-\"\"\"\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n",
    "canonical_solution": "elif c == ')':",
    "prefix": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"-\"\"\"\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n\n        ",
    "suffix": "\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/1/L7",
    "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"-\"\"\"\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n",
    "canonical_solution": "current_string.clear()",
    "prefix": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"-\"\"\"\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                ",
    "suffix": "\n\n    return result\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/1/L7",
    "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"-\"\"\"\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n",
    "canonical_solution": "current_string.append(c)",
    "prefix": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"-\"\"\"\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n\n        elif c == ')':\n            current_depth -= 1\n            ",
    "suffix": "\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/1/L7",
    "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"-\"\"\"\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n",
    "canonical_solution": "if current_depth == 0:",
    "prefix": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"-\"\"\"\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            ",
    "suffix": "\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/152/L0",
    "prompt": "\ndef compare(game,guess):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\ndef compare(game,guess):\n    \"\"\"I think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    \n    \n    example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    \"\"\"\n\n    return [abs(x-y) for x,y in zip(game,guess)]\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/83/L1",
    "prompt": "\ndef starts_one_ends(n):\n    \"\"\"-\"\"\"\n    if n == 1: return 1\n",
    "canonical_solution": "\ndef starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/134/L1",
    "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''-'''\n \n",
    "canonical_solution": "return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False",
    "prefix": "\ndef check_if_last_char_is_a_letter(txt):\n    '''-'''\n \n    check = txt.split(' ')[-1]\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/124/L1",
    "prompt": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n",
    "canonical_solution": "if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:",
    "prefix": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n        date = date.strip()\n\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        ",
    "suffix": "\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/124/L1",
    "prompt": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n",
    "canonical_solution": "if month == 2 and day < 1 or day > 29:",
    "prefix": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n        date = date.strip()\n\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        ",
    "suffix": "\n            return False\n    except:\n        return False\n\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/124/L1",
    "prompt": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n",
    "canonical_solution": "month, day, year = int(month), int(day), int(year)",
    "prefix": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n        date = date.strip()\n\n        month, day, year = date.split('-')\n        ",
    "suffix": "\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/124/L1",
    "prompt": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n",
    "canonical_solution": "return True",
    "prefix": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n        date = date.strip()\n\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/124/L1",
    "prompt": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n",
    "canonical_solution": "if month < 1 or month > 12:",
    "prefix": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n        date = date.strip()\n\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        ",
    "suffix": "\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/124/L1",
    "prompt": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n",
    "canonical_solution": "return False",
    "prefix": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n        date = date.strip()\n\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            ",
    "suffix": "\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/124/L1",
    "prompt": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n",
    "canonical_solution": "return False",
    "prefix": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n        date = date.strip()\n\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            ",
    "suffix": "\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/124/L1",
    "prompt": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n",
    "canonical_solution": "return False",
    "prefix": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n        date = date.strip()\n\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            ",
    "suffix": "\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/124/L1",
    "prompt": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n",
    "canonical_solution": "return False",
    "prefix": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n        date = date.strip()\n\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        ",
    "suffix": "\n\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/124/L1",
    "prompt": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n",
    "canonical_solution": "if month in [4,6,9,11] and day < 1 or day > 30:",
    "prefix": "\ndef valid_date(date):\n    \"\"\"-\"\"\"\n    try:\n        date = date.strip()\n\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        ",
    "suffix": "\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/108/L0",
    "prompt": "\ndef count_nums(arr):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return sum(n)",
    "prefix": "\ndef count_nums(arr):\n    \"\"\"-\"\"\"\n\n    def digits_sum(n):\n\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        ",
    "suffix": "\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/108/L0",
    "prompt": "\ndef count_nums(arr):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "neg = 1",
    "prefix": "\ndef count_nums(arr):\n    \"\"\"-\"\"\"\n\n    def digits_sum(n):\n\n        ",
    "suffix": "\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/108/L0",
    "prompt": "\ndef count_nums(arr):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))",
    "prefix": "\ndef count_nums(arr):\n    \"\"\"-\"\"\"\n\n    def digits_sum(n):\n\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/108/L0",
    "prompt": "\ndef count_nums(arr):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if n < 0: n, neg = -1 * n, -1 ",
    "prefix": "\ndef count_nums(arr):\n    \"\"\"-\"\"\"\n\n    def digits_sum(n):\n\n        neg = 1\n        ",
    "suffix": "\n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/108/L0",
    "prompt": "\ndef count_nums(arr):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "n = [int(i) for i in str(n)]",
    "prefix": "\ndef count_nums(arr):\n    \"\"\"-\"\"\"\n\n    def digits_sum(n):\n\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        ",
    "suffix": "\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/108/L0",
    "prompt": "\ndef count_nums(arr):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "n[0] = n[0] * neg",
    "prefix": "\ndef count_nums(arr):\n    \"\"\"-\"\"\"\n\n    def digits_sum(n):\n\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        ",
    "suffix": "\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/86/L0",
    "prompt": "\ndef anti_shuffle(s):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\ndef anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n\n    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/48/L1",
    "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"-\"\"\"\n    for i in range(len(text)):\n",
    "canonical_solution": "return False",
    "prefix": "\n\ndef is_palindrome(text: str):\n    \"\"\"-\"\"\"\n    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n\n            ",
    "suffix": "\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/48/L1",
    "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"-\"\"\"\n    for i in range(len(text)):\n",
    "canonical_solution": "return True",
    "prefix": "\n\ndef is_palindrome(text: str):\n    \"\"\"-\"\"\"\n    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n\n            return False\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/118/L4",
    "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"-\"\"\"\n    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n",
    "canonical_solution": "if (word[i+1] not in vowels) and (word[i-1] not in vowels):",
    "prefix": "\ndef get_closest_vowel(word):\n    \"\"\"-\"\"\"\n    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n\n        if word[i] in vowels:\n            ",
    "suffix": "\n                return word[i]\n    return \"\"\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/118/L4",
    "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"-\"\"\"\n    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n",
    "canonical_solution": "return word[i]",
    "prefix": "\ndef get_closest_vowel(word):\n    \"\"\"-\"\"\"\n    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                ",
    "suffix": "\n    return \"\"\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/118/L4",
    "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"-\"\"\"\n    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n",
    "canonical_solution": "if word[i] in vowels:",
    "prefix": "\ndef get_closest_vowel(word):\n    \"\"\"-\"\"\"\n    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n\n        ",
    "suffix": "\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/118/L4",
    "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"-\"\"\"\n    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n",
    "canonical_solution": "return \"\"",
    "prefix": "\ndef get_closest_vowel(word):\n    \"\"\"-\"\"\"\n    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/31/L3",
    "prompt": "\n\ndef is_prime(n):\n    \"\"\"-\"\"\"\n    if n < 2:\n        return False\n    for k in range(2, n - 1):\n",
    "canonical_solution": "return True",
    "prefix": "\n\ndef is_prime(n):\n    \"\"\"-\"\"\"\n    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n\n            return False\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/31/L3",
    "prompt": "\n\ndef is_prime(n):\n    \"\"\"-\"\"\"\n    if n < 2:\n        return False\n    for k in range(2, n - 1):\n",
    "canonical_solution": "return False",
    "prefix": "\n\ndef is_prime(n):\n    \"\"\"-\"\"\"\n    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n\n            ",
    "suffix": "\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/144/L4",
    "prompt": "\ndef simplify(x, n):\n    \"\"\"-\"\"\"\n    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n",
    "canonical_solution": "return False",
    "prefix": "\ndef simplify(x, n):\n    \"\"\"-\"\"\"\n    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n\n        return True\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/144/L4",
    "prompt": "\ndef simplify(x, n):\n    \"\"\"-\"\"\"\n    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n",
    "canonical_solution": "return True",
    "prefix": "\ndef simplify(x, n):\n    \"\"\"-\"\"\"\n    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n\n        ",
    "suffix": "\n    return False\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/78/L1",
    "prompt": "\ndef hex_key(num):\n    \"\"\"-\"\"\"\n    primes = ('2', '3', '5', '7', 'B', 'D')\n",
    "canonical_solution": "for i in range(0, len(num)):",
    "prefix": "\ndef hex_key(num):\n    \"\"\"-\"\"\"\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n\n    ",
    "suffix": "\n        if num[i] in primes:\n            total += 1\n    return total\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/78/L1",
    "prompt": "\ndef hex_key(num):\n    \"\"\"-\"\"\"\n    primes = ('2', '3', '5', '7', 'B', 'D')\n",
    "canonical_solution": "if num[i] in primes:",
    "prefix": "\ndef hex_key(num):\n    \"\"\"-\"\"\"\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n\n    for i in range(0, len(num)):\n        ",
    "suffix": "\n            total += 1\n    return total\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/78/L1",
    "prompt": "\ndef hex_key(num):\n    \"\"\"-\"\"\"\n    primes = ('2', '3', '5', '7', 'B', 'D')\n",
    "canonical_solution": "return total",
    "prefix": "\ndef hex_key(num):\n    \"\"\"-\"\"\"\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/78/L1",
    "prompt": "\ndef hex_key(num):\n    \"\"\"-\"\"\"\n    primes = ('2', '3', '5', '7', 'B', 'D')\n",
    "canonical_solution": "total += 1",
    "prefix": "\ndef hex_key(num):\n    \"\"\"-\"\"\"\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            ",
    "suffix": "\n    return total\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/143/L0",
    "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if len(word)%i == 0:",
    "prefix": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n    new_lst = []\n\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            ",
    "suffix": "\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/143/L0",
    "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if flg == 0 or len(word) == 2:",
    "prefix": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n    new_lst = []\n\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        ",
    "suffix": "\n            new_lst.append(word)\n    return \" \".join(new_lst)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/143/L0",
    "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if len(word) == 1:",
    "prefix": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n    new_lst = []\n\n    for word in sentence.split():\n        flg = 0\n        ",
    "suffix": "\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/143/L0",
    "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "flg = 0",
    "prefix": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n    new_lst = []\n\n    for word in sentence.split():\n        ",
    "suffix": "\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/143/L0",
    "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "for i in range(2, len(word)):",
    "prefix": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n    new_lst = []\n\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        ",
    "suffix": "\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/143/L0",
    "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "flg = 1",
    "prefix": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n    new_lst = []\n\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                ",
    "suffix": "\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/143/L0",
    "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return \" \".join(new_lst)",
    "prefix": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n    new_lst = []\n\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/143/L0",
    "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "for word in sentence.split():",
    "prefix": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n    new_lst = []\n\n    ",
    "suffix": "\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/143/L0",
    "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "new_lst.append(word)",
    "prefix": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n    new_lst = []\n\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            ",
    "suffix": "\n    return \" \".join(new_lst)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/143/L0",
    "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "flg = 1",
    "prefix": "\ndef words_in_sentence(sentence):\n    \"\"\"-\"\"\"\n\n    new_lst = []\n\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            ",
    "suffix": "\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/111/L12",
    "prompt": "\ndef histogram(test):\n    \"\"\"-\"\"\"\n    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n",
    "canonical_solution": "\ndef histogram(test):\n    \"\"\"Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n\n    \"\"\"\n    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/87/L0",
    "prompt": "\ndef get_row(lst, x):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])",
    "prefix": "\ndef get_row(lst, x):\n    \"\"\"-\"\"\"\n\n    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/123/L0",
    "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "n = n/2",
    "prefix": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n    if n%2==0:\n\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            ",
    "suffix": "\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/123/L0",
    "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "odd_collatz.append(int(n))",
    "prefix": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n    if n%2==0:\n\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            ",
    "suffix": "\n\n    return sorted(odd_collatz)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/123/L0",
    "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if n % 2 == 0:",
    "prefix": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n    if n%2==0:\n\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        ",
    "suffix": "\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/123/L0",
    "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "else:",
    "prefix": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n    if n%2==0:\n\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        ",
    "suffix": "\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/123/L0",
    "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "n = n*3 + 1",
    "prefix": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n    if n%2==0:\n\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            ",
    "suffix": "\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/123/L0",
    "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return sorted(odd_collatz)",
    "prefix": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n    if n%2==0:\n\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/123/L0",
    "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "odd_collatz = [] ",
    "prefix": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n    if n%2==0:\n\n        ",
    "suffix": "\n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/123/L0",
    "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "while n > 1:",
    "prefix": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n    if n%2==0:\n\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    ",
    "suffix": "\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/123/L0",
    "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "odd_collatz = [n]",
    "prefix": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n    if n%2==0:\n\n        odd_collatz = [] \n    else:\n        ",
    "suffix": "\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/123/L0",
    "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "else:",
    "prefix": "\ndef get_odd_collatz(n):\n    \"\"\"-\"\"\"\n\n    if n%2==0:\n\n        odd_collatz = [] \n    ",
    "suffix": "\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/135/L5",
    "prompt": "\ndef can_arrange(arr):\n    \"\"\"-\"\"\"\n    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n",
    "canonical_solution": "return ind",
    "prefix": "\ndef can_arrange(arr):\n    \"\"\"-\"\"\"\n    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/19/L11",
    "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"-\"\"\"\n    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n",
    "canonical_solution": "return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))",
    "prefix": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"-\"\"\"\n    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/65/L0",
    "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return s[::-1]",
    "prefix": "\ndef circular_shift(x, shift):\n    \"\"\"-\"\"\"\n\n    s = str(x)\n\n    if shift > len(s):\n        ",
    "suffix": "\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/65/L0",
    "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return s[len(s) - shift:] + s[:len(s) - shift]",
    "prefix": "\ndef circular_shift(x, shift):\n    \"\"\"-\"\"\"\n\n    s = str(x)\n\n    if shift > len(s):\n        return s[::-1]\n    else:\n        ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/65/L0",
    "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if shift > len(s):",
    "prefix": "\ndef circular_shift(x, shift):\n    \"\"\"-\"\"\"\n\n    s = str(x)\n\n    ",
    "suffix": "\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/65/L0",
    "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "else:",
    "prefix": "\ndef circular_shift(x, shift):\n    \"\"\"-\"\"\"\n\n    s = str(x)\n\n    if shift > len(s):\n        return s[::-1]\n    ",
    "suffix": "\n        return s[len(s) - shift:] + s[:len(s) - shift]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/142/L1",
    "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n    result =[]\n",
    "canonical_solution": "return sum(result)",
    "prefix": "\n\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n    result =[]\n    for i in range(len(lst)):\n\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/142/L1",
    "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n    result =[]\n",
    "canonical_solution": "else:",
    "prefix": "\n\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n    result =[]\n    for i in range(len(lst)):\n\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        ",
    "suffix": "\n            result.append(lst[i])\n    return sum(result)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/142/L1",
    "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n    result =[]\n",
    "canonical_solution": "result.append(lst[i])",
    "prefix": "\n\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n    result =[]\n    for i in range(len(lst)):\n\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            ",
    "suffix": "\n    return sum(result)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/142/L1",
    "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n    result =[]\n",
    "canonical_solution": "result.append(lst[i]**2)",
    "prefix": "\n\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n    result =[]\n    for i in range(len(lst)):\n\n        if i %3 == 0:\n            ",
    "suffix": "\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/142/L1",
    "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n    result =[]\n",
    "canonical_solution": "elif i % 4 == 0 and i%3 != 0:",
    "prefix": "\n\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n    result =[]\n    for i in range(len(lst)):\n\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        ",
    "suffix": "\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/142/L1",
    "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n    result =[]\n",
    "canonical_solution": "result.append(lst[i]**3)",
    "prefix": "\n\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n    result =[]\n    for i in range(len(lst)):\n\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            ",
    "suffix": "\n        else:\n            result.append(lst[i])\n    return sum(result)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/142/L1",
    "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n    result =[]\n",
    "canonical_solution": "if i %3 == 0:",
    "prefix": "\n\n\ndef sum_squares(lst):\n    \"\"\"-\"\"\"\n    result =[]\n    for i in range(len(lst)):\n\n        ",
    "suffix": "\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/94/L12",
    "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"-\"\"\"\n    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n",
    "canonical_solution": "return result",
    "prefix": "\n\ndef skjkasdkd(lst):\n    \"\"\"-\"\"\"\n    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n\n    ",
    "suffix": "\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/8/L4",
    "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"-\"\"\"\n    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n",
    "canonical_solution": "prod_value *= n",
    "prefix": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"-\"\"\"\n    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n\n        ",
    "suffix": "\n    return sum_value, prod_value\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/8/L4",
    "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"-\"\"\"\n    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n",
    "canonical_solution": "return sum_value, prod_value",
    "prefix": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"-\"\"\"\n    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n\n        prod_value *= n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/102/L3",
    "prompt": "\ndef choose_num(x, y):\n    \"\"\"-\"\"\"\n    if x > y:\n        return -1\n    if y % 2 == 0:\n",
    "canonical_solution": "return -1",
    "prefix": "\ndef choose_num(x, y):\n    \"\"\"-\"\"\"\n    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n\n    if x == y:\n        ",
    "suffix": "\n    return y - 1\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/102/L3",
    "prompt": "\ndef choose_num(x, y):\n    \"\"\"-\"\"\"\n    if x > y:\n        return -1\n    if y % 2 == 0:\n",
    "canonical_solution": "if x == y:",
    "prefix": "\ndef choose_num(x, y):\n    \"\"\"-\"\"\"\n    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n\n    ",
    "suffix": "\n        return -1\n    return y - 1\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/102/L3",
    "prompt": "\ndef choose_num(x, y):\n    \"\"\"-\"\"\"\n    if x > y:\n        return -1\n    if y % 2 == 0:\n",
    "canonical_solution": "return y - 1",
    "prefix": "\ndef choose_num(x, y):\n    \"\"\"-\"\"\"\n    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n\n    if x == y:\n        return -1\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/136/L0",
    "prompt": "\ndef largest_smallest_integers(lst):\n    '''-'''\n\n",
    "canonical_solution": "return (max(smallest) if smallest else None, min(largest) if largest else None)",
    "prefix": "\ndef largest_smallest_integers(lst):\n    '''-'''\n\n    smallest = list(filter(lambda x: x < 0, lst))\n\n    largest = list(filter(lambda x: x > 0, lst))\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/136/L0",
    "prompt": "\ndef largest_smallest_integers(lst):\n    '''-'''\n\n",
    "canonical_solution": "largest = list(filter(lambda x: x > 0, lst))",
    "prefix": "\ndef largest_smallest_integers(lst):\n    '''-'''\n\n    smallest = list(filter(lambda x: x < 0, lst))\n\n    ",
    "suffix": "\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/16/L0",
    "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n\n    return len(set(string.lower()))\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/100/L0",
    "prompt": "\ndef make_a_pile(n):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\ndef make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n\n    return [n + 2*i for i in range(n)]\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/128/L2",
    "prompt": "\ndef prod_signs(arr):\n    \"\"\"-\"\"\"\n    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n",
    "canonical_solution": "\ndef prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/114/L3",
    "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"-\"\"\"\n    max_sum = 0\n    s = 0\n    for num in nums:\n",
    "canonical_solution": "s = 0",
    "prefix": "\ndef minSubArraySum(nums):\n    \"\"\"-\"\"\"\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n\n        if (s < 0):\n            ",
    "suffix": "\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/114/L3",
    "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"-\"\"\"\n    max_sum = 0\n    s = 0\n    for num in nums:\n",
    "canonical_solution": "min_sum = -max_sum",
    "prefix": "\ndef minSubArraySum(nums):\n    \"\"\"-\"\"\"\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    ",
    "suffix": "\n    return min_sum\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/114/L3",
    "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"-\"\"\"\n    max_sum = 0\n    s = 0\n    for num in nums:\n",
    "canonical_solution": "return min_sum",
    "prefix": "\ndef minSubArraySum(nums):\n    \"\"\"-\"\"\"\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/114/L3",
    "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"-\"\"\"\n    max_sum = 0\n    s = 0\n    for num in nums:\n",
    "canonical_solution": "max_sum = max(-i for i in nums)",
    "prefix": "\ndef minSubArraySum(nums):\n    \"\"\"-\"\"\"\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        ",
    "suffix": "\n    min_sum = -max_sum\n    return min_sum\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/114/L3",
    "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"-\"\"\"\n    max_sum = 0\n    s = 0\n    for num in nums:\n",
    "canonical_solution": "max_sum = max(s, max_sum)",
    "prefix": "\ndef minSubArraySum(nums):\n    \"\"\"-\"\"\"\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n\n        if (s < 0):\n            s = 0\n        ",
    "suffix": "\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/114/L3",
    "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"-\"\"\"\n    max_sum = 0\n    s = 0\n    for num in nums:\n",
    "canonical_solution": "if (s < 0):",
    "prefix": "\ndef minSubArraySum(nums):\n    \"\"\"-\"\"\"\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n\n        ",
    "suffix": "\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/114/L3",
    "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"-\"\"\"\n    max_sum = 0\n    s = 0\n    for num in nums:\n",
    "canonical_solution": "if max_sum == 0:",
    "prefix": "\ndef minSubArraySum(nums):\n    \"\"\"-\"\"\"\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    ",
    "suffix": "\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/15/L0",
    "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n\n    return ' '.join([str(x) for x in range(n + 1)])\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/154/L3",
    "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"-\"\"\"\n    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n",
    "canonical_solution": "if a[i:i+l] == pat[j:j+l]:",
    "prefix": "\ndef cycpattern_check(a , b):\n    \"\"\"-\"\"\"\n    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n\n            ",
    "suffix": "\n                return True\n    return False\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/154/L3",
    "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"-\"\"\"\n    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n",
    "canonical_solution": "return False",
    "prefix": "\ndef cycpattern_check(a , b):\n    \"\"\"-\"\"\"\n    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/154/L3",
    "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"-\"\"\"\n    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n",
    "canonical_solution": "return True",
    "prefix": "\ndef cycpattern_check(a , b):\n    \"\"\"-\"\"\"\n    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n\n            if a[i:i+l] == pat[j:j+l]:\n                ",
    "suffix": "\n    return False\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/57/L0",
    "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return True",
    "prefix": "\n\ndef monotonic(l: list):\n    \"\"\"-\"\"\"\n\n    if l == sorted(l) or l == sorted(l, reverse=True):\n\n        ",
    "suffix": "\n    return False\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/57/L0",
    "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return False",
    "prefix": "\n\ndef monotonic(l: list):\n    \"\"\"-\"\"\"\n\n    if l == sorted(l) or l == sorted(l, reverse=True):\n\n        return True\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/12/L5",
    "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"-\"\"\"\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n",
    "canonical_solution": "return s",
    "prefix": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"-\"\"\"\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n\n            ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/52/L1",
    "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"-\"\"\"\n    for e in l:\n",
    "canonical_solution": "return False",
    "prefix": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"-\"\"\"\n    for e in l:\n        if e >= t:\n\n            ",
    "suffix": "\n    return True\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/52/L1",
    "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"-\"\"\"\n    for e in l:\n",
    "canonical_solution": "return True",
    "prefix": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"-\"\"\"\n    for e in l:\n        if e >= t:\n\n            return False\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/75/L3",
    "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n",
    "canonical_solution": "return True",
    "prefix": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n\n        ",
    "suffix": "\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/75/L3",
    "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n",
    "canonical_solution": "if not is_prime(k): continue",
    "prefix": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                ",
    "suffix": "\n                if i*j*k == a: return True\n    return False\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/75/L3",
    "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n",
    "canonical_solution": "if not is_prime(j): continue",
    "prefix": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            ",
    "suffix": "\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/75/L3",
    "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n",
    "canonical_solution": "if not is_prime(i): continue",
    "prefix": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n\n        return True\n\n    for i in range(2,101):\n        ",
    "suffix": "\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/75/L3",
    "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n",
    "canonical_solution": "for j in range(2,101):",
    "prefix": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        ",
    "suffix": "\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/75/L3",
    "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n",
    "canonical_solution": "return False",
    "prefix": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/75/L3",
    "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n",
    "canonical_solution": "for i in range(2,101):",
    "prefix": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n\n        return True\n\n    ",
    "suffix": "\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/75/L3",
    "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n",
    "canonical_solution": "if i*j*k == a: return True",
    "prefix": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                ",
    "suffix": "\n    return False\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/75/L3",
    "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n",
    "canonical_solution": "for k in range(2,101):",
    "prefix": "\ndef is_multiply_prime(a):\n    \"\"\"-\"\"\"\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            ",
    "suffix": "\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/30/L0",
    "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\n\ndef get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n    return [e for e in l if e > 0]\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/33/L2",
    "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"-\"\"\"\n    l = list(l)\n    l[::3] = sorted(l[::3])\n",
    "canonical_solution": "\n\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/6/L6",
    "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"-\"\"\"\n    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n",
    "canonical_solution": "else:",
    "prefix": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"-\"\"\"\n    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n\n            ",
    "suffix": "\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/6/L6",
    "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"-\"\"\"\n    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n",
    "canonical_solution": "return [parse_paren_group(x) for x in paren_string.split(' ') if x]",
    "prefix": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"-\"\"\"\n    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n\n            else:\n                depth -= 1\n\n        return max_depth\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/6/L6",
    "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"-\"\"\"\n    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n",
    "canonical_solution": "depth -= 1",
    "prefix": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"-\"\"\"\n    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n\n            else:\n                ",
    "suffix": "\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/6/L6",
    "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"-\"\"\"\n    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n",
    "canonical_solution": "return max_depth",
    "prefix": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"-\"\"\"\n    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n\n            else:\n                depth -= 1\n\n        ",
    "suffix": "\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/45/L0",
    "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\n\ndef triangle_area(a, h):\n    \"\"\"Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n\n    return a * h / 2.0\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/97/L0",
    "prompt": "\ndef multiply(a, b):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\ndef multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n    \"\"\"\n\n    return abs(a % 10) * abs(b % 10)\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/4/L1",
    "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"-\"\"\"\n    mean = sum(numbers) / len(numbers)\n",
    "canonical_solution": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/58/L0",
    "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "ret.add(e1)",
    "prefix": "\n\ndef common(l1: list, l2: list):\n    \"\"\"-\"\"\"\n\n    ret = set()\n\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ",
    "suffix": "\n    return sorted(list(ret))\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/58/L0",
    "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if e1 == e2:",
    "prefix": "\n\ndef common(l1: list, l2: list):\n    \"\"\"-\"\"\"\n\n    ret = set()\n\n    for e1 in l1:\n        for e2 in l2:\n            ",
    "suffix": "\n                ret.add(e1)\n    return sorted(list(ret))\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/58/L0",
    "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "for e1 in l1:",
    "prefix": "\n\ndef common(l1: list, l2: list):\n    \"\"\"-\"\"\"\n\n    ret = set()\n\n    ",
    "suffix": "\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/58/L0",
    "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return sorted(list(ret))",
    "prefix": "\n\ndef common(l1: list, l2: list):\n    \"\"\"-\"\"\"\n\n    ret = set()\n\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/58/L0",
    "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "for e2 in l2:",
    "prefix": "\n\ndef common(l1: list, l2: list):\n    \"\"\"-\"\"\"\n\n    ret = set()\n\n    for e1 in l1:\n        ",
    "suffix": "\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/156/L13",
    "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"-\"\"\"\n    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n",
    "canonical_solution": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/67/L4",
    "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"-\"\"\"\n    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n",
    "canonical_solution": "\ndef fruit_distribution(s,n):\n    \"\"\"\n    In this task, you will be given a string that represents a number of apples and oranges \n    that are distributed in a basket of fruit this basket contains \n    apples, oranges, and mango fruits. Given the string that represents the total number of \n    the oranges and apples and an integer that represent the total number of the fruits \n    in the basket return the number of the mango fruits in the basket.\n    for examble:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n    fruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n    fruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n    \"\"\"\n    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/112/L1",
    "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"-\"\"\"\n    s = ''.join([char for char in s if char not in c])\n",
    "canonical_solution": "\ndef reverse_delete(s,c):\n    \"\"\"Task\n    We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n    then check if the result string is palindrome.\n    A string is called palindrome if it reads the same backward as forward.\n    You should return a tuple containing the result string and True/False for the check.\n    Example\n    For s = \"abcde\", c = \"ae\", the result should be ('bcd',False)\n    For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n    For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\n    \"\"\"\n    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/13/L0",
    "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "a, b = b, a % b",
    "prefix": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"-\"\"\"\n\n    while b:\n\n        ",
    "suffix": "\n    return a\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/13/L0",
    "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return a",
    "prefix": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"-\"\"\"\n\n    while b:\n\n        a, b = b, a % b\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/125/L1",
    "prompt": "\ndef split_words(txt):\n    '''-'''\n    if \" \" in txt:\n",
    "canonical_solution": "else:",
    "prefix": "\ndef split_words(txt):\n    '''-'''\n    if \" \" in txt:\n        return txt.split()\n\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    ",
    "suffix": "\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/125/L1",
    "prompt": "\ndef split_words(txt):\n    '''-'''\n    if \" \" in txt:\n",
    "canonical_solution": "return txt.replace(',',' ').split()",
    "prefix": "\ndef split_words(txt):\n    '''-'''\n    if \" \" in txt:\n        return txt.split()\n\n    elif \",\" in txt:\n        ",
    "suffix": "\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/125/L1",
    "prompt": "\ndef split_words(txt):\n    '''-'''\n    if \" \" in txt:\n",
    "canonical_solution": "elif \",\" in txt:",
    "prefix": "\ndef split_words(txt):\n    '''-'''\n    if \" \" in txt:\n        return txt.split()\n\n    ",
    "suffix": "\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/125/L1",
    "prompt": "\ndef split_words(txt):\n    '''-'''\n    if \" \" in txt:\n",
    "canonical_solution": "return len([i for i in txt if i.islower() and ord(i)%2 == 0])",
    "prefix": "\ndef split_words(txt):\n    '''-'''\n    if \" \" in txt:\n        return txt.split()\n\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/116/L0",
    "prompt": "\ndef sort_array(arr):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\ndef sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n\n    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/28/L0",
    "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n\n    return ''.join(strings)\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/149/L3",
    "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"-\"\"\"\n    lst.sort()\n    new_lst = []\n    for i in lst:\n",
    "canonical_solution": "new_lst.append(i)",
    "prefix": "\ndef sorted_list_sum(lst):\n    \"\"\"-\"\"\"\n    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n\n            ",
    "suffix": "\n    return sorted(new_lst, key=len)\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/149/L3",
    "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"-\"\"\"\n    lst.sort()\n    new_lst = []\n    for i in lst:\n",
    "canonical_solution": "return sorted(new_lst, key=len)",
    "prefix": "\ndef sorted_list_sum(lst):\n    \"\"\"-\"\"\"\n    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n\n            new_lst.append(i)\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/7/L0",
    "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n\n    return [x for x in strings if substring in x]\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/99/L15",
    "prompt": "\ndef closest_integer(value):\n    '''-'''\n    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # -\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n",
    "canonical_solution": "return res",
    "prefix": "\ndef closest_integer(value):\n    '''-'''\n    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # -\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n\n        res = 0\n\n    ",
    "suffix": "\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/99/L15",
    "prompt": "\ndef closest_integer(value):\n    '''-'''\n    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # -\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n",
    "canonical_solution": "res = 0",
    "prefix": "\ndef closest_integer(value):\n    '''-'''\n    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # -\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n\n        ",
    "suffix": "\n\n    return res\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/64/L2",
    "prompt": "\nFIX = \"\"\"-\"\"\"\n\ndef vowels_count(s):\n    \"\"\"-\"\"\"\n    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n",
    "canonical_solution": "return n_vowels",
    "prefix": "\nFIX = \"\"\"-\"\"\"\n\ndef vowels_count(s):\n    \"\"\"-\"\"\"\n    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n\n        n_vowels += 1\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/64/L2",
    "prompt": "\nFIX = \"\"\"-\"\"\"\n\ndef vowels_count(s):\n    \"\"\"-\"\"\"\n    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n",
    "canonical_solution": "n_vowels += 1",
    "prefix": "\nFIX = \"\"\"-\"\"\"\n\ndef vowels_count(s):\n    \"\"\"-\"\"\"\n    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n\n        ",
    "suffix": "\n    return n_vowels\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/158/L0",
    "prompt": "\ndef find_max(words):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\ndef find_max(words):\n    \"\"\"Write a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number\n    of unique characters. If multiple strings have maximum number of unique\n    characters, return the one which comes first in lexicographical order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n    \"\"\"\n\n    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/162/L1",
    "prompt": "\ndef string_to_md5(text):\n    \"\"\"-\"\"\"\n    import hashlib\n",
    "canonical_solution": "\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/44/L0",
    "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return ret",
    "prefix": "\n\ndef change_base(x: int, base: int):\n    \"\"\"-\"\"\"\n\n    ret = \"\"\n\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/44/L0",
    "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "x //= base",
    "prefix": "\n\ndef change_base(x: int, base: int):\n    \"\"\"-\"\"\"\n\n    ret = \"\"\n\n    while x > 0:\n        ret = str(x % base) + ret\n        ",
    "suffix": "\n    return ret\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/44/L0",
    "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "while x > 0:",
    "prefix": "\n\ndef change_base(x: int, base: int):\n    \"\"\"-\"\"\"\n\n    ret = \"\"\n\n    ",
    "suffix": "\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/44/L0",
    "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "ret = str(x % base) + ret",
    "prefix": "\n\ndef change_base(x: int, base: int):\n    \"\"\"-\"\"\"\n\n    ret = \"\"\n\n    while x > 0:\n        ",
    "suffix": "\n        x //= base\n    return ret\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/157/L0",
    "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''-'''\n\n",
    "canonical_solution": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n\n    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/81/L21",
    "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n",
    "canonical_solution": "letter_grade.append(\"D-\")",
    "prefix": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            ",
    "suffix": "\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/81/L21",
    "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n",
    "canonical_solution": "letter_grade.append(\"E\")",
    "prefix": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            ",
    "suffix": "\n    return letter_grade\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/81/L21",
    "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n",
    "canonical_solution": "elif gpa > 1.0:",
    "prefix": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n\n        ",
    "suffix": "\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/81/L21",
    "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n",
    "canonical_solution": "letter_grade.append(\"D+\")",
    "prefix": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n\n        elif gpa > 1.0:\n            ",
    "suffix": "\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/81/L21",
    "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n",
    "canonical_solution": "elif gpa > 0.0:",
    "prefix": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        ",
    "suffix": "\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/81/L21",
    "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n",
    "canonical_solution": "return letter_grade",
    "prefix": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/81/L21",
    "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n",
    "canonical_solution": "letter_grade.append(\"D\")",
    "prefix": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            ",
    "suffix": "\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/81/L21",
    "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n",
    "canonical_solution": "else:",
    "prefix": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        ",
    "suffix": "\n            letter_grade.append(\"E\")\n    return letter_grade\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/81/L21",
    "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n",
    "canonical_solution": "elif gpa > 0.7:",
    "prefix": "\ndef numerical_letter_grade(grades):\n    \"\"\"-\"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        ",
    "suffix": "\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/5/L11",
    "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"-\"\"\"\n    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n",
    "canonical_solution": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/146/L4",
    "prompt": "\ndef specialFilter(nums):\n    \"\"\"-\"\"\"\n    \n    count = 0\n    for num in nums:\n        if num > 10:\n",
    "canonical_solution": "if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:",
    "prefix": "\ndef specialFilter(nums):\n    \"\"\"-\"\"\"\n    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n\n            number_as_string = str(num)\n            ",
    "suffix": "\n                count += 1\n        \n    return count \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/146/L4",
    "prompt": "\ndef specialFilter(nums):\n    \"\"\"-\"\"\"\n    \n    count = 0\n    for num in nums:\n        if num > 10:\n",
    "canonical_solution": "number_as_string = str(num)",
    "prefix": "\ndef specialFilter(nums):\n    \"\"\"-\"\"\"\n    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n\n            ",
    "suffix": "\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/146/L4",
    "prompt": "\ndef specialFilter(nums):\n    \"\"\"-\"\"\"\n    \n    count = 0\n    for num in nums:\n        if num > 10:\n",
    "canonical_solution": "return count ",
    "prefix": "\ndef specialFilter(nums):\n    \"\"\"-\"\"\"\n    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/146/L4",
    "prompt": "\ndef specialFilter(nums):\n    \"\"\"-\"\"\"\n    \n    count = 0\n    for num in nums:\n        if num > 10:\n",
    "canonical_solution": "count += 1",
    "prefix": "\ndef specialFilter(nums):\n    \"\"\"-\"\"\"\n    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                ",
    "suffix": "\n        \n    return count \n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/60/L0",
    "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n\n    return sum(range(n + 1))\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/26/L0",
    "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return [n for n in numbers if c[n] <= 1]",
    "prefix": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"-\"\"\"\n\n    import collections\n\n    c = collections.Counter(numbers)\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/26/L0",
    "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "c = collections.Counter(numbers)",
    "prefix": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"-\"\"\"\n\n    import collections\n\n    ",
    "suffix": "\n    return [n for n in numbers if c[n] <= 1]\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/163/L1",
    "prompt": "\ndef generate_integers(a, b):\n    \"\"\"-\"\"\"\n    lower = max(2, min(a, b))\n",
    "canonical_solution": "return [i for i in range(lower, upper+1) if i % 2 == 0]",
    "prefix": "\ndef generate_integers(a, b):\n    \"\"\"-\"\"\"\n    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/9/L6",
    "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"-\"\"\"\n    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n",
    "canonical_solution": "result.append(running_max)",
    "prefix": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"-\"\"\"\n    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n\n            running_max = max(running_max, n)\n\n        ",
    "suffix": "\n\n    return result\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/9/L6",
    "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"-\"\"\"\n    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n",
    "canonical_solution": "return result",
    "prefix": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"-\"\"\"\n    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/9/L6",
    "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"-\"\"\"\n    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n",
    "canonical_solution": "running_max = max(running_max, n)",
    "prefix": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"-\"\"\"\n    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n\n            ",
    "suffix": "\n\n        result.append(running_max)\n\n    return result\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/3/L0",
    "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return True",
    "prefix": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"-\"\"\"\n\n    balance = 0\n\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            ",
    "suffix": "\n\n    return False\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/3/L0",
    "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "balance += op",
    "prefix": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"-\"\"\"\n\n    balance = 0\n\n\n    for op in operations:\n        ",
    "suffix": "\n        if balance < 0:\n            return True\n\n    return False\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/3/L0",
    "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "return False",
    "prefix": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"-\"\"\"\n\n    balance = 0\n\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/3/L0",
    "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "for op in operations:",
    "prefix": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"-\"\"\"\n\n    balance = 0\n\n\n    ",
    "suffix": "\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/3/L0",
    "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "if balance < 0:",
    "prefix": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"-\"\"\"\n\n    balance = 0\n\n\n    for op in operations:\n        balance += op\n        ",
    "suffix": "\n            return True\n\n    return False\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/69/L5",
    "prompt": "\ndef search(lst):\n    '''-'''\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n",
    "canonical_solution": "return ans",
    "prefix": "\ndef search(lst):\n    '''-'''\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n\n        if frq[i] >= i:\n            ans = i\n    \n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/69/L5",
    "prompt": "\ndef search(lst):\n    '''-'''\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n",
    "canonical_solution": "if frq[i] >= i:",
    "prefix": "\ndef search(lst):\n    '''-'''\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n\n        ",
    "suffix": "\n            ans = i\n    \n    return ans\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/69/L5",
    "prompt": "\ndef search(lst):\n    '''-'''\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n",
    "canonical_solution": "ans = i",
    "prefix": "\ndef search(lst):\n    '''-'''\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n\n        if frq[i] >= i:\n            ",
    "suffix": "\n    \n    return ans\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/61/L1",
    "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"-\"\"\"\n    depth = 0\n",
    "canonical_solution": "depth -= 1",
    "prefix": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"-\"\"\"\n    depth = 0\n    for b in brackets:\n\n        if b == \"(\":\n            depth += 1\n        else:\n            ",
    "suffix": "\n        if depth < 0:\n            return False\n    return depth == 0\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/61/L1",
    "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"-\"\"\"\n    depth = 0\n",
    "canonical_solution": "return False",
    "prefix": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"-\"\"\"\n    depth = 0\n    for b in brackets:\n\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            ",
    "suffix": "\n    return depth == 0\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/61/L1",
    "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"-\"\"\"\n    depth = 0\n",
    "canonical_solution": "if depth < 0:",
    "prefix": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"-\"\"\"\n    depth = 0\n    for b in brackets:\n\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        ",
    "suffix": "\n            return False\n    return depth == 0\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/61/L1",
    "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"-\"\"\"\n    depth = 0\n",
    "canonical_solution": "if b == \"(\":",
    "prefix": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"-\"\"\"\n    depth = 0\n    for b in brackets:\n\n        ",
    "suffix": "\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/61/L1",
    "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"-\"\"\"\n    depth = 0\n",
    "canonical_solution": "else:",
    "prefix": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"-\"\"\"\n    depth = 0\n    for b in brackets:\n\n        if b == \"(\":\n            depth += 1\n        ",
    "suffix": "\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/61/L1",
    "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"-\"\"\"\n    depth = 0\n",
    "canonical_solution": "depth += 1",
    "prefix": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"-\"\"\"\n    depth = 0\n    for b in brackets:\n\n        if b == \"(\":\n            ",
    "suffix": "\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/61/L1",
    "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"-\"\"\"\n    depth = 0\n",
    "canonical_solution": "return depth == 0",
    "prefix": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"-\"\"\"\n    depth = 0\n    for b in brackets:\n\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/37/L7",
    "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"-\"\"\"\n    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n",
    "canonical_solution": "return ans",
    "prefix": "\n\ndef sort_even(l: list):\n    \"\"\"-\"\"\"\n    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n\n    ",
    "suffix": "\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/54/L0",
    "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"-\"\"\"\n\n",
    "canonical_solution": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n\n    return set(s0) == set(s1)\n\n"
  },
  {
    "name": "SingleLineInfilling/HumanEval/56/L7",
    "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"-\"\"\"\n    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n",
    "canonical_solution": "return depth == 0",
    "prefix": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"-\"\"\"\n    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n\n    ",
    "suffix": "\n"
  }
]